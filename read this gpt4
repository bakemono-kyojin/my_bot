can you give me the updated .py and add also more functionalities? Also let me show you a bot folder that i have downloaded before, you can use everything for referrcence seems it seem quite quite advanced. 
Folder is TelegramGoddsInBot:
.github > funding.yaml:
# These are supported funding model platforms

github: rashidovich2 # Replace with up to 4 GitHub Sponsors-enabled usernames e.g., [user1, user2]
patreon: # Replace with a single Patreon username
open_collective: # Replace with a single Open Collective username
ko_fi: # Replace with a single Ko-fi username
tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
otechie: # Replace with a single Otechie username
lfx_crowdfunding: # Replace with a single LFX Crowdfunding project-name e.g., cloud-foundry
custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']

.idea>inspectionProfiles>profiles_settings.xml:
<component name="InspectionProjectProfileManager">
  <settings>
    <option name="USE_PROJECT_PROFILE" value="false" />
    <version value="1.0" />
  </settings>
</component>

.idea>bot3101f.iml:
<?xml version="1.0" encoding="UTF-8"?>
<module type="PYTHON_MODULE" version="4">
  <component name="NewModuleRootManager">
    <content url="file://$MODULE_DIR$">
      <excludeFolder url="file://$MODULE_DIR$/venv" />
    </content>
    <orderEntry type="jdk" jdkName="Python 3.10 (bot3101f)" jdkType="Python SDK" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
  <component name="PyDocumentationSettings">
    <option name="renderExternalDocumentation" value="true" />
  </component>
</module>

.idea>deployment.xml:
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="PublishConfigData" serverName="91.236.79.57" remoteFilesAllowedToDisappearOnAutoupload="false" />
</project>

.idea>misc.xml:
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10 (bot3101f)" project-jdk-type="Python SDK" />
</project>

.idea>modules.xml
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/bot3101f.iml" filepath="$PROJECT_DIR$/.idea/bot3101f.iml" />
    </modules>
  </component>
</project>

.idea>other.xml:
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="PySciProjectComponent">
    <option name="PY_SCI_VIEW" value="true" />
  </component>
</project>

.idea>vcs.xml:
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="$PROJECT_DIR$" vcs="Git" />
  </component>
</project>

.idea>webServers.xml:
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="WebServers">
    <option name="servers">
      <webServer id="63d7e582-8fed-481f-bcdd-ffc0058cbd42" name="91.236.79.57 (project level)">
        <fileTransfer rootFolder="/var/local/bot3101f" accessType="SFTP" host="91.236.79.57" port="22" sshConfigId="d1631d33-4f0b-4914-a303-29ce23df39f1" sshConfig="root@91.236.79.57:22 password">
          <advancedOptions>
            <advancedOptions dataProtectionLevel="Private" keepAliveTimeout="0" passiveMode="true" shareSSLContext="true" />
          </advancedOptions>
        </fileTransfer>
      </webServer>
    </option>
  </component>
</project>

.idea>workspace.xml:
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="1a816423-3e7d-4c8e-87b0-1b3045c22518" name="Changes" comment="">
      <change afterPath="$PROJECT_DIR$/123" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/setup.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/.gitignore" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/autoshopDjimbo3.1.iml" beforeDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/modules.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/modules.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/vcs.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/vcs.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/main.py" beforeDir="false" afterPath="$PROJECT_DIR$/main.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/requirements.txt" beforeDir="false" afterPath="$PROJECT_DIR$/requirements.txt" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/settings.ini" beforeDir="false" afterPath="$PROJECT_DIR$/settings.ini" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/data/config.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/data/config.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/data/database.db" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/data/database.db" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/data/logs.log" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/data/logs.log" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/__init__.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/__init__.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/admin_functions.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/admin_functions.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/admin_menu.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/admin_menu.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/admin_payment.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/admin_payment.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/admin_products.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/admin_products.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/admin_products_shop.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/admin_products_shop.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/admin_settings.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/admin_settings.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/main_start.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/main_start.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/user_location.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/user_location.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/user_menu.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/user_menu.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/user_transactions.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/user_transactions.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/z_all_errors.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/z_all_errors.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/handlers/z_all_missed_.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/handlers/z_all_missed_.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/keyboards/inline_admin.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/keyboards/inline_admin.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/keyboards/inline_user.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/keyboards/inline_user.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/keyboards/inline_z_all.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/keyboards/inline_z_all.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/keyboards/inline_z_page.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/keyboards/inline_z_page.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/keyboards/location_keyboards.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/keyboards/location_keyboards.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/keyboards/reply_z_all.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/keyboards/reply_z_all.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/keyboards/shop_keyboards.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/keyboards/shop_keyboards.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/loader.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/loader.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/middlewares/__init__.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/middlewares/__init__.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/middlewares/exists_user.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/middlewares/exists_user.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/middlewares/throttling.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/middlewares/throttling.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/services/api_qiwi.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/services/api_qiwi.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/services/api_session.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/services/api_session.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/services/api_sqlite.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/services/api_sqlite.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/services/api_sqlite_shop.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/services/api_sqlite_shop.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/services/location_function.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/services/location_function.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/services/location_stat.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/services/location_stat.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/utils/const_functions.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/utils/const_functions.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/utils/misc/bot_commands.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/utils/misc/bot_commands.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/utils/misc/bot_filters.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/utils/misc/bot_filters.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/utils/misc/bot_logging.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/utils/misc/bot_logging.py" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/tgbot/utils/misc_functions.py" beforeDir="false" afterPath="$PROJECT_DIR$/tgbot/utils/misc_functions.py" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Setup Script" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="GitSEFilterConfiguration">
    <file-type-list>
      <filtered-out-file-type name="LOCAL_BRANCH" />
      <filtered-out-file-type name="REMOTE_BRANCH" />
      <filtered-out-file-type name="TAG" />
      <filtered-out-file-type name="COMMIT_BY_MESSAGE" />
    </file-type-list>
  </component>
  <component name="ProjectId" id="2GoMIDEecWP0SmO5bEGV2ogWiZA" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="ASKED_ADD_EXTERNAL_FILES" value="true" />
    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
    <property name="RunOnceActivity.ShowReadmeOnStart" value="true" />
    <property name="WebServerToolWindowFactoryState" value="false" />
    <property name="WebServerToolWindowPanel.toolwindow.highlight.mappings" value="true" />
    <property name="WebServerToolWindowPanel.toolwindow.highlight.symlinks" value="true" />
    <property name="WebServerToolWindowPanel.toolwindow.show.date" value="false" />
    <property name="WebServerToolWindowPanel.toolwindow.show.permissions" value="false" />
    <property name="WebServerToolWindowPanel.toolwindow.show.size" value="false" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="nodejs_interpreter_path.stuck_in_default_project" value="undefined stuck path" />
    <property name="nodejs_npm_path_reset_for_default_project" value="true" />
    <property name="settings.editor.selected.configurable" value="preferences.pluginManager" />
  </component>
  <component name="RunManager">
    <configuration default="true" type="PythonConfigurationType" factoryName="Python">
      <module name="bot3101f" />
      <option name="INTERPRETER_OPTIONS" value="" />
      <option name="PARENT_ENVS" value="true" />
      <envs>
        <env name="PYTHONUNBUFFERED" value="1" />
      </envs>
      <option name="SDK_HOME" value="" />
      <option name="WORKING_DIRECTORY" value="" />
      <option name="IS_MODULE_SDK" value="false" />
      <option name="ADD_CONTENT_ROOTS" value="true" />
      <option name="ADD_SOURCE_ROOTS" value="true" />
      <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
      <option name="SCRIPT_NAME" value="" />
      <option name="PARAMETERS" value="" />
      <option name="SHOW_COMMAND_LINE" value="true" />
      <option name="EMULATE_TERMINAL" value="false" />
      <option name="MODULE_MODE" value="false" />
      <option name="REDIRECT_INPUT" value="false" />
      <option name="INPUT_FILE" value="" />
      <method v="2" />
    </configuration>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="1a816423-3e7d-4c8e-87b0-1b3045c22518" name="Changes" comment="" />
      <created>1667050422078</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1667050422078</updated>
      <workItem from="1667050433375" duration="435000" />
      <workItem from="1667100977352" duration="3049000" />
      <workItem from="1667145726047" duration="259000" />
      <workItem from="1667148978419" duration="6637000" />
      <workItem from="1669938716353" duration="50000" />
      <workItem from="1670195928026" duration="1417000" />
      <workItem from="1670197783097" duration="1769000" />
      <workItem from="1670199615965" duration="1760000" />
      <workItem from="1670201438230" duration="1730000" />
      <workItem from="1670203394544" duration="876000" />
      <workItem from="1670677002186" duration="1617000" />
      <workItem from="1670684831990" duration="6509000" />
      <workItem from="1670710764439" duration="4103000" />
      <workItem from="1670766931809" duration="14009000" />
      <workItem from="1670800072874" duration="782000" />
      <workItem from="1672316279787" duration="4753000" />
      <workItem from="1672344550032" duration="134000" />
      <workItem from="1672344701852" duration="638000" />
      <workItem from="1672414520242" duration="4677000" />
      <workItem from="1672530008203" duration="91000" />
      <workItem from="1672530174975" duration="209000" />
    </task>
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="3" />
  </component>
  <component name="VcsManagerConfiguration">
    <option name="ADD_EXTERNAL_FILES_SILENTLY" value="true" />
  </component>
</project>

images (folder)

img (folder)

tgbot (folder):
tgbot >__pycache__ (filder)
tgbot >data:
tgbot >data>__pycache__(folder)
tgbot >data>__init__.py:
empty

tgbot >data>config_adv.py:
# - *- coding: utf- 8 - *-
import sqlite3
import configparser
import json


read_config = configparser.ConfigParser()
read_config.read('settings.ini')

BOT_TOKEN = read_config['settings']['token'].strip()  # Токен бота
PATH_DATABASE = 'tgbot/data/database_adv.db'  # Путь к БД
PATH_LOGS = 'tgbot/data/logs_adv.log'  # Путь к Логам
BOT_VERSION = '1.0'

# Преобразование полученного списка в словарь
def dict_factory(cursor, row):
    return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}

# Форматирование запроса без аргументов
def update_format(sql, parameters: dict):
    if "XXX" not in sql: sql += " XXX "

    values = ", ".join([
        f"{item} = ?" for item in parameters
    ])
    sql = sql.replace("XXX", values)

    return sql, list(parameters.values())

def get_type_trade():
    return get_settingsx()['type_trade']

# Получение администраторов бота
def get_admins():
    read_admins = configparser.ConfigParser()
    read_admins.read('settings.ini')

    admins = read_admins['settings']['admin_id'].strip()
    admins = admins.replace(' ', '')

    if ',' in admins:
        admins = admins.split(',')
    else:
        admins = [admins] if len(admins) >= 1 else []
    while '' in admins: admins.remove('')
    while ' ' in admins: admins.remove(' ')
    while '\r' in admins: admins.remove('\r')

    admins = list(map(int, admins))
    #print(admins)
    return admins


    # Получение админов магазинов
def get_shopadmins():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT user_id FROM storage_users WHERE user_role='ShopAdmin'"
        allshopadmins = con.execute(sql).fetchall()
        shopadmins = [admin['user_id'] for admin in allshopadmins]
    return shopadmins


def get_shopadmins2():
    read_shopadmins = configparser.ConfigParser()
    read_shopadmins.read('settings.ini')

    shopadmins = read_shopadmins['settings']['shopadmin_id'].strip()
    shopadmins = shopadmins.replace(' ', '')

    if ',' in shopadmins:
        shopadmins = shopadmins.split(',')
    else:
        shopadmins = [shopadmins] if len(shopadmins) >= 1 else []
    while '' in shopadmins: shopadmins.remove('')
    while ' ' in shopadmins: shopadmins.remove(' ')
    while '\r' in shopadmins: shopadmins.remove('\r')

    shopadmins = list(map(int, shopadmins))

    return shopadmins

    # Получение админов магазинов
def is_shopadmin(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT user_id FROM storage_users "
        #sql, parameters = update_format(sql, kwargs)
        #parameters.append(user_id)
        shopadmin = con.execute(f"{sql}WHERE user_id = ?", [user_id]).fetchone()

    return shopadmin['user_id']


def check_adminproducts():
    #get_position = get_positionsx(position_user_id=message.from_user.id)

    return 1


BOT_DESCRIPTION = f'<b>⚜ Bot Version: <code>{BOT_VERSION}</code>\n' \
                  f'🔗 Topic Link: <a href="https://github.com/rashidovich2/TGGoodsinbot">Click me</a>\n' \
                  f'♻ Bot created by @raclear\n' \
                  f'🍩 Donate to the author: <a href="https://qiwi.com/n/raclear">Click me</a>\n' \
                  f'🤖 Bot channel [NEWS | UPDATES]: <a href="https://t.me/raclear">Click me</a></b>'

tgbot >data>config.py:
# - *- coding: utf- 8 - *-
import os
import sqlite3
import configparser
import json
#from pathlib import Path
from babel import Locale
from pathlib import Path

read_config = configparser.ConfigParser()
read_config.read('settings.ini')

BOT_TOKEN = read_config['settings']['token'].strip()  # Токен бота
PATH_DATABASE = 'tgbot/data/database.db'  # Путь к БД
PATH_LOGS = 'tgbot/data/logs.log'  # Путь к Логам
BOT_VERSION = '1.0'
I18N_DOMAIN = 'mybot'
DEFAULT_LANGUAGE = read_config['settings']['default_language'].strip()
rd = Path(__file__).parents
BASE_DIR = rd[1]
LOCALES_DIR = str(f"{BASE_DIR}{os.sep}locales")
print(LOCALES_DIR)
locale = Locale('ru', 'RU')

#_ = i18n.gettext

# Преобразование полученного списка в словарь
def dict_factory(cursor, row):
    return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}

# Форматирование запроса без аргументов
def update_format(sql, parameters: dict):
    if "XXX" not in sql: sql += " XXX "

    values = ", ".join([
        f"{item} = ?" for item in parameters
    ])
    sql = sql.replace("XXX", values)

    return sql, list(parameters.values())

def get_type_trade():
    return get_settingsx()['type_trade']

# Получение администраторов бота
def get_admins():
    read_admins = configparser.ConfigParser()
    read_admins.read('settings.ini')

    admins = read_admins['settings']['admin_id'].strip()
    admins = admins.replace(' ', '')

    if ',' in admins:
        admins = admins.split(',')
    else:
        admins = [admins] if len(admins) >= 1 else []
    while '' in admins: admins.remove('')
    while ' ' in admins: admins.remove(' ')
    while '\r' in admins: admins.remove('\r')

    admins = list(map(int, admins))
    #print(admins)
    return admins


    # Получение админов магазинов
def get_shopadmins():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT user_id FROM storage_users WHERE user_role='ShopAdmin'"
        allshopadmins = con.execute(sql).fetchall()
        shopadmins = [admin['user_id'] for admin in allshopadmins]
    return shopadmins


def get_shopadmins2():
    read_shopadmins = configparser.ConfigParser()
    read_shopadmins.read('settings.ini')

    shopadmins = read_shopadmins['settings']['shopadmin_id'].strip()
    shopadmins = shopadmins.replace(' ', '')

    if ',' in shopadmins:
        shopadmins = shopadmins.split(',')
    else:
        shopadmins = [shopadmins] if len(shopadmins) >= 1 else []
    while '' in shopadmins: shopadmins.remove('')
    while ' ' in shopadmins: shopadmins.remove(' ')
    while '\r' in shopadmins: shopadmins.remove('\r')

    shopadmins = list(map(int, shopadmins))

    return shopadmins

    # Получение админов магазинов
def is_shopadmin(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT user_id FROM storage_users "
        #sql, parameters = update_format(sql, kwargs)
        #parameters.append(user_id)
        shopadmin = con.execute(f"{sql}WHERE user_id = ?", [user_id]).fetchone()

    return shopadmin['user_id']


def check_adminproducts():
    #get_position = get_positionsx(position_user_id=message.from_user.id)

    return 1


BOT_DESCRIPTION = f'<b>⚜ Bot Version: <code>{BOT_VERSION}</code>\n' \
                  f'🔗 Topic Link: <a href="https://github.com/rashidovich2/TGGoodsinbot">Click me</a>\n' \
                  f'♻ Bot created by @raclear\n' \
                  f'🍩 Donate to the author: <a href="https://qiwi.com/n/raclear">Click me</a>\n' \
                  f'🤖 Bot channel [NEWS | UPDATES]: <a href="https://t.me/raclear">Click me</a></b>'

tgbot >data>database_adv.db
tgbot >data>database.db:
tgbot >data>logs.log:

tgbot >handlers:
tgbot >handlers>__pycache__
tgbot >handlers>__init__.py:
# - *- coding: utf- 8 - *-

from .z_all_errors import dp
from .main_start import dp
from .admin_menu import dp
from .user_menu import dp
from .admin_functions import dp
from .admin_payment import dp
from .admin_products import dp
from .admin_settings import dp
from .user_transactions import dp
from .user_location import dp
from .admin_products_shop import dp
from .z_all_missed_ import dp

__all__ = ['dp']


tgbot >handlers>admin_functions.py:
# - *- coding: utf- 8 - *-
import asyncio
import gettext
from pathlib import Path
from contextvars import ContextVar

from aiogram import types
from aiogram.dispatcher import FSMContext
from aiogram.types import CallbackQuery, Message
from aiogram.utils.exceptions import CantParseEntities

from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR
#from tgbot.middlewares.i18n import I18nMiddleware
#from aiogram.contrib.middlewares.i18n import I18nMiddleware
from tgbot.middlewares.i18n import I18nMiddleware

from tgbot.keyboards.inline_admin import profile_search_finl, profile_search_reqs_finl
from tgbot.keyboards.inline_z_all import ad_confirm_inl, ad_add_to_plan_inl
from tgbot.loader import dp, bot
from tgbot.services.api_sqlite import *
from tgbot.utils.misc.bot_filters import IsAdmin
from tgbot.utils.misc_functions import open_profile_search, open_profile_search_req, upload_text, generate_sales_report, open_profile_search_seller
#from munch import Munch

i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
print(i18n)
_ = i18n.gettext


# Рассылка
@dp.message_handler(IsAdmin(), text="📢 Рассылка_lite", state="*")
async def functions_mail(message: Message, state: FSMContext):
    await state.finish()

    await state.set_state("here_mail_text")
    await message.answer("<b>📢 Введите текст для рассылки пользователям</b>\n"
                         "❕ Вы можете использовать HTML разметку")

@dp.message_handler(IsAdmin(), state="here_mail_text")
async def functions_mail_get(message: Message, state: FSMContext):
    await state.update_data(here_mail_text="📢 Рассылка.\n" + str(message.text))
    get_users = get_all_usersx()

    try:
        cache_msg = await message.answer(message.text)
        await cache_msg.delete()

        await state.set_state("here_mail_confirm")
        await message.answer(
            f"<b>📢 Отправить <code>{len(get_users)}</code> юзерам сообщение?</b>\n"
            f"{message.text}",
            reply_markup=mail_confirm_inl,
            disable_web_page_preview=True
        )
    except CantParseEntities:
        await message.answer("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📢 Введите текст для рассылки пользователям.\n"
                             "❕ Вы можете использовать HTML разметку.")

# Подтверждение отправки рассылки
@dp.callback_query_handler(IsAdmin(), text_startswith="confirm_mail", state="here_mail_confirm")
async def functions_mail_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]

    send_message = (await state.get_data())['here_mail_text']
    get_users = get_all_usersx()
    await state.finish()

    if get_action == "yes":
        await call.message.edit_text(f"<b>📢 Рассылка началась... (0/{len(get_users)})</b>")
        asyncio.create_task(functions_mail_make(send_message, call))
    else:
        await call.message.edit_text("<b>📢 Вы отменили отправку рассылки ✅</b>")


# Сама отправка рассылки
async def functions_mail_make(message, call: CallbackQuery):
    receive_users, block_users, how_users = 0, 0, 0
    get_users = get_all_usersx()
    get_time = get_unix()

    for user in get_users:
        try:
            await bot.send_message(user['user_id'], message, disable_web_page_preview=True)
            receive_users += 1
        except:
            block_users += 1

        how_users += 1

        if how_users % 10 == 0:
            await call.message.edit_text(f"<b>📢 Рассылка началась... ({how_users}/{len(get_users)})</b>")

        await asyncio.sleep(0.08)

    await call.message.edit_text(
        f"<b>📢 Рассылка была завершена за <code>{get_unix() - get_time}сек</code></b>\n"
        f"👤 Всего пользователей: <code>{len(get_users)}</code>\n"
        f"✅ Пользователей получило сообщение: <code>{receive_users}</code>\n"
        f"❌ Пользователей не получило сообщение: <code>{block_users}</code>"
    )

# Рассылка PRO
@dp.message_handler(text=["📢 Рассылка", "📢 Mass Send"], state="*")
async def functions_ad(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang)
    if user_role in ['Admin', 'ShopAdmin']:
        await state.set_state("here_ad_post")
        await message.answer(_("<b>📢 Введите текст для рассылки пользователям</b>", locale=lang))

######################################## ПРИНЯТИЕ ДАННЫХ ########################################
# Принятие текста для рассылки
@dp.message_handler(state="here_ad_post", content_types=types.ContentType.ANY)
async def functions_ad_get(message: Message, state: FSMContext):
    await state.reset_state(with_data=False)
    get_users = get_all_usersx()
    user_id = message.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang, user_role)
    mode = "tohour"
    ct = 0
    if user_role in ["Admin", "ShopAdmin"]:
        print("P10P20R")
        if types.ContentType.TEXT == message.content_type:
            ct = 'text'
            print("!text message entered")
            await state.update_data(ct='text', here_ad_post=str(message.html_text))
            add_post_to_plan(ct, user_id, message.html_text, mode, caption='')
        elif types.ContentType.PHOTO == message.content_type:
            ct = 'photo'
            print("!photo message entered")
            caption=message.html_text if message.caption else None
            await state.update_data(ct="photo", here_ad_photo=message.photo[-1].file_id, caption=caption)
            add_post_to_plan(ct, user_id, message.photo[-1].file_id, mode, caption=caption)
        elif types.ContentType.VIDEO == message.content_type:
            ct = 'video'
            caption=message.html_text if message.caption else None
            await state.update_data(ct="video", here_ad_video=message.video.file_id, caption=caption)
            add_post_to_plan(ct, user_id, message.video[-1].file_id, mode, caption=caption)
        elif types.ContentType.ANIMATION == message.content_type:
            ct = 'animation'
            caption=message.html_text if message.caption else None
            await state.update_data(ct="animation", here_ad_animation=message.animation.file_id, caption=caption)
            add_post_to_plan(ct, user_id, message.animation[-1].file_id, mode, caption=caption)
        post_id = get_lastpost()

        print(post_id)

        try:
            cache_msg = await message.answer(f"Тип поста:{ct}")
            await state.update_data(post_id=post_id)
            print(post_id)
            user_id = message.from_user.id
            lang = get_userx(user_id=user_id)['user_lang']
            print(lang)
            await message.answer(_("<b>📢 Включить пост в ротацию бота?</b>", locale=lang),
                reply_markup=ad_add_to_plan_inl,
                disable_web_page_preview=True
            )
        except CantParseEntities:
            await message.answer(_("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                                 "📢 Введите текст для рассылки пользователям.\n"
                                 "❕ Вы можете использовать HTML разметку.", locale=lang))


# Подтверждение отправки рассылки
@dp.callback_query_handler(IsAdmin(), text_startswith="plan_once_ad", state="*")
async def functions_ad_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    get_users = get_all_usersx()
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    post_id = (await state.get_data())['post_id']
    ct = (await state.get_data())['ct']

    try:
        if get_action == "yes":
            cache_msg = await call.message.answer(f"Выбрано добавление в план:{ct}")
            await cache_msg.delete()

        await state.set_state("here_ad_post_confirm")
        post = get_postx(post_id)
        print(post)

        await call.message.answer(f"<b>📢 Отправить <code>{len(get_users)}</code> юзерам сообщение?</b>\n",
            reply_markup=ad_confirm_inl,
            disable_web_page_preview=True
        )
    except CantParseEntities:
        await message.answer(_("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📢 Введите текст для рассылки пользователям.\n"
                             "❕ Вы можете использовать HTML разметку.", locale=lang))

# Подтверждение отправки рассылки
@dp.callback_query_handler(IsAdmin(), text_startswith="confirm_ad", state="here_ad_post_confirm")
async def functions_ad_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    ct = (await state.get_data())['ct']
    mode = "evening"
    if ct == "text":
        #print("|")
        send_message = (await state.get_data())['here_ad_post']
    elif ct == "photo":
        #print("||")
        send_photo = (await state.get_data())['here_ad_photo']
        caption = (await state.get_data())['caption']
    elif ct == "video":
        #print("|||")
        send_video = (await state.get_data())['here_ad_video']
        caption = (await state.get_data())['caption']
    elif ct == "animation":
        #print("||||")
        send_animation = (await state.get_data())['here_ad_animation']
        caption = (await state.get_data())['caption']

    get_users = get_all_usersx()
    await state.finish()

    if get_action == "yes":
        await call.message.edit_text(f"<b>📢 Рассылка началась... (0/{len(get_users)})</b>")
        if ct == "text":
            asyncio.create_task(functions_adext_make(ct, send_message, 0, call))
        if ct == "photo":
            asyncio.create_task(functions_adext_make(ct, send_photo, caption, call))
        if ct == "video":
            asyncio.create_task(functions_adext_make(ct, send_video, caption, call))
        if ct == "animation":
            asyncio.create_task(functions_adext_make(ct, send_animation, caption, call))
    else:
        await call.message.edit_text(_("<b>📢 Вы отменили отправку рассылки ✅</b>", locale=lang))


# Поиск профиля
@dp.message_handler(IsAdmin(), text=["👤 Поиск профиля 🔍", "👤 Find Profile 🔍"], state="*")
async def functions_profile(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    await state.finish()

    await state.set_state("here_profile")
    await message.answer(_("<b>👤 Введите логин или айди пользователя</b>", locale=lang))

# Поиск чеков
@dp.message_handler(IsAdmin(), text=["🧾 Поиск чеков 🔍", "🧾 Find Receipts 🔍"], state="*")
async def functions_receipt(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    await state.finish()

    await state.set_state("here_receipt")
    await message.answer(_("<b>🧾 Отправьте номер чека</b>", locale=lang))

# Просмотр запросов продавцов
@dp.message_handler(text=["🖍 Посмотреть запросы", "🖍 Show list requests"], state="*")
async def functions_seller_requests(message: Message, state: FSMContext):

    user_id = message.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang)
    if user_role in ['Admin', 'ShopAdmin']:
        await message.answer(_("<b>🧾 Посмотрим запросы продавцов:</b>", locale=lang))

    all_requests = get_all_requestx()
    if len(all_requests) >= 1:
        await message.answer(_("Запросы на роль продавца:", locale=lang) + str(len(all_requests)) + "шт.")

        for request in all_requests:
            print(request)
            await state.finish()
            await message.answer(open_profile_search_req(request['user_id'], lang), reply_markup=profile_search_reqs_finl(request['user_id'], lang))


# Просмотр запросов продавцов
@dp.message_handler(IsAdmin(), text=["📊 Отчет о продажах", "📊 Sales Report"], state="*")
async def functions_seller_requests(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    lang = get_userx(user_id=user_id)['user_lang']

    await message.answer(generate_sales_report())

    get_users = get_purchasesbysellers()

    if len(get_users)>= 1:
        await message.answer(_("Топ - продавцов", locale=lang) + str(get_users) + _("шт.", locale=lang))

        for user in get_users:

            await message.answer(open_profile_search_seller(user_id=user['user_id']), reply_markup=profile_search_finl(user['user_id']))

########################################### CALLBACKS ###########################################
# Подтверждение отправки рассылки
@dp.callback_query_handler(IsAdmin(), text_startswith="confirm_ad2", state="here_ad_confirm")
async def functions_ad_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    send_message = (await state.get_data())['here_ad_text']
    get_users = get_all_usersx()
    await state.finish()

    if get_action == "yes":
        await call.message.edit_text(_("<b>📢 Рассылка началась... (0/", locale=lang) + len(get_users) + _(")</b>", locale=lang))
        asyncio.create_task(functions_ad_make(send_message, call))
    else:
        await call.message.edit_text(_("<b>📢 Вы отменили отправку рассылки ✅</b>", locale=lang))


# Покупки пользователя
@dp.callback_query_handler(IsAdmin(), text_startswith="admin_user_purchases", state="*")
async def functions_profile_purchases(call: CallbackQuery, state: FSMContext):
    user_id = call.data.split(":")[1]
    lang = get_userx(user_id=user_id)['user_lang']
    last_purchases = last_purchasesx(user_id, 10)

    if len(last_purchases) >= 1:
        await call.answer(_("🎁 Последние 10 покупок", locale=lang))
        await call.message.delete()

        for purchases in last_purchases:
            link_items = await upload_text(call, purchases['purchase_item'])
            if lang == "ru":
                await call.message.answer(f"<b>🧾 Чек: <code>#{purchases['purchase_receipt']}</code></b>\n"
                                          f"🎁 Товар: <code>{purchases['purchase_position_name']} | {purchases['purchase_count']}шт | {purchases['purchase_price']}₽</code>\n"
                                          f"🕰 Дата покупки: <code>{purchases['purchase_date']}</code>\n"
                                          f"🔗 Товары: <a href='{link_items}'>кликабельно</a>")
            if lang == "en":
                await call.message.answer(f"<b>🧾 Receipt: <code>#{purchases['purchase_receipt']}</code></b>\n"
                                          f"🎁 Product: <code>{purchases['purchase_position_name']} | {purchases['purchase_count']}pcs | {purchases['purchase_price']}₽</code>\n"
                                          f"🕰 Purchase Date: <code>{purchases['purchase_date']}</code>\n"
                                          f"🔗 Products: <a href='{link_items}'>clickable</a>")

        await call.message.answer(open_profile_search(user_id), reply_markup=profile_search_finl(user_id))
    else:
        if lang == "ru":
            await call.answer("❗ У пользователя отсутствуют покупки", True)
        if lang == "en":
            await call.answer("❗ User don't have purchases", True)


# Отправка рассылки
async def functions_adext_make(ct, message, caption, call: CallbackQuery):
    receive_users, block_users, how_users = 0, 0, 0
    get_users = get_all_usersx()
    #user_id = call.data.split(":")[1]
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    ANNOUNCE_ID = 1925944285

    for user in get_users:
        try:
            if ct == "text":
                await dp.bot.send_message(user['user_id'], message, disable_web_page_preview=True)
            elif ct == "photo":
                await dp.bot.send_photo(
                    chat_id=user['user_id'],
                    photo=message,
                    caption=caption or None,
                )
                '''await dp.bot.forward_message(
                    chat_id=ANNOUNCE_ID,
                    from_chat_id=message.chat.id,
                    message_id=message.reply_to_message.message_id
                )'''
            elif ct == "video":
                await dp.bot.send_video(
                    chat_id=user['user_id'],
                    video=message,
                    caption=caption or None,
                )
            elif ct == "animation":
                await dp.bot.send_animation(
                    chat_id=user['user_id'],
                    animation=message,
                    caption=caption or None,
                )

            receive_users += 1
        except Exception:
            block_users += 1

        how_users += 1

        if how_users % 10 == 0:
            await call.message.edit_text("<b>📢 Рассылка началась... (" + str(how_users) + "/" + str(len(get_users)) + ")</b>")
        #_("<b>📢 Рассылка началась... (", locale=lang)
        await asyncio.sleep(0.05)

    if lang == "ru":
        await call.message.edit_text(
            f"<b>📢 Рассылка была завершена ✅</b>\n"
            f"👤 Пользователей получило сообщение: <code>{receive_users} ✅</code>\n"
            f"👤 Пользователей не получило сообщение: <code>{block_users} ❌</code>"
        )
    if lang == "en":
        await call.message.edit_text(
            f"<b>📢 Mass Sending has been finished ✅</b>\n"
            f"👤 Users Received Messages: <code>{receive_users} ✅</code>\n"
            f"👤 Users not Received Messages: <code>{block_users} ❌</code>"
        )

# Отправка рассылки
async def functions_ad_make(message, call: CallbackQuery):
    receive_users, block_users, how_users = 0, 0, 0
    get_users = get_all_usersx()

    for user in get_users:
        try:
            await bot.send_message(user['user_id'], message, disable_web_page_preview=True)
            receive_users += 1
        except Exception:
            block_users += 1

        how_users += 1

        if how_users % 10 == 0:
            await call.message.edit_text(_("<b>📢 Рассылка началась... (", locale=lang) + str(how_users) + "/" + str(len(get_users)) + "</b>")
        #_("<b>📢 Рассылка началась... (", locale=lang)
        await asyncio.sleep(0.05)

    await call.message.edit_text(
        f"<b>📢 Рассылка была завершена ✅</b>\n"
        f"👤 Пользователей получило сообщение: <code>{receive_users} ✅</code>\n"
        f"👤 Пользователей не получило сообщение: <code>{block_users} ❌</code>"
    )

# Подтверждение запроса продавца
@dp.callback_query_handler(IsAdmin(), text_startswith="admin_user_request_approve", state="*")
async def functions_shopadmin_request_approve(call: CallbackQuery, state: FSMContext):
    user_id = call.data.split(":")[1]

    get_user = get_userx(user_id=user_id)
    update_userx(user_id, user_role="ShopAdmin")
    update_requestx(user_id, state="Approved")

    await state.finish()
    await call.message.answer(
        f"<b>✅ Пользователю <a href='tg://user?id={user_id}'>{get_user['user_name']}</a> "
        f"изменена роль на: <code>{get_user['user_role']}</code></b>")

    await bot.send_message(user_id, "<b> Вам была выдана роль Продавца магазина. </b>")


# Отклонение запроса продавца
@dp.callback_query_handler(IsAdmin(), text_startswith="admin_user_request_decline", state="*")
async def functions_shopadmin_request_decline(call: CallbackQuery, state: FSMContext):
    await state.finish()
    user_id = call.data.split(":")[1]
    print(user_id)
    delete_requests_userx(user_id)

    await call.answer(_(" Запрос был успешно удален.", locale=lang))

    await bot.send_message(
        user_id,
        _("<b>Ваш запрос был отклонен. Вы можете попробовать подать следующий запрос через 14 дней.</b>",
            locale=lang,
        ),
    )


# Выдача баланса пользователю
@dp.callback_query_handler(IsAdmin(), text_startswith="admin_user_balance_add", state="*")
async def functions_profile_balance_add(call: CallbackQuery, state: FSMContext):
    await state.update_data(here_profile=call.data.split(":")[1])
    auser_id = call.from_user.id
    lang, user_role = get_userx(user_id=auser_id)['user_lang'], get_userx(user_id=auser_id)['user_role']

    await state.set_state("here_profile_add")
    await call.message.edit_text(_("<b>💰 Введите сумму для выдачи баланса</b>", locale=lang))


# Изменение баланса пользователю
@dp.callback_query_handler(IsAdmin(), text_startswith="admin_user_balance_set", state="*")
async def functions_profile_balance_set(call: CallbackQuery, state: FSMContext):
    await state.update_data(here_profile=call.data.split(":")[1])
    auser_id = call.from_user.id
    lang, user_role = get_userx(user_id=auser_id)['user_lang'], get_userx(user_id=auser_id)['user_role']

    await state.set_state("here_profile_set")
    await call.message.edit_text(_("<b>💰 Введите сумму для изменения баланса</b>", locale=lang))


# Обновление профиля пользователя
@dp.callback_query_handler(IsAdmin(), text_startswith="admin_user_refresh", state="*")
async def functions_profile_refresh(call: CallbackQuery, state: FSMContext):
    user_id = call.data.split(":")[1]
    auser_id = call.from_user.id
    lang, user_role = get_userx(user_id=auser_id)['user_lang'], get_userx(user_id=auser_id)['user_role']

    await call.message.delete()
    await call.message.answer(open_profile_search(user_id, lang), reply_markup=profile_search_finl(user_id))


######################################## СМЕНА СТАТУСОВ ПОЛЬЗОВАТЕЛЯ ############################

# Принятие суммы для выдачи баланса пользователю
@dp.callback_query_handler(IsAdmin(), state="here_user_request_approve")
async def functions_shopadmin_request_approvep(message: Message, state: FSMContext):
    user_id = (await state.get_data())['here_profile']
    await state.finish()

    get_user = get_userx(user_id=user_id)
    update_userx(user_id, user_role="ShopAdmin")
    lang = get_user(user_id=user_id)['user_lang']

    await message.answer(
        f"<b>✅ Пользователю <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a> "
        f"изменена роль на: <code>{get_user['user_role']}</code></b>")

    await message.bot.send_message(
        user_id,
        _("<b> Вам была выдана роль Продавца магазина </b>", locale=lang),
    )
    await message.answer(open_profile_search(user_id), reply_markup=profile_search_finl(user_id))


######################################## ПРИНЯТИЕ ДАННЫХ ########################################
# Принятие текста для рассылки
@dp.message_handler(IsAdmin(), state="here_ad_text")
async def functions_ad_get(message: Message, state: FSMContext):
    await state.update_data(here_ad_text="📢 Рассылка.\n" + str(message.text))
    get_users = get_all_usersx()

    try:
        cache_msg = await message.answer(message.text)
        await cache_msg.delete()

        await state.set_state("here_ad_confirm")
        await message.answer(
            f"<b>📢 Отправить <code>{len(get_users)}</code> юзерам сообщение?</b>\n"
            f"{message.text}",
            reply_markup=ad_confirm_inl,
            disable_web_page_preview=True
        )
    except CantParseEntities:
        await message.answer(_("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📢 Введите текст для рассылки пользователям.\n"
                             "❕ Вы можете использовать HTML разметку.", locale=lang))

# Принятие айди или логина для поиска профиля
@dp.message_handler(IsAdmin(), state="here_profile")
async def functions_profile_get(message: Message, state: FSMContext):
    find_user = message.text
    auser_id = message.from_user.id
    lang, user_role = get_user(user_id=auser_id)['user_lang'], get_user(user_id=auser_id)['user_role']

    if find_user.isdigit():
        get_user = get_userx(user_id=find_user)
    else:
        if find_user.startswith("@"): find_user = find_user[1:]
        print(find_user)
        get_user = get_userx(user_login=find_user.lower())

    if get_user is not None:
        await state.finish()
        await message.answer(open_profile_search(get_user['user_id'], lang),
                             reply_markup=profile_search_finl(get_user['user_id'], lang))
    else:
        await message.answer(_("<b>❌ Профиль не был найден</b>"
                             "👤 Введите логин или айди пользователя.", locale=lang))


# Принятие суммы для выдачи баланса пользователю
@dp.message_handler(IsAdmin(), state="here_profile_add")
async def functions_profile_balance_add_get(message: Message, state: FSMContext):
    if message.text.isdigit():
        if 0 <= int(message.text) <= 1000000000:
            user_id = (await state.get_data())['here_profile']
            await state.finish()

            get_user = get_userx(user_id=user_id)
            update_userx(user_id, user_balance=get_user['user_balance'] + int(message.text))

            await message.answer(
                f"<b>✅ Пользователю <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a> "
                f"выдано <code>{message.text}₽</code></b>")

            await message.bot.send_message(user_id, f"<b>💰 Вам было выдано <code>{message.text}₽</code></b>")
            await message.answer(open_profile_search(user_id), reply_markup=profile_search_finl(user_id))
        else:
            await message.answer(_("<b>❌ Сумма выдачи не может быть меньше 1 и больше 1 000 000 000</b>\n"
                                 "💰 Введите сумму для выдачи баланса", locale=lang))
    else:
        await message.answer(_("<b>❌ Данные были введены неверно.</b>\n"
                             "💰 Введите сумму для выдачи баланса", locale=lang))


# Принятие суммы для изменения баланса пользователя
@dp.message_handler(IsAdmin(), state="here_profile_set")
async def functions_profile_balance_set_get(message: Message, state: FSMContext):
    if message.text.isdigit():
        if 0 <= int(message.text) <= 1000000000:
            user_id = (await state.get_data())['here_profile']
            await state.finish()

            get_user = get_userx(user_id=user_id)
            update_userx(user_id, user_balance=message.text)

            await message.answer(
                f"<b>✅ Пользователю <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a> "
                f"изменён баланс на <code>{message.text}₽</code></b>")

            await message.answer(open_profile_search(user_id), reply_markup=profile_search_finl(user_id))
        else:
            await message.answer(_("<b>❌ Сумма изменения не может быть меньше 0 и больше 1 000 000 000</b>\n"
                                 "💰 Введите сумму для изменения баланса", locale=lang))
    else:
        await message.answer(_("<b>❌ Данные были введены неверно.</b>\n"
                             "💰 Введите сумму для изменения баланса", locale=lang))


# Отправка сообщения пользователю
@dp.callback_query_handler(IsAdmin(), text_startswith="admin_user_message", state="*")
async def functions_profile_user_message(call: CallbackQuery, state: FSMContext):
    await state.update_data(here_profile=call.data.split(":")[1])

    await state.set_state("here_profile_message")
    await call.message.edit_text(_("<b>💌 Введите сообщение для отправки</b>\n"
                                 "⚠ Сообщение будет сразу отправлено пользователю."), locale=lang)

# Принятие сообщения для пользователя
@dp.message_handler(IsAdmin(), state="here_profile_message")
async def functions_profile_user_message_get(message: Message, state: FSMContext):
    user_id = (await state.get_data())['here_profile']
    auser_id = message.from_user.id
    lang = get_userx(user_id=auser_id)['user_lang']
    await state.finish()

    get_message = _("<b>💌 Вам сообщение:</b>", locale=lang) + clear_html(message.text)
    get_user = get_userx(user_id=user_id)

    await message.bot.send_message(user_id, get_message)
    await message.answer(_("<b>✅ Пользователю ", locale=lang) + f"<a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a> "
                         + _("было отправлено сообщение:</b>", locale=lang) +
                         f"{get_message}")

    await message.answer(open_profile_search(user_id), reply_markup=profile_search_finl(user_id))


# Принятие чека для поиска
@dp.message_handler(IsAdmin(), state="here_receipt")
async def functions_receipt_search(message: Message, state: FSMContext):
    receipt = message.text[1:]
    get_refill = ""
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    if message.text.startswith("#"):
        get_refill = get_refillx(refill_receipt=receipt)
        get_purchase = get_purchasex(purchase_receipt=receipt)

        if get_refill is not None:
            await state.finish()

            if get_refill['refill_way'] == "Form":
                way_input = _("🥝 Способ пополнения: <code>По форме</code>", locale=lang)
            elif get_refill['refill_way'] == "Nickname":
                way_input = _("🥝 Способ пополнения: <code>По никнейму</code>", locale=lang)
            elif get_refill['refill_way'] == "Number":
                way_input = _("🥝 Способ пополнения: <code>По номеру</code>", locale=lang)
            else:
                way_input = _(f"🥝 Способ пополнения: <code>{get_refill['refill_way']}</code>", locale=lang)

            if lang == "ru":
                await message.answer(
                    f"<b>🧾 Чек: <code>#{get_refill['refill_receipt']}</code></b>\n"
                    "➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                    f"👤 Пользователь: <a href='tg://user?id={get_refill['user_id']}'>{get_refill['user_name']}</a> <code>({get_refill['user_id']})</code>\n"
                    f"💰 Сумма пополнения: <code>{get_refill['refill_amount']}₽</code>\n"
                    f"{way_input}\n"
                    f"🏷 Комментарий: <code>{get_refill['refill_comment']}</code>\n"
                    f"🕰 Дата пополнения: <code>{get_refill['refill_date']}</code>"
                )
            if lang == "en":
                await message.answer(
                    f"<b>🧾 Receipt: <code>#{get_refill['refill_receipt']}</code></b>\n"
                    "➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                    f"👤 User: <a href='tg://user?id={get_refill['user_id']}'>{get_refill['user_name']}</a> <code>({get_refill['user_id']})</code>\n"
                    f"💰 Charge Amount: <code>{get_refill['refill_amount']}₽</code>\n"
                    f"{way_input}\n"
                    f"🏷 Comment: <code>{get_refill['refill_comment']}</code>\n"
                    f"🕰 Date of charge: <code>{get_refill['refill_date']}</code>"
                )
            return
        elif get_purchase is not None:
            await state.finish()

            link_items = await upload_text(message, get_purchase['purchase_item'])
            if lang == "ru":
                await message.answer(
                    f"<b>🧾 Чек: <code>#{get_purchase['purchase_receipt']}</code></b>\n"
                    f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                    f"👤 Пользователь: <a href='tg://user?id={get_purchase['user_id']}'>{get_purchase['user_name']}</a> <code>({get_purchase['user_id']})</code>\n"
                    f"🏷 Название товара: <code>{get_purchase['purchase_position_name']}</code>\n"
                    f"📦 Куплено товаров: <code>{get_purchase['purchase_count']}шт</code>\n"
                    f"💰 Цена 1-го товара: <code>{get_purchase['purchase_price_one']}₽</code>\n"
                    f"💸 Сумма покупки: <code>{get_purchase['purchase_price']}₽</code>\n"
                    f"🔗 Товары: <a href='{link_items}'>кликабельно</a>\n"
                    f"🔻 Баланс до покупки: <code>{get_purchase['balance_before']}₽</code>\n"
                    f"🔺 Баланс после покупки: <code>{get_purchase['balance_after']}₽</code>\n"
                    f"🕰 Дата покупки: <code>{get_purchase['purchase_date']}</code>"
                )
            if lang == "en":
                await message.answer(
                    f"<b>🧾 Receipt: <code>#{get_purchase['purchase_receipt']}</code></b>\n"
                    f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                    f"👤 User: <a href='tg://user?id={get_purchase['user_id']}'>{get_purchase['user_name']}</a> <code>({get_purchase['user_id']})</code>\n"
                    f"🏷 Name of Product: <code>{get_purchase['purchase_position_name']}</code>\n"
                    f"📦 Products Purchased: <code>{get_purchase['purchase_count']}pcs</code>\n"
                    f"💰 Price for One Pieces: <code>{get_purchase['purchase_price_one']}R</code>\n"
                    f"💸 Summ of Purchaces: <code>{get_purchase['purchase_price']}R</code>\n"
                    f"🔗 Items: <a href='{link_items}'>кликабельно</a>\n"
                    f"🔻 Balance Before Purchase: <code>{get_purchase['balance_before']}R</code>\n"
                    f"🔺 Balance After Purchase: <code>{get_purchase['balance_after']}R</code>\n"
                    f"🕰 Purchase Date: <code>{get_purchase['purchase_date']}</code>"
                )

            return

    await message.answer(_("<b>❌ Чек не был найден.</b>\n"
                         "🧾 Отправьте номер чека", locale=lang))


tgbot >handlers>admin_menu.py:
# - *- coding: utf- 8 - *-
from aiogram.dispatcher import FSMContext
from aiogram.types import Message
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton as ikb

from tgbot.data.config import BOT_VERSION, PATH_LOGS, PATH_DATABASE
from tgbot.keyboards.reply_z_all import payments_frep, settings_frep, functions_frep, items_frep, seller_requests_frep
from tgbot.loader import dp
from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR
from tgbot.middlewares.i18n import I18nMiddleware
from tgbot.services.api_sqlite import get_all_usersx, get_top_sellersx, get_userx
from tgbot.utils.const_functions import get_date
from tgbot.utils.misc.bot_filters import IsAdmin, IsAdminorShopAdmin
from tgbot.utils.misc_functions import get_statisctics

i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)

print(i18n)
_ = i18n.gettext

# Платежные системы
@dp.message_handler(text=["🔑 Платежные системы", "🔑 Payment Systems"], state="*")
async def admin_payment(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang)
    if user_role in ['Admin', 'ShopAdmin']:
        await message.answer(_("<b>🔑 Настройка платежных систем.</b>", locale=lang), reply_markup=payments_frep(lang))


# Настройки бота
@dp.message_handler(IsAdmin(), text=["⚙ Настройки", "⚙ Settings"], state="*")
async def admin_settings(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang)
    if user_role in ['Admin', 'ShopAdmin']:
        await message.answer(_("<b>⚙ Основные настройки бота.</b>", locale=lang), reply_markup=settings_frep(lang))


# Запросы продавцов
@dp.message_handler(text=["Запросы продавцов", "Sellers Request"],state="*")
async def admin_requests(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang)
    if user_role in ['Admin']:
        await message.answer(_("<b>⚙ Запросы продавцов.</b>", locale=lang), reply_markup=seller_requests_frep(lang))


# Общие функции
@dp.message_handler(text=["🔆 Общие функции", "🔆 General Functions"], state="*") #, "🔆 General Functions"
async def admin_functions(message: Message, state: FSMContext):
    user_id = message.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang)
    if user_role in ['Admin', 'ShopAdmin']:
        print(lang)
        await state.finish()
        await message.answer(_("<b>🔆 Выберите нужную функцию.</b>", locale=lang), reply_markup=functions_frep(lang))


# Управление товарами
@dp.message_handler(text=["🎁 Управление товарами 🖍", "🎁 Products Management 🖍"], state="*")
async def admin_products(message: Message, state: FSMContext):
    user_id = message.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    lang = get_userx(user_id=user_id)['user_lang']
    print(user_role)
    if user_role in ['Admin', 'ShopAdmin']:
        print(lang)
        await state.finish()
        await message.answer("<b>🎁 Редактирование товаров.</b>", reply_markup=items_frep(lang))


# Cтатистики бота
@dp.message_handler(text=["📊 Статистика", "📊 Statistic"], state="*")
async def admin_statistics(message: Message, state: FSMContext):
    user_id = message.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    if user_role == "Admin":
        lang = get_userx(user_id=user_id)['user_lang']
        print(lang)
        await state.finish()
        await message.answer(get_statisctics(lang))


# Получение БД
@dp.message_handler(IsAdmin(), commands=['db', 'database'], state="*")
async def admin_database(message: Message, state: FSMContext):
    await state.finish()

    with open(PATH_DATABASE, "rb") as document:
        await message.answer_document(document,
                                      caption=f"<b>📦 BACKUP\n"
                                              f"🕰 <code>{get_date()}</code></b>")


# Получение Логов
@dp.message_handler(IsAdmin(), commands=['log', 'logs'], state="*")
async def admin_log(message: Message, state: FSMContext):
    await state.finish()

    with open(PATH_LOGS, "rb") as document:
        await message.answer_document(document,
                                      caption=f"<b>🖨 LOGS\n"
                                              f"🕰 <code>{get_date()}</code></b>")


# Получение версии бота
@dp.message_handler(commands=['version', 'log'], state="*")
async def admin_version(message: Message, state: FSMContext):
    await state.finish()

    await message.answer(f"<b>❇ Текущая версия бота: <code>{BOT_VERSION}</code></b>")


tgbot >handlers>admin_payment.py:
# - *- coding: utf- 8 - *-
import asyncio

from aiogram.dispatcher import FSMContext
from aiogram.types import CallbackQuery, Message

import json
from tgbot.keyboards.inline_admin import payment_choice_finl
from tgbot.loader import dp
from tgbot.services.api_qiwi import QiwiAPI
from tgbot.services.api_yoo import YooAPI
from tgbot.services.api_cb import CoinbaseAPI
from tgbot.services.api_sqlite import update_paymentx, get_paymentx, get_upaycount, get_upaymentx, update_upaymentx, get_userx
from tgbot.utils.misc.bot_filters import IsAdmin, IsAdminorShopAdmin


###################################################################################
############################# ВЫБОР СПОСОБА ПОПОЛНЕНИЯ ############################
# Открытие способов пополнения
@dp.message_handler(text=["🖲 Способы пополнения", "🖲 Payment methods"], state="*")
async def payment_systems(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    print(user_role)
    if user_role == "Admin" or user_role == "ShopAdmin":
        await message.answer(_("<b>🖲 Выберите способ пополнения</b>", locale=lang), reply_markup=payment_choice_finl(user_id, lang))

# Включение/выключение самих способов пополнения
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="change_payment:")
async def payment_systems_edit(call: CallbackQuery):
    way_pay = call.data.split(":")[1]
    way_status = call.data.split(":")[2]
    user_id = str(json.dumps(call.data.split(":")[3]))
    user_id = user_id.strip("\"")
    print(user_id)
    print(call.from_user.id)

    count = get_upaycount(user_id)
    if count == 0:
        cur = create_upayments_row(user_id)
    else:
        #get_payment = get_paymentx
        get_payment = get_upaymentx(user_id)
        print(get_payment)

    if get_payment['qiwi_login'] != "None" and get_payment['qiwi_token'] != "None" or way_status == "False":
        if way_pay == "Form":
            if get_payment['qiwi_secret'] != "None" or way_status == "False":
                update_upaymentx(user_id, way_form=way_status)
            else:
                await call.answer(
                    "❗ Приватный ключ отсутствует. Измените киви и добавьте приватный ключ для включения оплаты по Форме",
                    True)
        elif way_pay == "ForYm":
            if get_payment['yoo_client_id'] != "None" or way_status == "False":
                update_upaymentx(user_id, way_formy=way_status)
            else:
                await call.answer(
                    "❗ Приватный ключ отсутствует. Измените киви и добавьте приватный ключ для включения оплаты по Форме",
                    True)
        elif way_pay == "Number":
            update_upaymentx(user_id, way_number=way_status)
        elif way_pay == "Nickname":
            status, response = await (await QiwiAPI(call)).get_nickname()
            if status:
                update_upaymentx(user_id, way_nickname=way_status, qiwi_nickname=response)
            else:
                await call.answer(response, True)
        elif way_pay == "FreeCredi":
            update_upaymentx(user_id, way_freecredi=way_status)
        elif way_pay == "CoinBase":
            update_upaymentx(user_id, way_coinbase=way_status)
    else:
        await call.answer("❗ Добавьте киви кошелёк перед включением Способов пополнений.", True)

    try:
        await call.message.edit_text(_("<b>🖲 Выберите способ пополнения</b>", locale=lang), reply_markup=payment_choice_finl(user_id, lang))
    except Exception:
        pass


###################################################################################
####################################### QIWI ######################################
# Изменение QIWI кошелька
@dp.message_handler(IsAdminorShopAdmin(), text="🥝 Изменить QIWI 🖍", state="*")
async def payment_qiwi_edit(message: Message, state: FSMContext):
    await state.finish()

    await state.set_state("here_qiwi_login")
    await message.answer("<b>🥝 Введите <code>номер (через +7, +380)</code> QIWI кошелька 🖍</b>")


# Проверка работоспособности QIWI
@dp.message_handler(IsAdminorShopAdmin(), text="🥝 Проверить QIWI ♻", state="*")
async def payment_qiwi_check(message: Message, state: FSMContext):
    print("||| Проверка КИВИ админом площадки. |||")
    await state.finish()
    user_id = message.from_user.id
    print(user_id)

    await (await QiwiAPI(message, check_pass=True)).pre_checker()


# Баланс QIWI
@dp.message_handler(IsAdminorShopAdmin(), text="🥝 Баланс QIWI 👁", state="*")
async def payment_qiwi_balance(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id

    await (await QiwiAPI(message)).get_balance()

######################################## YooMoney ################################
# Изменение реквизитов Yoo
@dp.message_handler(IsAdminorShopAdmin(), text="💳 Изменить Yoo 🖍", state="*")
async def payment_qiwi_edit(message: Message, state: FSMContext):
    await state.finish()

    await state.set_state("here_yoo_acc_number")
    await message.answer("<b>💳 Введите <code>номер счета </code> Yoo аккаунта 🖍</b>")


######################################## ПРИНЯТИЕ QIWI ########################################
# Принятие логина для QIWI
@dp.message_handler(IsAdminorShopAdmin(), state="here_qiwi_login")
async def payment_qiwi_edit_login(message: Message, state: FSMContext):
    if message.text.startswith("+"):
        await state.update_data(here_qiwi_login=message.text)

        await state.set_state("here_qiwi_token")
        await message.answer(
            "<b>🥝 Введите <code>токен API</code> QIWI кошелька 🖍</b>\n"
            "❕ Получить можно тут 👉 <a href='https://qiwi.com/api'><b>Нажми на меня</b></a>\n"
            "❕ При получении токена, ставьте только первые 3 галочки.",
            disable_web_page_preview=True
        )
    else:
        await message.answer("<b>❌ Номер должен начинаться с + <code>(+7..., +380...)</code></b>\n"
                             "🥝 Введите <code>номер (через +7, +380)</code> QIWI кошелька 🖍")


# Принятие acc_number для Yoo
@dp.message_handler(IsAdminorShopAdmin(), state="here_yoo_acc_number")
async def payment_qiwi_edit_login(message: Message, state: FSMContext):
    #if message.text.startswith("+"):
    await state.update_data(here_yoo_acc_number=message.text)
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await state.set_state("here_yoo_token")
    if lang == "ru":
        await message.answer(
            "<b>🥝 Введите <code>токен API</code> Yoo кошелька 🖍</b>\n"
            "❕ Получить можно тут 👉 <a href='https://yoomoney.ru/docs/wallet'><b>Нажми на меня</b></a>\n"
            "❕ При получении токена, ставьте только первые 3 галочки.",
            disable_web_page_preview=True
        )
    if lang == "en":
        await message.answer(
            "<b>🥝 Please, enter <code> API token </code> Yoo wallet 🖍</b>\n"
            "❕ You can get it here 👉 <a href='https://yoomoney.ru/docs/wallet'><b>Click Me</b></a>\n"
            "❕ When receiving a token, put only the first 3 ticks",
            disable_web_page_preview=True
        )
    #else:
        #await message.answer("<b>❌ Номер должен начинаться с + <code>(+7..., +380...)</code></b>\n"
        #                     "🥝 Введите <code>номер (через +7, +380)</code> QIWI кошелька 🖍")


# Принятие токена для QIWI
@dp.message_handler(IsAdminorShopAdmin(), state="here_qiwi_token")
async def payment_qiwi_edit_token(message: Message, state: FSMContext):
    await state.update_data(here_qiwi_token=message.text)
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await state.set_state("here_qiwi_secret")
    await message.answer(
        "<b>🥝 Введите <code>Секретный ключ 🖍</code></b>\n"
        "❕ Получить можно тут 👉 <a href='https://qiwi.com/p2p-admin/transfers/api'><b>Нажми на меня</b></a>\n"
        "❕ Вы можете пропустить добавление оплаты по Форме, отправив: <code>0</code>",
        disable_web_page_preview=True
    )

# Принятие токена для Yoo
@dp.message_handler(IsAdminorShopAdmin(), state="here_yoo_token")
async def payment_qiwi_edit_token(message: Message, state: FSMContext):
    await state.update_data(here_yoo_token=message.text)
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await state.set_state("here_yoo_client_id")
    if lang == "ru":
        await message.answer(
            "<b>🥝 Введите <code>Клиентский ID 🖍</code></b>\n"
            "❕ Получить можно тут 👉 <a href='https://yoomoney.ru/p2p-admin/transfers/api'><b>Нажми на меня</b></a>\n"
            "❕ Вы можете пропустить добавление оплаты по Форме, отправив: <code>0</code>",
            disable_web_page_preview=True
        )
    if lang == "ru":
        await message.answer(
            "<b>🥝 Plaese Enter <code>Client ID 🖍</code></b>\n"
            "❕ You can enter this here 👉 <a href='https://yoomoney.ru/p2p-admin/transfers/api'><b>Нажми на меня</b></a>\n"
            "❕ Вы можете пропустить добавление оплаты по Форме, отправив: <code>0</code>",
            disable_web_page_preview=True
        )

# Принятие клиентского ID для Yoo
@dp.message_handler(IsAdminorShopAdmin(), state="here_yoo_client_id")
async def payment_qiwi_edit_token(message: Message, state: FSMContext):
    await state.update_data(here_yoo_client_id=message.text)
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await state.set_state("here_yoo_redirect_url")
    if lang == "ru":
        await message.answer(
            "<b>🥝 Введите <code>Redirect URL 🖍</code></b>\n"
            "❕ Получить можно в разделе Настройки YooMoney после аутентификации 👉 <a href='https://yoomoney.ru'><b>Нажми на меня</b></a>\n"
            "❕ Вы можете пропустить добавление оплаты по Форме, отправив: <code>0</code>",
            disable_web_page_preview=True
        )
    if lang == "en":
        await message.answer(
            "<b>🥝 Please enter <code>Redirect URL 🖍</code></b>\n"
            "❕ You can get it in the Settings section of YooMoney after authentication 👉 <a href='https://yoomoney.ru'><b>Click Me</b></a>\n"
            "❕ You can skip adding payment by Form by sending: <code>0</code>",
            disable_web_page_preview=True
        )


# Принятие приватного ключа для QIWI
@dp.message_handler(IsAdminorShopAdmin(), state="here_qiwi_secret")
async def payment_qiwi_edit_secret(message: Message, state: FSMContext):
    async with state.proxy() as data:
        qiwi_login = data['here_qiwi_login']
        qiwi_token = data['here_qiwi_token']
        if message.text == "0": qiwi_secret = "None"
        if message.text != "0": qiwi_secret = message.text
        user_id = message.from_user.id
        lang = get_userx(user_id=user_id)['user_lang']

    await state.finish()
    if lang == "ru":
        cache_message = await message.answer("<b>🥝 Проверка введённых QIWI данных... 🔄</b>")
    if lang == "en":
        cache_message = await message.answer("<b>🥝 Checking the entered QIWI data... 🔄</b>")

    await asyncio.sleep(0.5)

    await (await QiwiAPI(cache_message, qiwi_login, qiwi_token, qiwi_secret, add_pass=True, suser_id=user_id)).pre_checker()


# Принятие приватного ключа для Yoo
@dp.message_handler(IsAdminorShopAdmin(), state="here_yoo_redirect_url")
async def payment_qiwi_edit_secret(message: Message, state: FSMContext):
    async with state.proxy() as data:
        acc_number = data['here_yoo_acc_number']
        token = data['here_yoo_token']
        client_id = data['here_yoo_client_id']
        user_id = message.from_user.id
        lang = get_userx(user_id=user_id)['user_lang']

        if message.text == "0": redirect_url = "None"
        if message.text != "0": redirect_url = message.text

        print(acc_number, token, client_id, redirect_url)

    await state.finish()

    if lang == "ru":
        cache_message = await message.answer("<b>🥝 Проверка введённых Yoo данных... 🔄</b>")
    if lang == "en":
        cache_message = await message.answer("<b>🥝 Checking the entered Yoo data... 🔄</b>")
    await asyncio.sleep(0.5)
    #await update_paymentx()
    await (await YooAPI(user_id, acc_number, token, client_id, redirect_url)).update_yoo()
    await message.answer(
        "<b>Данные YooMoney успешно обновлены!</b>\n",
         disable_web_page_preview=True
    )


tgbot >handlers>admin_payment2.py:
# - *- coding: utf- 8 - *-
import asyncio

from aiogram.dispatcher import FSMContext
from aiogram.types import CallbackQuery, Message

import json
from tgbot.keyboards.inline_admin import payment_choice_finl
from tgbot.loader import dp
from tgbot.services.api_qiwi import QiwiAPI
from tgbot.services.api_yoo import YooAPI
from tgbot.services.api_sqlite import update_paymentx, get_paymentx, get_upaycount, get_upaymentx, update_upaymentx
from tgbot.utils.misc.bot_filters import IsAdmin, IsAdminorShopAdmin


###################################################################################
############################# ВЫБОР СПОСОБА ПОПОЛНЕНИЯ ############################
# Открытие способов пополнения
@dp.message_handler(IsAdminorShopAdmin(), text="🖲 Способы пополнения", state="*")
async def payment_systems(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    print(user_id)

    await message.answer("<b>🖲 Выберите способ пополнения</b>", reply_markup=payment_choice_finl(user_id))


# Включение/выключение самих способов пополнения
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="change_payment:")
async def payment_systems_edit(call: CallbackQuery):
    way_pay = call.data.split(":")[1]
    way_status = call.data.split(":")[2]
    user_id = str(json.dumps(call.data.split(":")[3]))
    user_id = user_id.strip("\"")
    print(user_id)
    print(call.from_user.id)

    count = get_upaycount(user_id)
    if count == 0:
        cur = create_upayments_row(user_id)
    else:
        #get_payment = get_paymentx
        get_payment = get_upaymentx(user_id)
        print(get_payment)

    if get_payment['qiwi_login'] != "None" and get_payment['qiwi_token'] != "None" or way_status == "False":
        if way_pay == "Form":
            if get_payment['qiwi_secret'] != "None" or way_status == "False":
                update_upaymentx(user_id, way_form=way_status)
            else:
                await call.answer(
                    "❗ Приватный ключ отсутствует. Измените киви и добавьте приватный ключ для включения оплаты по Форме",
                    True)
        elif way_pay == "ForYm":
            if get_payment['yoo_client_id'] != "None" or way_status == "False":
                update_upaymentx(user_id, way_formy=way_status)
            else:
                await call.answer(
                    "❗ Приватный ключ отсутствует. Измените киви и добавьте приватный ключ для включения оплаты по Форме",
                    True)
        elif way_pay == "Number":
            update_upaymentx(user_id, way_number=way_status)
        elif way_pay == "Nickname":
            status, response = await (await QiwiAPI(call)).get_nickname()
            if status:
                update_upaymentx(user_id, way_nickname=way_status, qiwi_nickname=response)
            else:
                await call.answer(response, True)
    else:
        await call.answer("❗ Добавьте киви кошелёк перед включением Способов пополнений.", True)

    try:
        await call.message.edit_text("<b>🖲 Выберите способ пополнения</b>", reply_markup=payment_choice_finl(user_id))
    except Exception:
        pass


###################################################################################
####################################### QIWI ######################################
# Изменение QIWI кошелька
@dp.message_handler(IsAdminorShopAdmin(), text="🥝 Изменить QIWI 🖍", state="*")
async def payment_qiwi_edit(message: Message, state: FSMContext):
    await state.finish()

    await state.set_state("here_qiwi_login")
    await message.answer("<b>🥝 Введите <code>номер (через +7, +380)</code> QIWI кошелька 🖍</b>")


# Проверка работоспособности QIWI
@dp.message_handler(IsAdminorShopAdmin(), text="🥝 Проверить QIWI ♻", state="*")
async def payment_qiwi_check(message: Message, state: FSMContext):
    print("||| Проверка КИВИ админом площадки. |||")
    await state.finish()
    user_id = message.from_user.id

    await (await QiwiAPI(message, check_pass=True)).pre_checker()


# Баланс QIWI
@dp.message_handler(IsAdminorShopAdmin(), text="🥝 Баланс QIWI 👁", state="*")
async def payment_qiwi_balance(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id

    await (await QiwiAPI(message)).get_balance()

######################################## YooMoney ################################
# Изменение реквизитов Yoo
@dp.message_handler(IsAdminorShopAdmin(), text="💳 Изменить Yoo 🖍", state="*")
async def payment_qiwi_edit(message: Message, state: FSMContext):
    await state.finish()

    await state.set_state("here_yoo_acc_number")
    await message.answer("<b>💳 Введите <code>номер счета </code> Yoo аккаунта 🖍</b>")


######################################## ПРИНЯТИЕ QIWI ########################################
# Принятие логина для QIWI
@dp.message_handler(IsAdminorShopAdmin(), state="here_qiwi_login")
async def payment_qiwi_edit_login(message: Message, state: FSMContext):
    if message.text.startswith("+"):
        await state.update_data(here_qiwi_login=message.text)

        await state.set_state("here_qiwi_token")
        await message.answer(
            "<b>🥝 Введите <code>токен API</code> QIWI кошелька 🖍</b>\n"
            "❕ Получить можно тут 👉 <a href='https://qiwi.com/api'><b>Нажми на меня</b></a>\n"
            "❕ При получении токена, ставьте только первые 3 галочки.",
            disable_web_page_preview=True
        )
    else:
        await message.answer("<b>❌ Номер должен начинаться с + <code>(+7..., +380...)</code></b>\n"
                             "🥝 Введите <code>номер (через +7, +380)</code> QIWI кошелька 🖍")


# Принятие acc_number для Yoo
@dp.message_handler(IsAdminorShopAdmin(), state="here_yoo_acc_number")
async def payment_qiwi_edit_login(message: Message, state: FSMContext):
    #if message.text.startswith("+"):
        await state.update_data(here_yoo_acc_number=message.text)

        await state.set_state("here_yoo_token")
        await message.answer(
            "<b>🥝 Введите <code>токен API</code> Yoo кошелька 🖍</b>\n"
            "❕ Получить можно тут 👉 <a href='https://yoomoney.ru/api'><b>Нажми на меня</b></a>\n"
            "❕ При получении токена, ставьте только первые 3 галочки.",
            disable_web_page_preview=True
        )
    #else:
        #await message.answer("<b>❌ Номер должен начинаться с + <code>(+7..., +380...)</code></b>\n"
        #                     "🥝 Введите <code>номер (через +7, +380)</code> QIWI кошелька 🖍")


# Принятие токена для QIWI
@dp.message_handler(IsAdminorShopAdmin(), state="here_qiwi_token")
async def payment_qiwi_edit_token(message: Message, state: FSMContext):
    await state.update_data(here_qiwi_token=message.text)

    await state.set_state("here_qiwi_secret")
    await message.answer(
        "<b>🥝 Введите <code>Секретный ключ 🖍</code></b>\n"
        "❕ Получить можно тут 👉 <a href='https://qiwi.com/p2p-admin/transfers/api'><b>Нажми на меня</b></a>\n"
        "❕ Вы можете пропустить добавление оплаты по Форме, отправив: <code>0</code>",
        disable_web_page_preview=True
    )

# Принятие токена для Yoo
@dp.message_handler(IsAdminorShopAdmin(), state="here_yoo_token")
async def payment_qiwi_edit_token(message: Message, state: FSMContext):
    await state.update_data(here_yoo_token=message.text)

    await state.set_state("here_yoo_client_id")
    await message.answer(
        "<b>🥝 Введите <code>Клиентский ID 🖍</code></b>\n"
        "❕ Получить можно тут 👉 <a href='https://yoomoney.ru/p2p-admin/transfers/api'><b>Нажми на меня</b></a>\n"
        "❕ Вы можете пропустить добавление оплаты по Форме, отправив: <code>0</code>",
        disable_web_page_preview=True
    )

# Принятие клиентского ID для Yoo
@dp.message_handler(IsAdminorShopAdmin(), state="here_yoo_client_id")
async def payment_qiwi_edit_token(message: Message, state: FSMContext):
    await state.update_data(here_yoo_client_id=message.text)

    await state.set_state("here_yoo_redirect_url")
    await message.answer(
        "<b>🥝 Введите <code>Redirect URL 🖍</code></b>\n"
        "❕ Получить можно тут 👉 <a href='https://yoomoney.ru/p2p-admin/transfers/api'><b>Нажми на меня</b></a>\n"
        "❕ Вы можете пропустить добавление оплаты по Форме, отправив: <code>0</code>",
        disable_web_page_preview=True
    )


# Принятие приватного ключа для QIWI
@dp.message_handler(IsAdminorShopAdmin(), state="here_qiwi_secret")
async def payment_qiwi_edit_secret(message: Message, state: FSMContext):
    async with state.proxy() as data:
        qiwi_login = data['here_qiwi_login']
        qiwi_token = data['here_qiwi_token']
        if message.text == "0": qiwi_secret = "None"
        if message.text != "0": qiwi_secret = message.text
        user_id = message.from_user.id

    await state.finish()

    cache_message = await message.answer("<b>🥝 Проверка введённых QIWI данных... 🔄</b>")
    await asyncio.sleep(0.5)

    await (await QiwiAPI(cache_message, qiwi_login, qiwi_token, qiwi_secret, True)).pre_checker()


# Принятие приватного ключа для Yoo
@dp.message_handler(IsAdminorShopAdmin(), state="here_yoo_redirect_url")
async def payment_qiwi_edit_secret(message: Message, state: FSMContext):
    async with state.proxy() as data:
        acc_number = data['here_yoo_acc_number']
        token = data['here_yoo_token']
        client_id = data['here_yoo_client_id']
        if message.text == "0": redirect_url = "None"
        if message.text != "0": redirect_url = message.text

    await state.finish()

    cache_message = await message.answer("<b>🥝 Проверка введённых Yoo данных... 🔄</b>")
    await asyncio.sleep(0.5)
    #await update_paymentx()
    await (await YooAPI(acc_number, token, client_id, redirect_url)).update_yoo()
    await message.answer(
        "<b>Данные yoomoney успешно обновлены!</b>\n"
        "❕ Вы можете пропустить добавление оплаты по Форме, отправив: <code>0</code>",
         disable_web_page_preview=True
    )



tgbot >handlers>admin_products_shop.py:
from aiogram.dispatcher import FSMContext
from aiogram.types import CallbackQuery, Message
from aiogram.utils.exceptions import CantParseEntities

from tgbot.keyboards.inline_admin import category_edit_open_finl, position_edit_open_finl, category_edit_delete_finl, \
    position_edit_clear_finl, position_edit_delete_finl, shop_edit_open_finl, shop_name_edit_open_finl, shop_edit_delete_finl
from tgbot.keyboards.inline_z_all import category_remove_confirm_inl, position_remove_confirm_inl, \
    item_remove_confirm_inl, close_inl
from tgbot.keyboards.shop_keyboards import *
from tgbot.keyboards.reply_z_all import finish_load_rep, items_frep
from tgbot.keyboards.inline_z_page import position_create_open_fp
from tgbot.loader import dp
from tgbot.middlewares.throttling import rate_limit
from tgbot.services.api_sqlite_shop import *
from tgbot.services.api_sqlite import get_city_user, get_city_user3, check_user_shop_exist, get_settingsx, get_my_shopx, remove_shopx, get_userx, get_all_shopx
from tgbot.utils.const_functions import clear_list
from tgbot.utils.misc.bot_filters import IsAdmin, IsShopAdmin, IsAdminorShopAdmin
from tgbot.utils.misc_functions import get_position_admin, upload_text, get_shop_admin
# Добавлено
from tgbot.keyboards.location_keyboards import geo_1_kb
from tgbot.services.location_function import update_position_city, get_city_info


# принятие названия магазина, запрос описания
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_name")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        print("admin_products_shop - создание магазина")
        await state.update_data(data={'name': message.text})
        await state.set_state('here_shop_description')
        await message.answer(_("<b>🏪 Введите описание для магазина 📜</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')
    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "🏪 Введите название для магазина 🏷", locale=lang), parse_mode='HTML')


# принятие описания магазина, запрос адреса
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_description")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 600:
        if message.text == '0':
            await state.update_data(data={'description': 'None'})
        else:
            await state.update_data(data={'description': message.text})
        await state.set_state('here_shop_adress')
        await message.answer(_("<b>🏪 Отправьте адресс магазина 📍</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


    else:
        await message.answer(_("<b>❌ Описание не может превышать 600 символов.</b>\n"
                             "🏪 Введите новое описание для магазина 📜\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


# принятие адреса магазина, запрос номера
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_adress")
async def product_category_create_name(message: Message, state: FSMContext):
    if message.text == '0':
        await state.update_data(data={'address': 'None'})
    else:
        await state.update_data(data={'address': message.text})
    await state.set_state('here_shop_phone')
    await message.answer(_("<b>🏪 Отправьте телефон магазина ☎️</b>\n"
                         "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


# принятие номера магазина, запрос лого
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_phone")
async def product_category_create_name(message: Message, state: FSMContext):
    if message.text == '0':
        await state.update_data(data={'phone': 'None'})
    else:
        await state.update_data(data={'phone': message.text})
    await state.set_state('here_shop_logo')
    await message.answer(_("<b>🏪 Отправьте лого магазина 📷</b>\n"
                         "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


# принятие лого магазина, запрос лого
@dp.message_handler(IsAdminorShopAdmin(), content_types=['photo','text'], state="here_shop_logo")
async def product_category_create_logo(message: Message, state: FSMContext):
    logo = message.photo[0].file_id if message.content_type == 'photo' else None
    async with state.proxy() as data:
        print(data)
        name = data['name']
        description = data['description']
        address = data['address']
        phone = data['phone']

    await state.finish()

    type_trade = get_settingsx()
    if type_trade['type_trade'] != "digital":
        city = get_city_user3(message.from_user.id)
        print(city)
        city_id = city[0]
        geocode = city[1]
        city_name = city[2]
    else:
        city_id = 0
        geocode = ''
        city_name = ''
    add_shopx(name, description, address, phone, message.from_user.id, logo, city_id, geocode, city_name)
    await message.answer(_("<b>🏪 Магазин был успешно создан ✅</b>", locale=lang), parse_mode='HTML')

################################################################################################
####################################### СОЗДАНИЕ МАГАЗИНА #####################################
# Принятие названия магазина для её создания
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_name")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        add_shopx(clear_html(message.text))

        await state.finish()
        await message.answer(_("<b>🏪 Магазин был успешно создан ✅</b>", locale=lang))
    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "🏪 Введите название для магазина 🏷", locale=lang), locale=lang)

# -----------------------------------------------------------------------------------------------------------
# Открытие страниц выбора магазина для редактирования
@dp.message_handler(IsAdminorShopAdmin(), text="🏪 Изменить магазин 🖍2", state="*")
async def shop_list_edit(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']
    shops = get_shopsxx(admin=user_id)
    print(shops)

    if len(shops) >= 1:
        await message.answer(_("<b>🏪 Выберите магазин для изменения 🖍</b>", locale=lang),
                             reply_markup=shop_edit_open_fp(0, user_id, lang))
    else:
        await message.answer(_("<b>🏪 Ваши магазины отсутствуют 🖍</b>", locale=lang))


# Смена страницы выбора магазина
@dp.message_handler(IsAdminorShopAdmin(), text_startswith="change_shop_edit_pg:", state="*")
async def shop_list_edit(call: CallbackQuery, state: FSMContext):
    await state.finish()
    user_id = call.from_user.id
    lang = get_user_lang(user_id)['user_lang']
    if len(shops) >= 1:
        remover = int(str(call.data).split(':')[1])

        await call.message.answer(_("<b>🏪 Выберите магазин для изменения 🖍</b>", locale=lang),
                             reply_markup=shop_edit_open_fp(remover, user_id, lang))
    else:
        await call.message.answer(_("<b>🏪 Магазины отсутствуют 🖍</b>", locale=lang))


# Выбор позиции для редактирования
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="shop_edit_open:", state="*")
async def product_position_edit_open(call: CallbackQuery, state: FSMContext):
    print('Выбор магазина для редактирования api_sqlite.py 169')
    shop_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    user_id = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    print(shop_id, remover, user_id)

    get_message, get_photo = get_shop_admin(shop_id)

    if get_photo is not None and get_photo != '':
        await call.message.delete()
        await call.message.answer_photo(get_photo, get_message, reply_markup=shop_edit_open_finl(shop_id, user_id, remover, lang))
    else:
        await call.message.edit_text(get_message, reply_markup=shop_edit_open_finl(shop_id, user_id, remover, lang))


# Возвращение к выбору позиции для изменения
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="shop_edit_return", state="*")
async def product_position_edit_return(call: CallbackQuery, state: FSMContext):
    user_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    user_id = call.from_user.id
    print(user_id)
    shops = get_shopsxx(admin=user_id)

    print(shops)

    if len(shops) >= 1:
        await call.message.delete()
        await call.message.answer(_("<b>📁 Выберите нужный Вам магазин 🖍</b>", locale=lang),
                                  reply_markup=shop_edit_open_fp(0, user_id, lang))
    else:
        await call.answer("<b>❗ У Вас отсутствуют магазины</b>")

################################ Добавление магазина при создании позиции ########################

# Создание новой позиции
@dp.message_handler(IsAdminorShopAdmin(), text="📁 Создать позицию ➕2", state="*")
async def product_position_create(message: Message, state: FSMContext):
    await state.finish()
    print("APS 182")

    await message.answer(_("<b>📁 Выберите категорию для позиции</b>", locale=lang),
                             reply_markup=position_people_create_open_fp(0))
    #else:
        #await message.answer(_("<b>❌ Отсутствуют магазины для создания позиции.</b>", locale=lang))


######################################## САМО ИЗМЕНЕНИЕ МАГАЗИНОВ ########################################
# Изменение названия магазина
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="shop_edit_name:", state="*")
async def product_category_edit_name(call: CallbackQuery, state: FSMContext):
    print("|||| -= EDIT SHOP NAME =- ||||")

    shop_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_shop_id=shop_id)
    await state.update_data(here_cache_user_id=user_id)
    await state.update_data(here_cache_shop_remover=remover)

    await state.set_state("here_change_shop_name")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Введите новое название для магазина 🏷</b>", locale=lang))


# Принятие нового имени для магазина
@dp.message_handler(IsAdminorShopAdmin(), state="here_change_shop_name")
async def product_shop_edit_name_get(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        async with state.proxy() as data:
            shop_id = data['here_cache_shop_id']
            remover = data['here_cache_shop_remover']
            user_id = data['here_cache_user_id']
        await state.finish()

        update_shopx(shop_id, name=clear_html(message.text))
        get_shop = get_shopx(shop_id=shop_id)

        await message.answer(f"<b>🗃 Новое название магазина: <code>{get_shop['name']}</code></b>\n"
                             "➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖\n", reply_markup=shop_name_edit_open_finl(shop_id, user_id, remover, lang))
    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "🗃 Введите новое название для магазина 🏷", locale=lang))


# Изменение описания позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="shop_edit_description", state="*")
async def product_shop_edit_description(call: CallbackQuery, state: FSMContext):
    print("|||| -= EDIT SHOP NAME =- ||||")
    shop_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_shop_id=shop_id)
    await state.update_data(here_cache_user_id=user_id)
    await state.update_data(here_cache_shop_remover=remover)

    await state.set_state("here_change_shop_description")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Введите новое описание для позиции 📜</b>\n"
                              "❕ Вы можете использовать HTML разметку\n"
                              "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))


# Принятие описания позиции для её изменения
@dp.message_handler(IsAdminorShopAdmin(), state="here_change_shop_description")
async def product_shop_edit_description_get(message: Message, state: FSMContext):
    async with state.proxy() as data:
        shop_id = data['here_cache_shop_id']
        remover = data['here_cache_shop_remover']
        user_id = data['here_cache_user_id']

    try:
        if len(message.text) <= 900:
            await state.finish()

            if message.text != "0":
                cache_msg = await message.answer(message.text)
                await cache_msg.delete()

            update_shopx(shop_id, description=message.text)
            get_message, get_photo = get_shop_admin(shop_id)

            if get_photo is not None:
                await message.answer_photo(get_photo, get_message, reply_markup=shop_edit_open_finl(shop_id, user_id, remover))
            else:
                await message.answer(get_message, reply_markup=shop_edit_open_finl(shop_id, user_id, remover))
        else:
            await message.answer(_("<b>❌ Описание не может превышать 600 символов.</b>\n"
                                 "📁 Введите новое описание для магазина 📜\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))
    except CantParseEntities:
        await message.answer(_("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📁 Введите новое описание для магазина 📜\n"
                             "❕ Вы можете использовать HTML разметку\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))

# Изменение изображения позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="shop_edit_photo", state="*")
async def product_shop_edit_photo(call: CallbackQuery, state: FSMContext):
    shop_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_shop_id=shop_id)
    await state.update_data(here_cache_user_id=user_id)
    await state.update_data(here_cache_shop_remover=remover)

    await state.set_state("here_change_shop_photo")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Отправьте новое изображение для позиции 📸</b>\n"
                                "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))


# Принятие нового фото для позиции
@dp.message_handler(IsAdminorShopAdmin(), content_types="photo", state="here_change_shop_photo")
@dp.message_handler(IsAdminorShopAdmin(), text="0", state="here_change_shop_photo")
async def product_shop_edit_photo_get(message: Message, state: FSMContext):
    async with state.proxy() as data:
        shop_id = data['here_cache_shop_id']
        user_id = data['here_cache_user_id']
        remover = data['here_cache_shop_remover']
    await state.finish()

    shop_photo = "" if "text" in message else message.photo[-1].file_id
    update_shopx(shop_id, logo=shop_photo)
    get_message, get_photo = get_shop_admin(shop_id)

    if get_photo is not None:
        await message.answer_photo(get_photo, get_message, reply_markup=shop_edit_open_finl(shop_id, user_id, remover, lang))
    else:
        await message.answer(get_message, reply_markup=shop_edit_open_finl(shop_id, user_id, remover, lang))


# -------------------------------------------------------------------------------------------------------------
# Окно с уточнением удалить все магазины (позиции и товары включительно)
@dp.message_handler(text=["🏪 Удалить все магазины ❌", "🏪 Delete all shops ❌"], state="*")
async def product_category_remove(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']

    if user_role == "Admin":
        await message.answer("<b>🗃 Вы действительно хотите удалить все магазины? ❌</b>\n",
                             reply_markup=category_remove_confirm_inl)

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
################################################################################################
####################################### ИЗМЕНЕНИЕ МАГАЗИНА ####################################

# Следующая страница позиций для их изменения
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="shop_edit_nextp:", state="*")
async def product_position_edit_next(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])

    await call.message.edit_text(_("<b>📁 Выберите магазин для изменения 🖍</b>", locale=lang), reply_markup=shop_edit_next_page_fp(remover, user_id))

# Предыдущая страница позиций для их изменения
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="shop_edit_backp:", state="*")
async def product_position_edit_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])

    await call.message.edit_text(_("<b>📁 Выберите магазин для изменения 🖍</b>", locale=lang), reply_markup=shop_edit_back_page_fp(remover, user_id))


# Выбор позиции для редактирования
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="shop_edit_open:", state="*")
async def shop_edit_open(call: CallbackQuery, state: FSMContext):
    print('Выбор магазина для редактирования api_sqlite.py 421')
    shop_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    user_id = int(call.data.split(":")[3])

    get_message, get_photo = get_shop_admin(shop_id)

    if get_photo is not None:
        await call.message.delete()
        await call.message.answer_photo(get_photo, get_message, reply_markup=shop_edit_open_finl(shop_id, user_id, remover))
    else:
        await call.message.edit_text(get_message, reply_markup=shop_edit_open_finl(shop_id, user_id, remover))

# Следующая страница магазинов для их изменения
def shop_edit_next_page_fp(remover, user_id):
    get_shops = get_shopsxx(admin=user_id)
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_shops))):
        if count < cpage:
            #get_items = get_itemsx(position_id=get_positions[a]['position_id'])
            keyboard.add(ikb(f"{get_shops[a]['name']}", callback_data=f"shop_edit_open:{get_shops[a]['shop_id']}:{remover}:{user_id}")) # | {get_positions[a]['position_price']}₽ | {len(get_items)} шт",
    if remover + cpage >= len(get_shops):
        keyboard.add(ikb("⬅ Назад", callback_data=f"shop_edit_backp:{remover - cpage}:{user_id}"), ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(ikb("⬅ Назад", callback_data=f"shop_edit_backp:{remover - cpage}:{user_id}"),
                     ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
                     ikb("Далее ➡", callback_data=f"shop_edit_nextp:{remover + cpage}:{user_id}"),
        )
    #keyboard.add(ikb("⬅ Вернуться ↩", callback_data="shop_edit_category_return"))

    return keyboard


# Предыдующая страница позиций для их изменения
def shop_edit_back_page_fp(remover, user_id):
    get_shops = get_shopsxx(admin=user_id)
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_shops))):
        if count < cpage:
            #get_items = get_itemsx(position_id=get_positions[a]['position_id'])    # | {get_shops[a]['position_price']}₽ | {len(get_items)} шт",
            keyboard.add(ikb(f"{get_shops[a]['name']}", callback_data=f"shop_edit_open:{get_shops[a]['shop_id']}:{remover}:{user_id}"))
    if remover <= 0:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb("Далее ➡", callback_data=f"shop_edit_nextp:{remover + cpage}:{user_id}")
        )
    else:
        keyboard.add(ikb("⬅ Назад", callback_data=f"shop_edit_backp:{remover - cpage}:{user_id}"),
                     ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
                     ikb("Далее ➡", callback_data=f"shop_edit_nextp:{remover + cpage}:{user_id}"),
        )
    #keyboard.add(ikb("⬅ Вернуться ↩", callback_data="shop_edit_return"))

    return keyboard


# Окно с уточнением удалить категорию
@dp.callback_query_handler(text_startswith="shop_edit_delete", state="*")
async def shop_edit_dellete(call: CallbackQuery, state: FSMContext):
    shop_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    user_id = call.from_user.id

    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    if user_role == "Admin":
        print("shop_edit_delete")
        await call.answer("🗃 Магазин будет удален ✅")

        await call.message.answer("<b>❗ Вы действительно хотите удалить один из магазинов?</b>", #_("<b>❗ Вы действительно хотите удалить один из магазинов?</b>", locale=lang),
                                     reply_markup=shop_edit_delete_finl(shop_id, remover, lang))

# Отмена удаления категории
@dp.callback_query_handler(text_startswith="shop_delete:", state="*")
async def shop_edit_delete_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    shop_id = int(call.data.split(":")[2])
    user_id = call.from_user.id
    print(get_action, shop_id, user_id)
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    print(lang, user_role)
    if user_role == "Admin":
        if get_action == "yes":
            remove_shopx(shop_id=shop_id)

            #if len(get_all_shopx()) >= 1:
            #await call.message.delete()
            await call.message.edit_text(_("🗃 Магазин был успешно удален ✅", locale=lang), reply_markup=shop_edit_open_fp(0, user_id, lang))
            #else:
            #    await call.message.delete()
        else:
            get_shop_count = len(get_shopx(store_id=shop_id))
            get_shop = get_shopx(shop_id=shop_id)

            remover = 0

            await call.message.edit_text(f"<b>🗃 Магазин: <code>{get_shop['name']}</code></b>\n"
                                         "➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                         f"📁 Кол-во позиций: <code>{get_shop_count}шт</code>", reply_markup=shop_edit_open_finl(shop_id, remover, lang))

tgbot >handlers>admin_products.py:
# - *- coding: utf- 8 - *-
from aiogram.dispatcher import FSMContext
from aiogram.types import CallbackQuery, Message
from aiogram.utils.exceptions import CantParseEntities
from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR

from tgbot.keyboards.inline_admin import category_edit_open_finl, position_edit_open_finl, category_edit_delete_finl, \
    position_edit_clear_finl, position_edit_delete_finl
from tgbot.keyboards.inline_z_all import category_remove_confirm_inl, position_remove_confirm_inl, \
    item_remove_confirm_inl, close_inl
from tgbot.keyboards.inline_z_page import *
from tgbot.keyboards.reply_z_all import finish_load_rep, items_frep, items_sh_frep
from tgbot.loader import dp
from tgbot.middlewares.throttling import rate_limit
from tgbot.services.api_sqlite import *
from tgbot.utils.const_functions import clear_list
from tgbot.utils.misc.bot_filters import IsAdmin, IsShopAdmin, IsAdminorShopAdmin
from tgbot.utils.misc_functions import get_position_admin, upload_text
# Добавлено
from tgbot.keyboards.location_keyboards import geo_1_kb
from tgbot.services.location_function import update_position_city, get_city_info

from tgbot.middlewares.i18n import I18nMiddleware
i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
_ = i18n.gettext

# Открытие страниц выбора категорий для редактирования
@dp.message_handler(text=["🗃 Изменить категорию 🖍", "🗃 Edit category 🖍"], state="*")
async def product_category_edit(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']

    if user_role in ["Admin", "ShopAdmin"]:
        if len(get_all_categoriesx()) >= 1:
            await state.finish()
            await message.answer(_("<b>🗃 Выберите категорию для изменения 🖍</b>", locale=lang),
                                 reply_markup=category_edit_open_fp(0, lang))
        else:
            await state.finish()
            await message.answer(_("<b>🗃 Категории отсутствуют 🖍</b>", locale=lang))


# Окно с уточнением удалить все категории (позиции и товары включительно)
@dp.message_handler(text=["🗃 Удалить все категории ❌", "🗃 Delete all categories ❌"], state="*")
async def product_category_remove(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']

    if user_role in ["Admin", "ShopAdmin"]:
        await message.answer(_("<b>🗃 Вы действительно хотите удалить все категории? ❌</b>\n"
                             "❗ Так же будут удалены все позиции и товары", locale=lang),
                             reply_markup=category_remove_confirm_inl)

# Начальные категории для изменения позиции
@dp.message_handler(text="📁 Изменить позицию 🖍2", state="*")
async def product_position_edit(message: Message, state: FSMContext):
    print('📁 Изменить позицию 🖍  admin_products.py 73')
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    if user_role == "Admin":
        await message.answer(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                             reply_markup=position_edit_category_open_fp(0, lang))

# Подтверждение удаления всех позиций
@dp.message_handler(text=["📁 Удалить все позиции ❌", "📁 Delete all positions ❌"], state="*")
async def product_position_remove(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    if user_role == "Admin":
        await message.answer(_("<b>📁 Вы действительно хотите удалить все позиции? ❌</b>\n"
                             "❗ Так же будут удалены все товары", locale=lang),
                             reply_markup=position_remove_confirm_inl)

# Начальные категории для добавления товаров
@dp.message_handler(text=["🎁 Добавить товары ➕", "🎁 Add Goods➕"], state="*")
async def product_item_create(message: Message, state: FSMContext):
    print('🎁 Добавить товары ➕  admin_products_shop.py 93')
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']

    if user_role == "Admin" or user_role == "ShopAdmin":
        if len(get_all_positionsx()) >= 1:
            await message.answer(_("<b>🎁 Выберите категорию с нужной позицией</b>", locale=lang),
                                 reply_markup=products_add_category_open_fp(0, lang))
        else:
            await message.answer(_("<b>❌ Отсутствуют позиции для добавления товара.</b>", locale=lang))


# Удаление определённых товаров
@dp.message_handler(text=["🎁 Удалить товары 🖍", "🎁 Delete Goods 🖍"], state="*")
async def product_item_delete(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']

    if user_role == "Admin":
        await state.set_state("here_items_delete")
        await message.answer(_("<b>🖍 Вводите айди товаров, которые нужно удалить</b>\n"
                             "❕ Получить айди товаров можно при изменении позиции\n"
                             "❕ Если хотите удалить несколько товаров, отправьте ID товаров через запятую или пробел. Пример:\n"
                             "<code>▶ 123456,123456,123456</code>\n"
                             "<code>▶ 123456 123456 123456</code>", locale=lang))


# -------------------------------------------------------------------------------------------------------------------
# Кнопки с подтверждением удаления всех категорий
@dp.message_handler(text=["🎁 Удалить все товары ❌", "🎁 Delete All Goods ❌"], state="*")
async def product_item_remove(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']

    if user_role == "Admin":
        await message.answer(_("<b>🎁 Вы действительно хотите удалить все товары? ❌</b>\n", locale=lang),
                             reply_markup=item_remove_confirm_inl)


################################################################################################
####################################### СОЗДАНИЕ КАТЕГОРИЙ #####################################
# Принятие названия категории для её создания
@dp.message_handler(IsAdmin(), state="here_category_name")
async def product_category_create_name(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    print(lang)
    if user_role == "Admin":
        if len(message.text) <= 100:
            add_categoryx(clear_html(message.text))
            await message.answer(_("<b>🗃 Категория была успешно создана ✅</b>", locale=lang))
        else:
            await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>", locale=lang))


################################################################################################
####################################### ИЗМЕНЕНИЕ КАТЕГОРИЙ ####################################
# Следующая страница выбора категорий для редактирования
@dp.callback_query_handler(IsAdmin(), text_startswith="catategory_edit_nextp:", state="*")
async def product_category_edit_next(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.edit_text(_("<b>🗃 Выберите категорию для изменения 🖍</b>", locale=lang),
                                 reply_markup=category_edit_next_page_fp(remover, lang))

# Предыдущая страница выбора категорий для редактирования
@dp.callback_query_handler(IsAdmin(), text_startswith="catategory_edit_backp:", state="*")
async def product_category_edit_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.delete()
    await call.message.answer(_("<b>🗃 Выберите категорию для изменения 🖍</b>", locale=lang),
                              reply_markup=category_edit_back_page_fp(remover, lang))


# Выбор текущей категории для редактирования
@dp.callback_query_handler(IsAdmin(), text_startswith="category_edit_here:", state="*")
async def product_category_edit_open(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    get_fat_count = len(get_positionsx(category_id=category_id))
    get_category = get_categoryx(category_id=category_id)

    if lang == "ru":
        await call.message.edit_text(f"<b>🗃 Категория: <code>{get_category['category_name']}</code></b>\n"
                                     "➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                     f"📁 Кол-во позиций: <code>{get_fat_count}шт</code>",
                                     reply_markup=category_edit_open_finl(category_id, remover, lang))
    if lang == "en":
        await call.message.edit_text(f"<b>🗃 Category: <code>{get_category['category_name']}</code></b>\n"
                                     "➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                     f"📁 Position quantity: <code>{get_fat_count}pcs</code>",
                                     reply_markup=category_edit_open_finl(category_id, remover, lang))


# Возвращение к списку выбора категорий для редактирования
@dp.callback_query_handler(IsAdmin(), text_startswith="category_edit_return:", state="*")
async def product_category_edit_return(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.edit_text(_("<b>🗃 Выберите категорию для изменения 🖍</b>", locale=lang),
                                 reply_markup=category_edit_open_fp(remover, lang))


######################################## САМО ИЗМЕНЕНИЕ КАТЕГОРИИ ########################################
# Изменение названия категории
@dp.callback_query_handler(IsAdmin(), text_startswith="category_edit_name:", state="*")
async def product_category_edit_name(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_category_remover=remover)

    await state.set_state("here_change_category_name")
    await call.message.delete()
    await call.message.answer(_("<b>🗃 Введите новое название для категории 🏷</b>", locale=lang))


# Принятие нового имени для категории
@dp.message_handler(IsAdmin(), state="here_change_category_name")
async def product_category_edit_name_get(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    if len(message.text) <= 100:
        async with state.proxy() as data:
            category_id = data['here_cache_category_id']
            remover = data['here_cache_category_remover']
        await state.finish()


        update_categoryx(category_id, category_name=clear_html(message.text))

        get_fat_count = len(get_positionsx(category_id=category_id))
        get_category = get_categoryx(category_id=category_id)

        if lang == "ru":
            await message.answer(f"<b>🗃 Категория: <code>{get_category['category_name']}</code></b>\n"
                                 "➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                 f"📁 Кол-во позиций: <code>{get_fat_count}шт</code>",
                                 reply_markup=category_edit_open_finl(category_id, remover, lang))
        if lang == "en":
            await message.answer(f"<b>🗃 Category: <code>{get_category['category_name']}</code></b>\n"
                                 "➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                 f"📁 Position Quantity: <code>{get_fat_count}pcs</code>",
                                 reply_markup=category_edit_open_finl(category_id, remover, lang))

    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "🗃 Введите новое название для категории 🏷", locale=lang))


# Окно с уточнением удалить категорию
@dp.callback_query_handler(text_startswith="category_edit_delete:", state="*")
async def product_category_edit_delete(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    if user_role == "Admin":
        await call.message.edit_text("<b>❗ Вы действительно хотите удалить категорию и все её данные?</b>",
                                     reply_markup=category_edit_delete_finl(category_id, remover, lang))


# Отмена удаления категории
@dp.callback_query_handler(text_startswith="category_delete:", state="*")
async def product_category_edit_delete_confirm(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    get_action = call.data.split(":")[2]
    remover = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    if user_role == "Admin":
        if get_action == "yes":
            remove_categoryx(category_id=category_id)
            remove_positionx(category_id=category_id)
            remove_itemx(category_id=category_id)

            if lang == "ru":
                await call.answer("🗃 Категория и все её данные были успешно удалены ✅")
            if lang == "en":
                await call.answer("🗃 Category and all of data has been deleted succesfully ✅")
            if len(get_all_categoriesx()) >= 1:
                await call.message.edit_text(_("<b>🗃 Выберите категорию для изменения 🖍</b>", locale=lang),
                                             reply_markup=category_edit_open_fp(remover, lang))
            else:
                await call.message.delete()
        else:
            get_fat_count = len(get_positionsx(category_id=category_id))
            get_category = get_categoryx(category_id=category_id)

            if lang == "ru":
                await message.answer(f"<b>🗃 Категория: <code>{get_category['category_name']}</code></b>\n"
                                     "➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                     f"📁 Кол-во позиций: <code>{get_fat_count}шт</code>",
                                     reply_markup=category_edit_open_finl(category_id, remover, lang))
            if lang == "en":
                await message.answer(f"<b>🗃 Category: <code>{get_category['category_name']}</code></b>\n"
                                     "➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                     f"📁 Position Quantity: <code>{get_fat_count}pcs</code>",
                                     reply_markup=category_edit_open_finl(category_id, remover, lang))


################################################################################################
#################################### УДАЛЕНИЕ ВСЕХ КАТЕГОРИЙ ###################################
# Подтверждение на удаление всех категорий (позиций и товаров включительно)
@dp.callback_query_handler(IsAdmin(), text_startswith="confirm_remove_category:", state="*")
async def product_category_remove_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    if get_action == "yes":
        get_categories = len(get_all_categoriesx())
        get_positions = len(get_all_positionsx())
        get_items = len(get_all_itemsx())

        clear_categoryx()
        clear_positionx()
        clear_itemx()

        await call.message.edit_text(
            f"<b>🗃 Вы удалили все категории<code>({get_categories}шт)</code>, "
            f"позиции<code>({get_positions}шт)</code> и товары<code>({get_items}шт)</code> ☑</b>")
    else:
        await call.message.edit_text("<b>🗃 Вы отменили удаление всех категорий ✅</b>")


################################################################################################
####################################### ДОБАВЛЕНИЕ ПОЗИЦИЙ #####################################
# Следующая страница выбора категорий для создания позиций
@dp.callback_query_handler(IsAdmin(), text_startswith="position_create_nextp:", state="*")
async def product_position_create_next(call: CallbackQuery, state: FSMContext):
    print('выбора категорий для создания позиций  admin_products_shop.py 300')
    remover = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    print(remover)

    await call.message.edit_text(_("<b>📁 Выберите категорию для позиции ➕</b>", locale=lang),
                                 reply_markup=position_create_next_page_fp(remover, lang))


# Предыдущая страница выбора категорий для создания позиций
@dp.callback_query_handler(IsAdmin(), text_startswith="position_create_backp:", state="*")
async def product_position_create_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.edit_text(_("<b>📁 Выберите категорию для позиции ➕</b>", locale=lang),
                                 reply_markup=position_create_back_page_fp(remover, lang))


@dp.callback_query_handler(IsAdmin(), text_startswith="position_shop_create_here:", state="*")
async def product_position_create(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await state.update_data(here_cache_change_shop_id=category_id)

    if len(get_all_categoriesx()) >= 1:
        await call.message.answer(_("<b>📁 Выберите категорию для позиции</b>", locale=lang),
                             reply_markup=position_create_open_fp(0, lang))
    else:
        await call.message.answer(_("<b>❌ Отсутствуют категории для создания позиции.</b>", locale=lang))


# Выбор категории для создания позиции
@dp.callback_query_handler(IsAdmin(), text_startswith="position_create_here2:", state="*")
async def product_position_create_select_category(call: CallbackQuery, state: FSMContext):
    print('position_create_here - admin_products')
    category_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    print(category_id)

    await state.update_data(here_cache_change_category_id=category_id)

    await state.set_state("here_position_name")
    await call.message.edit_text(_("<b>📁 Введите название для позиции 🏷</b>", locale=lang))

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Заготовка под принятие города магазином
# Принятие города для создания позиции
# @dp.message_handler(IsAdmin(), state="here_position_city")
# async def product_position_create_name(message: Message, state: FSMContext):
#     print(f'Принятие города для создания позиции  admin_products_shop.py 344')
#     city_user = get_city_user(message.from_user.id)


# Выбор категории для создания позиции
@dp.callback_query_handler(IsAdmin(), text_startswith="position_create_here:", state="*")
async def product_position_create_select_category(call: CallbackQuery, state: FSMContext):
    print('position_create_here - user_menu 160')
    category_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    await state.update_data(here_cache_change_category_id=category_id)

    print('position_addtoshop - user_menu 555')
    user_id = call.from_user.id
    get_user_shops = get_shopsxx(admin=user_id)
    if len(get_user_shops) >= 1:
        await call.message.edit_text(_("<b>Выберите магазин для добавления позиции.</b>", loacle=lang),
                                     reply_markup=position_select_shop_fp(user_id))

        await state.set_state("here_position_addtoshop")
        await call.message.edit_text(_("<b>📁 Введите название для позиции 🏷</b>", locale=lang))

# Выбор категории для создания позиции
@dp.callback_query_handler(IsAdmin(), text_startswith="here_position_addtoshop:", state="*")
async def product_position_create_select_category(call: CallbackQuery, state: FSMContext):
    print('here_position_addtoshop: - user_menu 574')
    shop_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await state.update_data(here_cache_change_shop_id=shop_id)

    await state.set_state("here_position_name")
    await call.message.edit_text(_("<b>📁 Введите название для позиции 🏷</b>", locale=lang))


# Принятие имени для создания позиции
@dp.message_handler(IsAdmin(), state="here_position_name")
async def product_position_create_name(message: Message, state: FSMContext):
    print('Принятие имени для создания позиции  admin_products.py 355')
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    if len(message.text) <= 100:
        await state.update_data(here_position_name=clear_html(message.text), here_position_city=get_city_user(message.from_user.id)[0], position_city_id=get_city_user(message.from_user.id)[0])

        await state.set_state("here_position_price")
        await message.answer(_("<b>📁 Введите цену для позиции 💰</b>", locale=lang))
    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "📁 Введите название для позиции 🏷", locale=lang))


# Принятие цены позиции для её создания
@dp.message_handler(IsAdmin(), state="here_position_price")
async def product_position_create_price(message: Message, state: FSMContext):
    print('Принятие цены позиции  admin_products.py 366')
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    if message.text.isdigit():
        if 0 <= int(message.text) <= 10000000:
            await state.update_data(here_position_price=message.text)

            await state.set_state("here_position_description")
            await message.answer(_("<b>📁 Введите описание для позиции 📜</b>\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))
        else:
            await message.answer(_("<b>❌ Цена не может быть меньше 0 или больше 10 000 000.</b>\n"
                                 "📁 Введите цену для позиции 💰", locale=lang))
    else:
        await message.answer(_("<b>❌ Данные были введены неверно.</b>\n"
                             "📁 Введите цену для позиции 💰", locale=lang))


# Принятие описания позиции для её создания
@dp.message_handler(IsAdmin(), state="here_position_description")
async def product_position_create_description(message: Message, state: FSMContext):
    print('Принятие описания позиции  admin_products.py 386')
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    try:
        if len(message.text) <= 600:
            if message.text != "0":
                cache_msg = await message.answer(message.text)
                await cache_msg.delete()

            await state.update_data(here_position_description=message.text)

            await state.set_state("here_position_photo")
            await message.answer(_("<b>📁 Отправьте изображение для позиции 📸</b>\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))
        else:
            await message.answer(_("<b>❌ Описание не может превышать 600 символов.</b>\n"
                                 "📁 Введите новое описание для позиции 📜\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))
    except CantParseEntities:
        await message.answer(_("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📁 Введите описание для позиции 📜\n"
                             "❕ Вы можете использовать HTML разметку\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))


# Принятие изображения позиции для её создания
@dp.message_handler(IsAdmin(), content_types="photo", state="here_position_photo")
@dp.message_handler(IsAdmin(), text="0", state="here_position_photo")
async def product_position_create_photo(message: Message, state: FSMContext):
    print('Принятие изображения позиции  admin_products.py 418')
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    async with state.proxy() as data:
        position_user_id = message.from_user.id
        position_city = data['here_position_city']
        position_city_id = data['position_city_id']
        position_name = clear_html(data['here_position_name'])
        position_price = data['here_position_price']
        catategory_id = data['here_cache_change_category_id']
        position_description = data['here_position_description']
    await state.finish()

    position_photo = "" if "text" in message else message.photo[-1].file_id
    add_positionx(position_city, position_city_id, position_name, position_price, position_description, position_photo, catategory_id, position_user_id)

    await message.answer(_("<b>📁 Позиция была успешно создана ✅</b>", locale=lang))


################################################################################################
####################################### ИЗМЕНЕНИЕ ПОЗИЦИЙ #####################################
# Возвращение к начальным категориям для редактирования позиции
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_category_return", state="*")
async def product_position_edit_return(call: CallbackQuery, state: FSMContext):
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang), reply_markup=position_edit_category_open_fp(0, lang))


# Следующая страница категорий для редактирования позиции
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_category_nextp:", state="*")
async def product_position_edit_category_next(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang), reply_markup=position_edit_category_next_page_fp(remover, lang))


# Предыдущая страница категорий для редактирования позиции
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_category_backp:", state="*")
async def product_position_edit_category_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang), reply_markup=position_edit_category_back_page_fp(remover, lang))


# Выбор категории с нужной позицией
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_category:", state="*")
async def product_position_edit_category_open(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    if len(get_positionsx(category_id=category_id)) >= 1:
        await call.message.edit_text(_("<b>📁 Выберите нужную вам позицию 🖍</b>", locale=lang),
                                     reply_markup=position_edit_open_fp(0, category_id, lang))
    else:
        await call.answer(_("📁 Позиции в данной категории отсутствуют", locale=lang))


# Следующая страница позиций для их изменения
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_nextp:", state="*")
async def product_position_edit_next(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang), reply_markup=position_edit_next_page_fp(remover, category_id, lang))

# Предыдущая страница позиций для их изменения
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_backp:", state="*")
async def product_position_edit_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])

    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang), reply_markup=position_edit_back_page_fp(remover, category_id, lang))

# Выбор позиции для редактирования
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit:", state="*")
async def product_position_edit_open(call: CallbackQuery, state: FSMContext):
    print('Выбор позиции для редактирования api_sqlite.py 496')
    position_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    get_message, get_photo = get_position_admin(position_id)

    if get_photo is not None:
        await call.message.delete()
        await call.message.answer_photo(get_photo, get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
    else:
        await call.message.edit_text(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))


# Возвращение к выбору позиции для изменения
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_return", state="*")
async def product_position_edit_return(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    if len(get_positionsx(category_id=category_id)) >= 1:
        await call.message.delete()
        await call.message.answer(_("<b>📁 Выберите нужную вам позицию 🖍</b>", locale=lang), reply_markup=position_edit_open_fp(remover, category_id, lang))
    else:
        await call.answer(_("<b>❗ Позиции в данной категории отсутствуют</b>", locale=lang))


######################################## САМО ИЗМЕНЕНИЕ ПОЗИЦИИ ########################################
# Изменение имени позиции
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_name", state="*")
async def product_position_edit_name(call: CallbackQuery, state: FSMContext):
    print('Изменение имени позиции api_sqlite.py 529')
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_name")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Введите новое название для позиции 🏷</b>", locale=lang))


# Принятие имени позиции для её изменения
@dp.message_handler(IsAdmin(), state="here_change_position_name")
async def product_position_edit_name_get(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    if len(message.text) <= 100:
        async with state.proxy() as data:
            position_id = data['here_cache_category_id']
            category_id = data['here_cache_position_id']
            remover = data['here_cache_position_remover']
        await state.finish()

        update_positionx(position_id, position_name=clear_html(message.text))
        get_message, get_photo = get_position_admin(position_id)

        if get_photo is not None:
            await message.answer_photo(get_photo, get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
        else:
            await message.answer(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "📁 Введите новое название для позиции 🏷", locale=lang))


# Изменение цены позиции
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_price", state="*")
async def product_position_edit_price(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_price")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Введите новую цену для позиции 💰</b>", locale=lang))


# Принятие цены позиции для её изменения
@dp.message_handler(IsAdmin(), state="here_change_position_price")
async def product_position_edit_price_get(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    if message.text.isdigit():
        if 0 <= int(message.text) <= 10000000:
            async with state.proxy() as data:
                position_id = data['here_cache_category_id']
                category_id = data['here_cache_position_id']
                remover = data['here_cache_position_remover']
            await state.finish()

            update_positionx(position_id, position_price=message.text)
            get_message, get_photo = get_position_admin(position_id)

            if get_photo is not None:
                await message.answer_photo(get_photo, get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
            else:
                await message.answer(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
        else:
            await message.answer(_("<b>❌ Цена не может быть меньше 0 или больше 10 000 000.</b>\n"
                                 "📁 Введите цену для позиции 💰", locale=lang))
    else:
        await message.answer(_("<b>❌ Данные были введены неверно.</b>\n"
                             "📁 Введите цену для позиции 💰", locale=lang))


# Изменение описания позиции
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_description", state="*")
async def product_position_edit_description(call: CallbackQuery, state: FSMContext):
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_description")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Введите новое описание для позиции 📜</b>\n"
                              "❕ Вы можете использовать HTML разметку\n"
                              "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))


# Принятие описания позиции для её изменения
@dp.message_handler(IsAdmin(), state="here_change_position_description")
async def product_position_edit_description_get(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    async with state.proxy() as data:
        position_id = data['here_cache_category_id']
        category_id = data['here_cache_position_id']
        remover = data['here_cache_position_remover']

    try:
        if len(message.text) <= 600:
            await state.finish()

            if message.text != "0":
                cache_msg = await message.answer(message.text)
                await cache_msg.delete()

            update_positionx(position_id, position_description=message.text)
            get_message, get_photo = get_position_admin(position_id)

            if get_photo is not None:
                await message.answer_photo(get_photo, get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
            else:
                await message.answer(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
        else:
            await message.answer(_("<b>❌ Описание не может превышать 600 символов.</b>\n"
                                 "📁 Введите новое описание для позиции 📜\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))
    except CantParseEntities:
        await message.answer(_("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📁 Введите новое описание для позиции 📜\n"
                             "❕ Вы можете использовать HTML разметку\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))

# Изменение имени позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="position_edit_rest", state="*")
async def product_position_edit_name(call: CallbackQuery, state: FSMContext):
    print('Изменение имени позиции api_sqlite.py 529')
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_rest")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Введите новый остаток для позиции 🏷</b>", locale=lang))


# Принятие имени позиции для её изменения
@dp.message_handler(IsAdminorShopAdmin(), state="here_change_position_rest")
async def product_position_edit_rest_get(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    if len(message.text) <= 100:
        async with state.proxy() as data:
            position_id = data['here_cache_category_id']
            category_id = data['here_cache_position_id']
            remover = data['here_cache_position_remover']
        await state.finish()

        update_positionx(position_id, position_rest=clear_html(message.text))
        get_message, get_photo = get_position_admin(position_id)

        if get_photo is not None:
            await message.answer_photo(get_photo, get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
        else:
            await message.answer(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "📁 Введите новый остаток для позиции 🏷", locale=lang))



# Изменение изображения позиции
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_photo", state="*")
async def product_position_edit_photo(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_photo")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Отправьте новое изображение для позиции 📸</b>\n"
                              "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))


# Принятие нового фото для позиции
@dp.message_handler(IsAdmin(), content_types="photo", state="here_change_position_photo")
@dp.message_handler(IsAdmin(), text="0", state="here_change_position_photo")
async def product_position_edit_photo_get(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    async with state.proxy() as data:
        position_id = data['here_cache_category_id']
        category_id = data['here_cache_position_id']
        remover = data['here_cache_position_remover']
    await state.finish()

    position_photo = "" if "text" in message else message.photo[-1].file_id
    update_positionx(position_id, position_photo=position_photo)
    get_message, get_photo = get_position_admin(position_id)

    if get_photo is not None:
        await message.answer_photo(get_photo, get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
    else:
        await message.answer(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))


# ---------------------------  Добавлено 12.08.22 ------------------------------------------

# Изменение города продукта
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_city", state="*")
async def product_position_edit_description(call: CallbackQuery, state: FSMContext):
    print('Изменение города продукта  admin_products.py 715')
    print(call.data)
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    category_id = int(call.data.split(":")[2])
    position_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[3])

    current_city = get_city_user(call.from_user.id)[0]

    await state.set_state("here_change_city")
    await state.update_data({'position_id': position_id, 'category_id': category_id, 'remover': remover})
    await call.message.delete()
    if lang == "ru":
        await call.message.answer("<b>📁 Выберите другой город 🏙</b>\n"
                                  "❕ Вы можете использовать геолокацию или выбрать город из списка\n"
                                  f"❕ Город товара: <code>{current_city}</code>", reply_markup=geo_1_kb())
    if lang == "en":
        await call.message.answer("<b>📁 Choose different city 🏙</b>\n"
                                  "❕ You can use geolocation or select a city from the list\n"
                                  f"❕City of product: <code>{current_city}</code>", reply_markup=geo_1_kb())

# принятие новой геопозиции для позиции
@dp.callback_query_handler(text_startswith = 'geo_chosen_cities', state='here_change_city')
async def geo_5(cb: CallbackQuery, state: FSMContext):
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    info = int(str(cb.data).split('#')[1])
    if info == 0:
        async with state.proxy() as data:
            city = data['city']
            position_id = int(data['position_id'])
            category_id = data['category_id']
            remover = data['remover']
            city_id = data['city_id']

    else:
        async with state.proxy() as data:
            position_id = int(data['position_id'])
            category_id = data['category_id']
            remover = data['remover']

        city_id = info
        city = get_city_info(info)

    await state.finish()
    update_position_city(city[0], city_id, position_id)

    # update_positionx(position_id)
    get_message, get_photo = get_position_admin(position_id)

    if get_photo is not None:
        await cb.message.answer_photo(get_photo, get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
    else:
        await cb.message.answer(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))



# Выгрузка товаров
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_items", state="*")
async def product_position_edit_items(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    get_position = get_positionx(position_id=position_id)
    get_items = get_itemsx(position_id=position_id)
    if lang == "ru":
        save_items = ['АйдиТовара   -   Данные товара', "================================"]
    if lang == "en":
        save_items = ['IDProduct   -   Product Data', "================================"]

    if len(get_items) >= 1:
        save_items.extend(
            f"{item['item_id']} - {item['item_data']}" for item in get_items
        )
        save_items = "\n".join(save_items)

        save_items = await upload_text(call, save_items)
        if lang == "ru":
            await call.message.answer(f"<b>📥 Все товары позиции: <code>{get_position['position_name']}</code>\n"
                                  f"🔗 Ссылка: <a href='{save_items}'>кликабельно</a></b>",
                                  reply_markup=close_inl)
        if lang == "en":
            await call.message.answer(f"<b>📥 All position items: <code>{get_position['position_name']}</code>\n"
                                  f"🔗 Link: <a href='{save_items}'>Clickable</a></b>",
                                  reply_markup=close_inl)

        await call.answer()
    else:
        if lang == "ru":
            await call.answer("❕ В данной позиции отсутствуют товары", True)
        if lang == "en":
            await call.answer("❕ This position has no items", True)


# Удаление позиции
@dp.callback_query_handler(text_startswith="position_edit_delete", state="*")
async def product_position_edit_delete(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    if user_role == "Admin":
        await call.message.delete()
        await call.message.answer(_("<b>📁 Вы действительно хотите удалить позицию? ❌</b>", locale=lang), reply_markup=position_edit_delete_finl(position_id, category_id, remover, lang))


# Подтверждение удаления позиции
@dp.callback_query_handler(text_startswith="position_delete", state="*")
async def product_position_edit_delete_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])
    remover = int(call.data.split(":")[4])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    if user_role == "Admin":
        if get_action == "yes":
            remove_itemx(position_id=position_id)
            remove_positionx(position_id=position_id)

            await call.answer(_("📁 Вы успешно удалили позицию и её товары ✅", locale=lang))

            if len(get_positionsx(category_id=category_id)) >= 1:
                await call.message.edit_text(_("<b>📁 Выберите нужную вам позицию 🖍</b>", locale=lang), reply_markup=position_edit_open_fp(remover, category_id, lang))
            else:
                await call.message.delete()
        else:
            get_message, get_photo = get_position_admin(position_id)

            if get_photo is not None:
                await call.message.delete()
                await call.message.answer_photo(get_photo, get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
            else:
                await call.message.edit_text(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))


# Очистка позиции
@dp.callback_query_handler(IsAdmin(), text_startswith="position_edit_clear", state="*")
async def product_position_edit_clear(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.delete()
    await call.message.answer(_("<b>📁 Вы хотите удалить все товары позиции?</b>", locale=lang), reply_markup=position_edit_clear_finl(position_id, category_id, remover, lang))


# Согласие очистики позиции
@dp.callback_query_handler(IsAdmin(), text_startswith="position_clear", state="*")
async def product_position_edit_clear_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])
    remover = int(call.data.split(":")[4])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    if get_action == "yes":
        remove_itemx(position_id=position_id)
        await call.answer(_("📁 Вы успешно удалили все товары позиции ✅", locale=lang))

    get_message, get_photo = get_position_admin(position_id)

    if get_photo is not None:
        await call.message.delete()
        await call.message.answer_photo(get_photo, get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
    else:
        await call.message.edit_text(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))


################################################################################################
###################################### УДАЛЕНИЕ ВСЕХ ПОЗИЦИЙ ###################################
# Согласие на удаление всех позиций и товаров
@dp.callback_query_handler(IsAdmin(), text_startswith="confirm_remove_position:", state="*")
async def product_position_remove(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    if get_action == "yes":
        get_positions = len(get_all_positionsx())
        get_items = len(get_all_itemsx())

        clear_positionx()
        clear_itemx()

        if lang == "ru":
            await call.message.edit_text(f"<b>📁 Вы удалили все позиции<code>({get_positions}шт)</code> и товары<code>({get_items}шт)</code> ☑</b>")
        if lang == "en":
            await call.message.edit_text(f"<b>📁 You delete all position <code>({get_positions}шт)</code> anf positions<code>({get_items}pcs)</code> ☑</b>")
    else:
        await call.message.edit_text(_("<b>📁 Вы отменили удаление всех позиций ✅</b>", locale=lang))


################################################################################################
####################################### ДОБАВЛЕНИЕ ТОВАРОВ #####################################
# Возвращение к начальным категориям для добавления товаров
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="back_add_products_to_category", state="*")
async def product_item_create(call: CallbackQuery, state: FSMContext):
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    await call.message.edit_text(_("<b>🎁 Выберите категорию с нужной позицией</b>", locale=lang), reply_markup=products_add_category_open_fp(0, lang))

# Следующая страница выбора категории с позицией для добавления товаров
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="products_add_category_nextp", state="*")
async def product_item_load_category_next(call: CallbackQuery, state: FSMContext):
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    remover = int(call.data.split(":")[1])

    await call.message.delete()
    await call.message.answer(_("<b>🎁 Выберите категорию с нужной позицией</b>", locale=lang), reply_markup=products_add_category_next_page_fp(remover, lang))


# Предыдущая страница выбора категории с позицией для добавления товаров
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="products_add_category_backp", state="*")
async def product_item_load_category_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.delete()
    await call.message.answer(_("<b>🎁 Выберите категорию с нужной позицией</b>", locale=lang), reply_markup=products_add_category_back_page_fp(remover, lang))


# Выбор категории с нужной позицией
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="products_add_category", state="*")
async def product_item_load_category_open(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    if len(get_positionsx(category_id=category_id)) >= 1:
        await call.message.delete()
        await call.message.answer(_("<b>🎁 Выберите нужную вам позицию</b>", locale=lang), reply_markup=products_add_position_open_fp(0, category_id, lang))
    else:
        await call.answer(_("🎁 Позиции в данной категории отсутствуют", locale=lang))


# Следующая страница позиций для добавления товаров
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="products_add_position_nextp", state="*")
async def product_item_load_next(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.edit_text(_("<b>🎁 Выберите нужную вам позицию</b>", locale=lang), reply_markup=products_add_position_next_page_fp(remover, category_id, lang))


# Предыдущая страница позиций для добавления товаров
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="products_add_position_backp", state="*")
async def product_item_load_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.edit_text(_("<b>🎁 Выберите нужную вам позицию</b>", locale=lang), reply_markup=products_add_position_back_page_fp(remover, category_id, lang))


# Выбор позиции для добавления товаров
@rate_limit(0)
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="products_add_position:", state="*")
async def product_item_load_open(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await state.update_data(here_cache_add_item_category_id=category_id)
    await state.update_data(here_cache_add_item_position_id=position_id)
    await state.update_data(here_count_add_items=0)

    await state.set_state("here_add_items")
    await call.message.delete()
    await call.message.answer(_("<b>📤 Отправьте данные товаров.</b>\n"
                              "❗ Товары разделяются одной пустой строчкой. Пример:\n"
                              "<code>Данные товара...\n\n"
                              "Данные товара...\n\n"
                              "Данные товара...</code>", locale=lang), reply_markup=finish_load_rep)


# Завершение загрузки товаров
@rate_limit(0)
@dp.message_handler(IsAdminorShopAdmin(), text="📥 Закончить загрузку товаров", state="*")
async def product_item_load_finish(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    get_all_items = 0
    try:
        async with state.proxy() as data:
            get_all_items = data['here_count_add_items']
    except Exception:
        pass

    await state.finish()
    user_id = message.from_user.id
    ur = get_userx(user_id=user_id)['user_role']
    if ur == 'Admin':
        if lang == "ru":
            await message.answer("<b>📥 Загрузка товаров была успешно завершена ✅\n"
                                 f"▶ Загружено товаров: <code>{get_all_items}шт</code></b>", reply_markup=items_frep(lang))
        if lang == "en":
            await message.answer("<b>📥 Loading of items has been finished succesfully ✅\n"
                                 f"▶ Items Uploaded: <code>{get_all_items}шт</code></b>", reply_markup=items_frep(lang))
    if ur == 'ShopAdmin':
        if lang == "ru":
            await message.answer("<b>📥 Загрузка товаров была успешно завершена ✅\n"
                                 f"▶ Загружено товаров: <code>{get_all_items}шт</code></b>", reply_markup=items_sh_frep(lang))
        if lang == "en":
            await message.answer("<b>📥 Loading of items has been finished succesfully ✅\n"
                                 f"▶ Items Uploaded: <code>{get_all_items}шт</code></b>", reply_markup=items_sh_frep(lang))


# Принятие данных товара
@rate_limit(0)
@dp.message_handler(IsAdminorShopAdmin(), state="here_add_items")
async def product_item_load_get(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    cache_msg = await message.answer(_("<b>⌛ Ждите, товары добавляются...</b>", locale=lang))

    count_add = get_all_items = 0
    get_all_items = clear_list(message.text.split("\n\n"))

    for check_item in get_all_items:
        if not check_item.isspace() and check_item != "":
            count_add += 1

    async with state.proxy() as data:
        category_id = data['here_cache_add_item_category_id']
        position_id = data['here_cache_add_item_position_id']
        data['here_count_add_items'] += count_add

    get_user = get_userx(user_id=message.from_user.id)
    add_itemx(category_id, position_id, get_all_items, get_user['user_id'], get_user['user_name'])
    if lang == "ru":
        await cache_msg.edit_text(f"<b>📥 Товары в кол-ве</b> <u>{count_add}шт</u> <b>были успешно добавлены ✅</b>")
    if lang == "en":
        await cache_msg.edit_text(f"<b>📥 Items quantity</b> <u>{count_add}шт</u> <b>has been add succesfully ✅</b>")



################################################################################################
####################################### УДАЛЕНИЕ ТОВАРОВ ######################################
# Принятие айди товаров для их удаления
@dp.message_handler(IsAdmin(), state="here_items_delete")
async def product_item_delete_get(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    await state.finish()

    remove_ids, cancel_ids = [], []  # Айди удалённых и ненайденных товаров
    get_item_ids_one, get_item_ids_two = [], [[]]
    save_ids = []

    if "," in message.text:
        get_item_ids_one = clear_list(message.text.split(","))
    else:
        get_item_ids_one = clear_list([message.text])

    get_item_ids_two.extend(
        item.split(" ") for item in get_item_ids_one if " " in item
    )
    if len(get_item_ids_two) == 1:
        get_item_ids_two.append(get_item_ids_one)

    for check_item in get_item_ids_two:
        save_ids.extend(iter(clear_list(check_item)))
    save_ids = clear_list(save_ids)

    for item_id in save_ids:
        check_item = get_itemx(item_id=item_id)
        if check_item is not None:
            remove_itemx(item_id=item_id)
            remove_ids.append(item_id)
        else:
            cancel_ids.append(item_id)

    remove_ids = ", ".join(remove_ids)
    cancel_ids = ", ".join(cancel_ids)

    if lang == "ru":
        await message.answer(f"<b>✅ Успешно удалённые товары:\n"
                             f"▶ <code>{remove_ids}</code>\n"
                             f"➖➖➖➖➖➖➖➖➖➖\n"
                             f"❌ Ненайденные товары:\n"
                             f"▶ <code>{cancel_ids}</code></b>")
    if lang == "en":
        await message.answer(f"<b>✅ Successfully deleted items:\n"
                         f"▶ <code>{remove_ids}</code>\n"
                         f"➖➖➖➖➖➖➖➖➖➖\n"
                         f"❌ Undiscovered goods:\n"
                         f"▶ <code>{cancel_ids}</code></b>")


################################################################################################
##################################### УДАЛЕНИЕ ВСЕХ ТОВАРОВ ####################################
# Согласие на удаление всех товаров
@dp.callback_query_handler(IsAdmin(), text_startswith="confirm_remove_item:", state="*")
async def product_item_remove(call: CallbackQuery, state: FSMContext):
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    get_action = call.data.split(":")[1]

    if get_action == "yes":
        get_items = len(get_all_itemsx())
        clear_itemx()
        if lang == "ru":
            await call.message.edit_text(f"<b>🎁 Вы удалили все товары<code>({get_items}шт)</code> ☑</b>")
        if lang == "en":
            await call.message.edit_text(f"<b>🎁 You have deleted all the products<code>({get_items}pcs)</code> ☑</b>")
    else:
            await call.message.edit_text(_("<b>🎁 Вы отменили удаление всех товаров ✅</b>", locale=lang))

tgbot >handlers>admin_settings.py:
# - *- coding: utf- 8 - *-
import gettext
from pathlib import Path
from contextvars import ContextVar

from aiogram.dispatcher import FSMContext
from aiogram.types import CallbackQuery, Message
from aiogram.utils.exceptions import CantParseEntities

from tgbot.keyboards.inline_admin import turn_open_finl, settings_open_finl
from tgbot.loader import dp
from tgbot.services.api_sqlite import *
from tgbot.utils.misc.bot_filters import IsAdmin
from tgbot.utils.misc_functions import send_admins, get_faq
from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR
#from tgbot.middlewares.i18n import I18nMiddleware
#from aiogram.contrib.middlewares.i18n import I18nMiddleware
from tgbot.middlewares.i18n import I18nMiddleware

i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)

print(i18n)
_ = i18n.gettext
print(i18n.find_locales())

# Изменение данных
@dp.message_handler(text=["🖍 Изменить данные", "🖍 Edit settings"], state="*")
async def settings_data_edit(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']

    if user_role == "Admin":
        await state.finish()
        await message.answer(_("<b>🖍 Изменение настроек бота.</b>", locale=lang), reply_markup=settings_open_finl(lang))

# Выключатели бота
@dp.message_handler(text=["🕹 Выключатели", "🕹 Switches"],  state="*")
async def settings_turn_edit(message: Message, state: FSMContext):
    user_role = get_userx(user_id=message.from_user.id)['user_role']
    lang = get_userx(user_id=message.from_user.id)['user_lang']
    print("::|::")
    if user_role == "Admin":
        await state.finish()
        await message.answer(_("<b>🕹 Включение и выключение основных функций</b>", locale=lang), reply_markup=turn_open_finl(lang))

######################################## ВЫКЛЮЧАТЕЛИ ########################################
# Включение/выключение тех работ
@dp.callback_query_handler(IsAdmin(), text_startswith="turn_twork", state="*")
async def settings_turn_twork(call: CallbackQuery, state: FSMContext):
    get_status = call.data.split(":")[1]

    get_user = get_userx(user_id=call.from_user.id)
    lang = get_user['user_lang']
    update_settingsx(status_work=get_status)

    if get_status == "True":
        send_text = "🔴 Отправил бота на технические работы."
    else:
        send_text = "🟢 Вывел бота из технических работ."

    await send_admins(
        f"👤 Администратор <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a>\n"
        f"{send_text}", not_me=get_user['user_id'])

    await call.message.edit_reply_markup(reply_markup=turn_open_finl(lang))


# Включение/выключение покупок
@dp.callback_query_handler(IsAdmin(), text_startswith="turn_buy", state="*")
async def settings_turn_buy(call: CallbackQuery, state: FSMContext):
    get_status = call.data.split(":")[1]

    get_user = get_userx(user_id=call.from_user.id)
    lang = get_user['user_lang']
    update_settingsx(status_buy=get_status)

    if get_status == "True":
        send_text = "🟢 Включил покупки в боте."
    else:
        send_text = "🔴 Выключил покупки в боте."

    await send_admins(
        f"👤 Администратор <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a>\n"
        f"{send_text}", not_me=get_user['user_id'])

    await call.message.edit_reply_markup(reply_markup=turn_open_finl(lang))


# Включение/выключение пополнений
@dp.callback_query_handler(IsAdmin(), text_startswith="turn_pay", state="*")
async def settings_turn_pay(call: CallbackQuery, state: FSMContext):
    get_status = call.data.split(":")[1]

    get_user = get_userx(user_id=call.from_user.id)
    lang = get_user['user_lang']
    update_settingsx(status_refill=get_status)

    if get_status == "True":
        send_text = "🟢 Включил пополнения в боте."
    else:
        send_text = "🔴 Выключил пополнения в боте."

    await send_admins(
        f"👤 Администратор <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a>\n"
        f"{send_text}", not_me=get_user['user_id'])

    await call.message.edit_reply_markup(reply_markup=turn_open_finl(lang))


######################################## ИЗМЕНЕНИЕ ДАННЫХ ########################################
# Изменение поддержки
@dp.callback_query_handler(text_startswith="settings_edit_support", state="*")
async def settings_support_edit(call: CallbackQuery, state: FSMContext):
    await state.set_state("here_settings_support")
    lang = get_userx(user_id=call.from_user.id)['user_lang']
    user_role = get_userx(user_id=call.from_user.id)['user_role']
    if user_role == "Admin":
        await call.message.edit_text(_("<b>☎ Отправьте ID пользователя.</b>"
                                     "❕ Вводимый ID должен быть пользователем бота.", locale=lang))

# Изменение типа площадки
@dp.callback_query_handler(text_startswith="settings_edit_type_trade", state="*")
async def settings_type_trade_edit(call: CallbackQuery, state: FSMContext):
    await state.set_state("here_settings_trade_type")
    lang = get_userx(user_id=call.from_user.id)['user_lang']
    user_role = get_userx(user_id=call.from_user.id)['user_role']
    print(lang, user_role)
    if user_role == "Admin":
        await call.message.edit_text(_("<b>ℹ Выберите тип площадки: real | digital | hybrid</b>", locale=lang))

# Изменение FAQ
@dp.callback_query_handler(text_startswith="settings_edit_faq", state="*")
async def settings_faq_edit(call: CallbackQuery, state: FSMContext):
    await state.set_state("here_settings_faq")
    lang = get_userx(user_id=call.from_user.id)['user_lang']
    user_role = get_userx(user_id=call.from_user.id)['user_role']
    if user_role == "Admin":
        await call.message.edit_text(_("<b>ℹ Введите новый текст для FAQ</b>"
                                     "❕ Вы можете использовать заготовленный синтаксис и HTML разметку:\n"
                                     "<code>▶ {username}</code>  - логин пользоваля\n"
                                     "<code>▶ {user_id}</code>   - айди пользователя\n"
                                     "<code>▶ {firstname}</code> - имя пользователя", locale=lang))

# Принятие нового типа площадки
@dp.message_handler(state="here_settings_trade_type")
async def settings_tt_edit(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang, user_role = get_userx(user_id=user_id)['user_lang'], get_userx(user_id=user_id)['user_role']

    if user_role == "Admin":
        try:
            await state.finish()
            update_settingsx(type_trade=message.text)

            await message.answer("<b>🖍 Изменение настроек бота.</b>", reply_markup=settings_open_finl(lang))
        except CantParseEntities:
            await message.answer(_("<b>❌ Ошибка синтаксиса HTML.</b>"
                                 "ℹ Введите новый тип real | digital | hybrid.", locale=lang))


# Принятие нового текста для FAQ
@dp.message_handler(state="here_settings_faq")
async def settings_faq_get(message: Message, state: FSMContext):
    user_id = message.from_user.id
    get_message = get_faq(user_id, message.text)
    lang, user_role = get_userx(user_id=user_id)['user_lang'], get_userx(user_id=user_id)['user_role']
    if user_role == "Admin":
        try:
            cache_msg = await message.answer(get_message)
            await state.finish()
            update_settingsx(misc_faq=message.text)

            await cache_msg.edit_text("<b>ℹ FAQ было успешно обновлено ✅</b>")
            await message.answer(_("<b>🖍 Изменение настроек бота.</b>", locale=lang), reply_markup=settings_open_finl(lang))
        except CantParseEntities:
            await message.answer(_("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                                 "ℹ Введите новый текст для FAQ", locale=lang))


# Принятие нового айди для поддержки
@dp.message_handler(state="here_settings_support")
async def settings_support_get(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang, user_role = get_userx(user_id=user_id)['user_lang'], get_userx(user_id=user_id)['user_role']
    print(message.text)
    if user_role == "Admin":
        if message.text.isdigit():
            get_user = get_userx(user_id=message.text)
            print(get_user)

            if get_user is None:
                await message.answer(_("<b>❌ Пользователь не был найден.</b>\n"
                                     "☎ Отправьте ID пользователя.", locale=lang))
            elif len(get_user['user_login']) >= 1:
                await state.finish()
                update_settingsx(misc_support=get_user['user_id'])

                await message.answer(_("<b>☎ Поддержка была успешно обновлена ✅</b>", locale=lang))
                await message.answer(_("<b>🖍 Изменение настроек бота.</b>", locale=lang), reply_markup=settings_open_finl(lang))
            else:
                await message.answer(_("<b>❌ У пользоваля отсутствует юзернейм.</b>"
                                     "☎ Отправьте ID пользователя.", locale=lang))
        else:
            await message.answer(_("<b>❌ Данные были введены неверно.</b>"
                                 "☎ Отправьте ID пользователя.", locale=lang))



tgbot >handlers>main_start.py:
# - *- coding: utf- 8 - *-
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher import filters
from aiogram.types import Message, User, CallbackQuery
from aiogram.utils.deep_linking import get_start_link, decode_payload

import gettext
from pathlib import Path
from contextvars import ContextVar
from tgbot.data.config import I18N_DOMAIN, LOCALES_DIR, DEFAULT_LANGUAGE

from tgbot.keyboards.inline_user import user_support_finl, open_deep_link_object_finl, lang_menu_finl, lang_menu_ext_finl
from tgbot.keyboards.reply_z_all import menu_frep
from aiogram import Dispatcher
from tgbot.loader import dp
from tgbot.services.api_sqlite import get_settingsx, get_userx, get_positionx, update_userx, get_user_lang
from tgbot.utils.misc.bot_filters import IsBuy, IsRefill, IsWork
from tgbot.utils.misc_functions import get_position_of_day
from tgbot.services.location_function import is_location, add_city
from tgbot.services.lang_function import is_lang
from tgbot.services.location_stat import geo_choice
from tgbot.keyboards.location_keyboards import geo_11_kb
from babel import Locale
from tgbot.middlewares.i18n import I18nMiddleware

i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
print(i18n)
_ = i18n.gettext

# Игнор-колбэки покупок
prohibit_buy = ['buy_category_open', 'buy_category_return', 'buy_category_nextp', 'buy_category_backp',
                'buy_shop_open', 'buy_shop_return', 'buy_shop_nextp', 'buy_shop_backp',
                'buy_position_open', 'buy_position_open', 'buy_position_return', 'buy_position_nextp', 'buy_position_backp',
                'buy_purchase_select', 'here_purchase_count', 'xpurchase_item', 'add_item_cart', 'user_cart',
                'enter_address_manualy', 'enter_address_manualy_fin', 'checkout_finally',
                'here_itemsadd_cart', 'xaddcart_item', 'geo_first_letter', 'cart_checkout_start',
                'enter_message_manualy', 'conf_order_addr_saved']
# Игнор-колбэки пополнений
prohibit_refill = ['user_refill', 'refill_choice', 'Pay:', 'Pay:Form', 'Pay:ForYm', 'Pay:Number', 'Pay:Nickname']


####################################################################################################
######################################## ТЕХНИЧЕСКИЕ РАБОТЫ ########################################
# Фильтр на технические работы - сообщение
@dp.message_handler(IsWork(), state="*")
async def filter_work_message(message: Message, state: FSMContext):
    await state.finish()

    user_support = get_settingsx()['misc_support']
    if str(user_support).isdigit():
        get_user = get_userx(user_id=user_support)

        if len(get_user['user_login']) >= 1:
            await message.answer(_("<b>⛔ Бот находится на технических работах.</b>", locale=lang),
                                 reply_markup=user_support_finl(get_user['user_login']))
            return

    await message.answer(_("<b>⛔ Бот находится на технических работах.</b>", locale=lang))


# Фильтр на технические работы - колбэк
@dp.callback_query_handler(IsWork(), state="*")
async def filter_work_callback(call: CallbackQuery, state: FSMContext):
    await state.finish()

    await call.answer(_("⛔ Бот находится на технических работах.", locale=lang), True)

####################################################################################################
########################################### СТАТУС ПОКУПОК #########################################
# Фильтр на доступность покупок - сообщение
@dp.message_handler(IsBuy(), text="🎁 Купить", state="*")
@dp.message_handler(IsBuy(), state="here_purchase_count")
async def filter_buy_message(message: Message, state: FSMContext):
    await state.finish()

    await message.answer(_("<b>⛔ Покупки временно отключены.</b>", locale=lang))

# Фильтр на доступность покупок - колбэк
@dp.callback_query_handler(IsBuy(), text_startswith=prohibit_buy, state="*")
async def filter_buy_callback(call: CallbackQuery, state: FSMContext):
    await state.finish()

    await call.answer(_("⛔ Покупки временно отключены.", locale=lang), True)


####################################################################################################
######################################### СТАТУС ПОПОЛНЕНИЙ ########################################
# Фильтр на доступность пополнения - сообщение
@dp.message_handler(IsRefill(), state="here_pay_amount")
async def filter_refill_message(message: Message, state: FSMContext):
    await state.finish()

    await message.answer(_("<b>⛔ Пополнение временно отключено.</b>", locale=lang))


# Фильтр на доступность пополнения - колбэк
@dp.callback_query_handler(IsRefill(), text_startswith=prohibit_refill, state="*")
async def filter_refill_callback(call: CallbackQuery, state: FSMContext):
    await state.finish()

    await call.answer(_("⛔ Пополнение временно отключено.", locale=lang), True)


####################################################################################################
############################################## ПРОЧЕЕ ##############################################
# В случае - если посетитель идет по deeplink'у или просто стартует
@dp.message_handler(filters.CommandStart())
@dp.message_handler(text=['⬅ Main Menu', '⬅ Главное меню', '/start', '⬆️ Выбрать город позже', 'start'], state="*")
async def main_start(message: Message, state: FSMContext):
    print(message.text)
    if args := message.get_args():
        payload = decode_payload(args)
        list = payload.split("&")
        print(list)
        category_id = 0
        object_id = 0
        print(list[0])
        object_id = list[2]
        position = get_positionx(position_id=object_id)
        user = get_userx(user_id=message.from_user.id)
        print(position)
        print(user)
        remover= 0
        city_id = 34
        category_id = position['category_id']
        await message.answer("🔸 Открываем объект по внешней ссылке.\n"
                             "▶ Добро пожаловать в TelegramGoodsinbot!",
                             reply_markup=open_deep_link_object_finl(object_id, category_id, remover, city_id))

    get_settings = get_settingsx()
    type_trade = get_settings['type_trade']

    if is_lang(message.from_user.id) == False:
        lang = DEFAULT_LANGUAGE
        await message.answer("Выберите язык", reply_markup=lang_menu_finl(lang))
    else:
        lang = get_userx(user_id=message.from_user.id)['user_lang']
        await message.answer(f"Ваш язык: {lang}", reply_markup=menu_frep(message.from_user.id, lang)) #lang_menu_finl()

    if type_trade in ['hybrid', 'real']:
        print("loco is not present")
        print("hybrid|real")
        if message.text == '⬆️ Выбрать город позже':
            add_city(1, "Москва", message.from_user.id)
            await message.answer("🔸 Город не определен. Вам показываются позиции в городе Москва.\n"
                                 "🔸 Бот готов к использованию.\n"
                                 "🔸 Если не появились вспомогательные кнопки.\n"
                                 "▶ Введите /start",
                                 reply_markup=menu_frep(message.from_user.id, lang))

        elif is_location(message.from_user.id) == True:
            print("loco is present")
            await message.answer(f"🔸 Город определен. Бот готов к использованию.\n"
                                 "🔸 Выберите один из разделов[Купить, Продать, Магазины, Афиша].\n"
                                 "🔸 Если не появились вспомогательные кнопки.\n"
                                 "▶ Введите /start",
                                 reply_markup=menu_frep(message.from_user.id, lang))
        else:
            await geo_choice.location.set()
            await message.answer('Отправьте локацию или выберите город из списка', reply_markup=geo_11_kb())

    elif type_trade == 'digital':
        await message.answer("🔸 Режим Digital. Бот готов к использованию.\n"
                             "🔸 Если не появились вспомогательные кнопки.\n"
                             "▶ Введите /start",
                             reply_markup=menu_frep(message.from_user.id, lang))

@dp.message_handler(commands='lang')
async def cmd_lang(message: Message):
    lang = get_userx(user_id=message.from_user.id)['user_lang']
    await message.answer("Выберите язык: ", reply_markup=lang_menu_finl(lang))

@dp.message_handler(commands='edit_location')
async def cmd_location(message: Message):
    await geo_choice.location.set()
    #lang = get_userx(user_id=message.from_user.id)['user_lang']
    await message.answer("Выберите Ваш город: ", reply_markup=geo_11_kb())

@dp.callback_query_handler(text_startswith="lang", state="*")
async def language_was_selected(call: CallbackQuery, state: FSMContext):
    lang = call.data.split(":")[1]
    if lang in ('ru', 'en'):
        if lang == 'ru':
            locale = Locale('ru', 'RU')
            yourl = "Ваш язык "
        if lang == 'en':
            locale = Locale('en', 'US')
            yourl = "Your Language "

        print(call.from_user.id, lang)
        update_userx(call.from_user.id, user_lang = lang)

        state = Dispatcher.get_current().current_state()
        await state.update_data(locale=locale)

        print(locale.language, locale.language_name)
        lang = get_userx(user_id=call.from_user.id)['user_lang']

        await call.answer(f"{lang}")
        await call.message.answer(f"{yourl} : {lang}", reply_markup=menu_frep(call.from_user.id, lang))
    else: print("Такого языка нет.-*")


tgbot >handlers>user_location.py:
from aiogram import types
from aiogram.dispatcher import Dispatcher, FSMContext

from tgbot.loader import dp

from tgbot.data.config import DEFAULT_LANGUAGE
from tgbot.services.location_stat import geo_choice
from tgbot.keyboards.location_keyboards import *
from tgbot.services.location_function import search_address, add_address, search_city, add_geocode, add_city, get_city, update_position_city
from tgbot.services.api_sqlite import get_userx
from tgbot.keyboards.reply_z_all import menu_frep


@dp.callback_query_handler(text="edit_location", state='*')
async def geo_1(call: types.CallbackQuery, state: FSMContext):
    await state.finish()
    await geo_choice.location.set()
    await call.message.answer('Отправьте локацию или выберите город из списка', reply_markup=geo_11_kb())

# приём локации
@dp.message_handler(content_types=['location'], state=geo_choice.location)
async def geo_2(message: types.Message, state: FSMContext):
    await message.delete()
    lat = message.location.latitude
    long = message.location.longitude
    city = 0
    city = search_city(lat, long)
    lang = get_userx(user_id=message.from_user.id)['user_lang']

    print(lang, city)
    address = search_address(lat, long)
    add_geocode(lat, long, message.from_user.id)
    add_address(address, message.from_user.id)
    print("geo_choice:")

    if city == False:
        await message.answer('Ваш город не определён. Выберите город из списка', reply_markup=geo_3_kb())
    else:
        await message.answer(f'Ваш город: {city[0]}?', reply_markup=geo_2_kb(city[1], city[0]))


@dp.message_handler(text = "📋 Выбрать город из списка", state="*") #geo_choice.location
async def geo_3(message: types.Message, state: FSMContext):
    await message.answer('Первая буква названия вашего города', reply_markup=geo_3_kb())


@dp.callback_query_handler(text_startswith = "geo_first_letter", state="*") #geo_choice.location
async def geo_4(call: types.CallbackQuery):
    city_letter = str(call.data).split(':')[1]
    await call.message.edit_text('Выберите город', reply_markup=geo_4_kb(city_letter))


@dp.callback_query_handler(text_startswith = "geo_chosen_cities", state="*") #geo_choice.location
async def geo_5(call: types.CallbackQuery, state: FSMContext):
    await state.finish()
    city_id = int(call.data.split(":")[1])
    city_name = call.data.split(":")[2]
    lang = DEFAULT_LANGUAGE
    print("IIII")

    user_id = call.from_user.id
    print(city_id, lang, user_id)
    add_city(city_id, city_name, user_id)
    await call.message.answer(f"🔸 Выбран город: {city_name}.\n"
                              "🔸 Бот готов к использованию.\n"
                              "🔸 Если не появились вспомогательные кнопки\n"
                              "Наберите /start",
                              reply_markup=menu_frep(user_id, lang))

# ==============================================================================================================
# ================================  Локация для позицци (для магазина в будующем)   =============================

# приём локации
@dp.message_handler(content_types=['location'], state='here_change_city')
async def geo_position_1(message: types.Message, state: FSMContext):
    await message.delete()
    lat = message.location.latitude
    long = message.location.longitude
    city = 0
    city = search_city(lat, long)
    #lang = get_userx(user_id=message.from_user.id)['user_lang']
    lang = DEFAULT_LANGUAGE
    print(lang, city)

    if city == False:
        await message.answer('Город не определён. Выберите город из списка', reply_markup=geo_3_kb())
    else:
        await state.update_data({'city': city[0], 'city_id': city[1]})
        await message.answer(f'Ваш город: {city[0]}?', reply_markup=geo_2_kb(city[1], city[0]))

# выбор буквы города при нажатии кнопки
@dp.message_handler(text = "📋 Выбрать из списка", state='here_change_city')
async def geo_3(message: types.Message, state: FSMContext):
    #lang = get_userx(user_id=message.from_user.id)['user_lang']
    #lang = DEFAULT_LANGUAGE
    await message.answer('Первая буква названия вашего города', reply_markup=geo_3_kb())


# выбор буквы города при ошибке геокода
@dp.callback_query_handler(text_startswith='choice_city_list', state='here_change_city')
async def geo_position_2(call: types.CallbackQuery, state: FSMContext):
    #lang = get_userx(user_id=call.from_user.id)['user_lang']
    #lang = DEFAULT_LANGUAGE
    await call.message.answer('Первая буква названия вашего города', reply_markup=geo_3_kb())


# выбор города по букве
@dp.callback_query_handler(text_startswith='geo_first_letter', state='here_change_city')
async def geo_4(call: types.CallbackQuery):
    letter = str(call.data).split(':')[1]
    print(letter)
    await call.message.edit_text('Выберите город', reply_markup=geo_4_kb(letter))

# приём локации
@dp.message_handler(content_types=['location'], state='here_change_city_artist')
async def geo_position_1(message: types.Message, state: FSMContext):
    await message.delete()
    lat = message.location.latitude
    long = message.location.longitude
    city = 0
    city = search_city(lat, long)
    lang = get_userx(user_id=message.from_user.id)['user_lang']
    if city == False:
        await message.answer('Город не определён. Выберите город из списка', reply_markup=geo_3_kb(lang))
    else:
        await state.update_data({'city': city[0], 'city_id': city[1]})
        await message.answer(f'Ваш город: {city[0]}?', reply_markup=geo_2_kb(city[1]))

# выбор буквы города при нажатии кнопки
@dp.message_handler(text = "📋 Выбрать из списка", state='here_change_city_artist')
async def geo_3(message: types.Message, state: FSMContext):
    #lang = get_userx(user_id=message.from_user.id)['user_lang']
    await message.answer('Первая буква названия вашего города', reply_markup=geo_3_kb())

# выбор буквы города при ошибке геокода
@dp.callback_query_handler(text_startswith='choice_city_list', state='here_change_city_artist')
async def geo_position_2(call: types.CallbackQuery, state: FSMContext):
    lang = get_userx(user_id=message.from_user.id)['user_lang']
    await call.message.answer('Первая буква названия вашего города', reply_markup=geo_3_kb())

# выбор города по букве
@dp.callback_query_handler(text_startswith='geo_first_letter', state='here_change_city_artist')
async def geo_4(call: types.CallbackQuery):
    info = str(call.data).split(':')[1]
    await call.message.edit_text('Выберите город', reply_markup=geo_4_kb(info))

tgbot >handlers>user_menu copy.py:
# - *- coding: utf- 8 - *-
import asyncio
import json
from aiogram.dispatcher import FSMContext
#from aiogram import Bot
from aiogram import Dispatcher

from aiogram.types import CallbackQuery, Message, KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove

from tgbot.data.config import BOT_DESCRIPTION
from tgbot.keyboards.inline_admin import category_edit_open_finl, position_edit_open_finl, category_edit_delete_finl, \
    position_edit_clear_finl, position_edit_delete_finl, payment_choice_finl
from tgbot.keyboards.inline_user import user_support_finl, products_open_finl, products_confirm_finl, \
    products_addcart_confirm_finl, payment_as_choice_finl, accept_saved_adr, accept_saved_phone, \
    cart_enter_message_finl, give_number_inl, reply_order_message_finl, refill_choice_finl, charge_button_add, products_open_cart_finl, switch_category_shop_finl
from tgbot.keyboards.inline_z_all import category_remove_confirm_inl, position_remove_confirm_inl, \
    item_remove_confirm_inl, close_inl, confirm_delete_user_cart_inl
from tgbot.keyboards.inline_z_all import refill_open_inl, profile_open_inl, cart_open_created_inl, cart_open_delivery_inl, checkout_step2_accept, order_user_refill
from tgbot.keyboards.inline_z_page import *
from tgbot.keyboards.reply_z_all import finish_load_rep
from tgbot.keyboards.reply_z_all import menu_frep, items_sh_frep
from tgbot.loader import dp
from tgbot.loader import bot
from tgbot.services.api_qiwi import QiwiAPI
from tgbot.services.api_sqlite import *
from tgbot.utils.const_functions import get_date, split_messages, get_unix, clear_list
from tgbot.utils.misc.bot_filters import IsShopAdmin, IsAdminorShopAdmin
from tgbot.utils.misc_functions import user_refill_my, calc_cart_summ, open_cart_my, open_profile_my, upload_text, get_faq, send_admins
from tgbot.utils.misc_functions import get_position_admin, upload_text

async def notify(dp: Dispatcher, msg):
    print('Уведомление!')
    await send_admins(msg, markup="default")
################################################################################################
# Заявка на продавца магазина
# Открытие товаров
@dp.message_handler(text="Я продавец", state="*")
async def user_seller_request(message: Message, state: FSMContext):
    # await state.finish()
    await state.set_state("here_seller_request_direction")
    await message.answer("<b>📁 Введите вид товаров или услуг, которые Вы предлагаете:</b>")

# Управление товарами
@dp.message_handler(IsShopAdmin(), text="🎁 Управление товарами дмаг.🖍", state="*")
async def shopadmin_products(message: Message, state: FSMContext):
    await state.finish()
    await message.answer("<b>🎁 Редактирование товаров дмаг.</b>", reply_markup=items_sh_frep())

@dp.message_handler(text="🗃 Создать категорию ➕", state="*")
async def product_category_create(message: Message, state: FSMContext):
    await state.finish()

    await state.set_state("here_category_name")
    await message.answer("<b>🗃 Введите название для категории 🏷</b>")


# Начальные категории для изменения позиции
@dp.message_handler(IsShopAdmin(), text="📁 Изменить позицию 🖍", state="*")  # !!!!!!!   Изменить позицию
async def product_position_edit(message: Message, state: FSMContext):
    print('📁 Изменить позицию 🖍  user_menu.py 56')
    await state.finish()

    await message.answer("<b>📁 Выберите категорию с нужной позицией 🖍</b>",
                         reply_markup=position_edit_category_open_fp(0))






# Открытие товаров
@dp.message_handler(text="🎁 Купить", state="*")
async def user_shop(message: Message, state: FSMContext):
    print('Открытие категорий товаров  user_menu.py 65')
    await state.finish()

    get_settings = get_settingsx()
    if(get_settings['type_trade'] != 'digital'):
        city_id = get_city_user(message.from_user.id)[0]
        #get_categories = get_category_in_city(city_id)
        if len(get_category_in_city(city_id)) >= 1:
            await message.answer("<b>🎁 Выберите нужный вам товар:</b>",
                                 reply_markup=products_item_category_open_fp(0, city_id))
        else:
            await message.answer("<b>🎁 В вашем городе товаров нет, выберите другой город</b>\n\n"
                                 "🏙 Изменить город вы можете в личном кабинете")
    else: #if len(get_all_categoriesx()) >= 1
        await message.answer("<b>🎁 Выберите нужный вам товар:</b>",
                             reply_markup=products_item_category_open_fp(0, None))

# Открытие товаров
@dp.message_handler(text="🎁 Магазины", state="*")
async def user_shop(message: Message, state: FSMContext):
    print('Открытие магазинов товаров  user_menu.py 65')
    await state.finish()

    get_settings = get_settingsx()
    if(get_settings['type_trade'] != 'digital'):
        city_id = get_city_user(message.from_user.id)[0]
        #get_categories = get_category_in_city(city_id)
        if len(get_shops_on_city(city=city_id)) >= 1:
            await message.answer("<b>🎁 Выберите нужный вам товар:</b>",
                                 reply_markup=products_item_shop_open_fp(0, city_id))
        else:
            await message.answer("<b>🎁 В вашем городе товаров нет, выберите другой город</b>\n\n"
                                 "🏙 Изменить город вы можете в личном кабинете")
    else: #if len(get_all_categoriesx()) >= 1
        await message.answer("<b>🎁 Выберите нужный вам товар:</b>",
                             reply_markup=products_item_shop_open_fp(0, 0))






# Открытие пополнения счета
@dp.message_handler(text="💰 Пополнить", state="*")
async def user_refill_b(message: Message, state: FSMContext):
    await state.finish()
    await message.answer(user_refill_my(message.from_user.id), reply_markup=refill_open_inl)

#refiil_way(message.from_user.id)

# Открытие профиля
@dp.message_handler(text="👤 Профиль", state="*")
async def user_profile(message: Message, state: FSMContext):
    await state.finish()
    await message.answer(open_profile_my(message.from_user.id), reply_markup=profile_open_inl)

# Открытие корзины
@dp.message_handler(text="🧮 Корзина", state="*")
async def user_cart(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    orderdata = get_params_orderx(user_id=user_id)
    print(orderdata)
    for order in orderdata:
        print(order['order_state'])
        if order['order_state'] == 'delivery':
            await message.answer(open_cart_my(message.from_user.id), reply_markup=cart_open_delivery_inl)
        if order['order_state'] == 'created':
            await message.answer(open_cart_my(message.from_user.id), reply_markup=cart_open_created_inl)
        if order['order_state'] == 'submited':
            await message.answer(f"<b>Активных заказов нет.</b>\n")

# Открытие FAQ
@dp.message_handler(text=["ℹ FAQ", "/faq"], state="*")
async def user_faq(message: Message, state: FSMContext):
    await state.finish()

    send_message = get_settingsx()['misc_faq']
    if send_message == "None":
        send_message = f"ℹ Информация. Измените её в настройках бота.\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n{BOT_DESCRIPTION}"

    await message.answer(get_faq(message.from_user.id, send_message), disable_web_page_preview=True)


# -----------------------------------------------------------------------------------------------------------
# Открытие страниц выбора магазина для редактирования
@dp.message_handler(IsShopAdmin(), text="🏪 Изменить магазин 🖍", state="*")
async def product_category_edit(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id

    shops = get_my_shopx(user_id)
    print(f'shops {shops}')

    if len(shops) >= 1:
        await message.answer("<b>🏪 Выберите магазин для изменения 🖍</b>",
                             reply_markup=shop_edit_open_fp(0, shops))
    else:
        await message.answer("<b>🏪 Магазины отсутствуют 🖍</b>")


# Открытие сообщения с ссылкой на поддержку
@dp.message_handler(text=["☎ Поддержка", "/support"], state="*")
async def user_support(message: Message, state: FSMContext):
    await state.finish()

    user_support = get_settingsx()['misc_support']
    if str(user_support).isdigit():
        get_user = get_userx(user_id=user_support)

        if len(get_user['user_login']) >= 1:
            await message.answer("<b>☎ Нажмите кнопку ниже для связи с Администратором.</b>",
                                 reply_markup=user_support_finl(get_user['user_login']))
            return
        else:
            update_settingsx(misc_support="None")

    await message.answer(f"☎ Поддержка. Измените их в настройках бота.\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n{BOT_DESCRIPTION}",
                         disable_web_page_preview=True)


# Создание запроса на продавца
@dp.message_handler(state="here_seller_request_direction")
async def user_seller(message: Message, state: FSMContext):
    await state.finish()
    # message.answer(message.text)
    seller_request = create_seller_request(message.from_user.id, message.text)
    await message.answer("👌 Ваш запрос успешно отправлен.")

# Просмотр истории покупок
@dp.callback_query_handler(text="create_seller_request5", state="*")
async def user_seller(call: CallbackQuery, state: FSMContext):
    seller_request = create_seller_request(call.from_user.id)
    await call.answer("🎁 Запрос успешно создан")
    await notify(dp, "Поступил новый запрос продавца!")
    # await bot.send_message(get_admins(), "ntcnnnnnn")

# Подтверждение удаления всех позиций
@dp.message_handler(IsShopAdmin(), text="📁 Удалить все позиции ❌", state="*")
async def product_position_remove(message: Message, state: FSMContext):
    await state.finish()

    await message.answer("<b>📁 Вы действительно хотите удалить все позиции? ❌</b>\n"
                         "❗ Так же будут удалены все товары",
                         reply_markup=position_remove_confirm_inl)

# Удаление позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_delete", state="*")
async def product_position_edit_delete(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await call.message.delete()
    await call.message.answer("<b>📁 Вы действительно хотите удалить позицию? ❌</b>",
                              reply_markup=position_edit_delete_finl(position_id, category_id, remover))


# Подтверждение удаления позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_delete", state="*")
async def product_position_edit_delete_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])
    remover = int(call.data.split(":")[4])

    if get_action == "yes":
        remove_itemx(position_id=position_id)
        remove_positionx(position_id=position_id)

        await call.answer("📁 Вы успешно удалили позицию и её товары ✅")

        if len(get_positionsx(category_id=category_id)) >= 1:
            await call.message.edit_text("<b>📁 Выберите нужную вам позицию 🖍</b>",
                                         reply_markup=position_edit_open_fp(remover, category_id))
        else:
            await call.message.delete()
    else:
        get_message, get_photo = get_position_admin(position_id)

        if get_photo is not None:
            await call.message.delete()
            await call.message.answer_photo(get_photo, get_message,
                                            reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await call.message.edit_text(get_message,
                                         reply_markup=position_edit_open_finl(position_id, category_id, remover))


# Согласие очистики позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_clear", state="*")
async def product_position_edit_clear_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])
    remover = int(call.data.split(":")[4])

    if get_action == "yes":
        remove_itemx(position_id=position_id)
        await call.answer("📁 Вы успешно удалили все товары позиции ✅")

    get_message, get_photo = get_position_admin(position_id)

    if get_photo is not None:
        await call.message.delete()
        await call.message.answer_photo(get_photo, get_message,
                                        reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await call.message.edit_text(get_message,
                                     reply_markup=position_edit_open_finl(position_id, category_id, remover))


# Открытие способов пополнения
@dp.message_handler(IsShopAdmin(), text="🖲 Способы пополнения", state="*")
async def payment_systems(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id

    await message.answer("<b>🖲 Выберите способ пополнения</b>", reply_markup=payment_as_choice_finl(user_id))


# Включение/выключение самих способов пополнения
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="change_payment7:")
async def payment_systems_edit7(call: CallbackQuery):
    way_pay = call.data.split(":")[1]
    way_status = call.data.split(":")[2]
    user_id = json.dumos(call.data.split(":")[3])
    print("Админ магазина")
    # print(call.data.split(":")[0])
    print(call.from_user.id)
    user_id = call.from_user.id

    count = get_upaycount(user_id)
    print(count['paycount'])
    if count['paycount'] == 0:
        cur = create_upayments_row(user_id)
    else:
        get_payment = get_upaymentx(user_id)

    if get_payment['qiwi_login'] != "None" and get_payment['qiwi_token'] != "None" or way_status == "False":
        if way_pay == "Form":
            if get_payment['qiwi_secret'] != "None" or way_status == "False":
                update_upaymentx(user_id, way_form=way_status)
            else:
                await call.answer(
                    "❗ Приватный ключ отсутствует. Измените киви и добавьте приватный ключ для включения оплаты по Форме",
                    True)
        elif way_pay == "ForYm":
            if get_payment['yoo_token'] != "None" or way_status == "False":
                update_upaymentx(user_id, way_formy=way_status)
            else:
                await call.answer(
                    "❗ Номер счета отсутствует. Измените YooMoney и добавьте токен для включения оплаты по Форме YooMoney",
                    True)
        elif way_pay == "Number":
            update_update_upaymentx(user_id, way_number=way_status)
        elif way_pay == "Nickname":
            status, response = await (await QiwiAPI(call)).get_nickname()
            if status:
                update_upaymentx(user_id, way_nickname=way_status, qiwi_nickname=response)
            else:
                await call.answer(response, True)
    else:
        await call.answer("❗ Добавьте киви кошелёк перед включением Способов пополнений.", True)

    try:
        await call.message.edit_text("<b>🖲 Выберите способ пополнения</b>", reply_markup=payment_as_choice_finl())
    except Exception:
        pass


####################################### QIWI ######################################
# Изменение QIWI кошелька
@dp.message_handler(IsShopAdmin(), text="🥝 Изменить QIWI 🖍", state="*")
async def payment_qiwi_edit(message: Message, state: FSMContext):
    await state.finish()

    await state.set_state("here_qiwi_login")
    await message.answer("<b>🥝 Введите <code>номер (через +7, +380)</code> QIWI кошелька 🖍</b>")


# Проверка работоспособности QIWI
@dp.message_handler(IsShopAdmin(), text="🥝 Проверить QIWI ♻", state="*")
async def payment_qiwi_check(message: Message, state: FSMContext):
    print("Проверка КИВИ админом магазина")
    await state.finish()

    await (await QiwiAPI(message, check_pass=True)).pre_checker()


# Баланс QIWI
@dp.message_handler(IsShopAdmin(), text="🥝 Баланс QIWI 👁", state="*")
async def payment_qiwi_balance(message: Message, state: FSMContext):
    await state.finish()

    await (await QiwiAPI(message)).get_balance()


######################################## ПРИНЯТИЕ QIWI ########################################
# Принятие логина для QIWI
@dp.message_handler(IsShopAdmin(), state="here_qiwi_login")
async def payment_qiwi_edit_login(message: Message, state: FSMContext):
    if message.text.startswith("+"):
        await state.update_data(here_qiwi_login=message.text)

        await state.set_state("here_qiwi_token")
        await message.answer(
            "<b>🥝 Введите <code>токен API</code> QIWI кошелька 🖍</b>\n"
            "❕ Получить можно тут 👉 <a href='https://qiwi.com/api'><b>Нажми на меня</b></a>\n"
            "❕ При получении токена, ставьте только первые 3 галочки.",
            disable_web_page_preview=True
        )
    else:
        await message.answer("<b>❌ Номер должен начинаться с + <code>(+7..., +380...)</code></b>\n"
                             "🥝 Введите <code>номер (через +7, +380)</code> QIWI кошелька 🖍")


# Принятие токена для QIWI
@dp.message_handler(IsShopAdmin(), state="here_qiwi_token")
async def payment_qiwi_edit_token(message: Message, state: FSMContext):
    await state.update_data(here_qiwi_token=message.text)

    await state.set_state("here_qiwi_secret")
    await message.answer(
        "<b>🥝 Введите <code>Секретный ключ 🖍</code></b>\n"
        "❕ Получить можно тут 👉 <a href='https://qiwi.com/p2p-admin/transfers/api'><b>Нажми на меня</b></a>\n"
        "❕ Вы можете пропустить добавление оплаты по Форме, отправив: <code>0</code>",
        disable_web_page_preview=True
    )


# Принятие приватного ключа для QIWI
@dp.message_handler(IsShopAdmin(), state="here_qiwi_secret")
async def payment_qiwi_edit_secret(message: Message, state: FSMContext):
    async with state.proxy() as data:
        qiwi_login = data['here_qiwi_login']
        qiwi_token = data['here_qiwi_token']
        if message.text == "0": qiwi_secret = "None"
        if message.text != "0": qiwi_secret = message.text

    await state.finish()

    cache_message = await message.answer("<b>🥝 Проверка введённых QIWI данных... 🔄</b>")
    await asyncio.sleep(0.5)

    await (await QiwiAPI(cache_message, qiwi_login, qiwi_token, qiwi_secret, True)).pre_checker()


################################################################################################
###################################### УДАЛЕНИЕ ВСЕХ ПОЗИЦИЙ ###################################
# Согласие на удаление всех позиций и товаров
@dp.callback_query_handler(IsShopAdmin(), text_startswith="confirm_remove_position:", state="*")
async def product_position_remove(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    print("SA DEL POSITIONS")
    user_id = call.from_user.id
    print(user_id)

    if get_action == "yes":

        get_positions = len(get_all_my_positionsnx(position_user_id=user_id))
        print(get_positions)
        get_items = len(get_all_my_itemsnx(creator_id=user_id))
        print(get_items)

        remove_positionx(position_user_id=user_id)
        remove_itemx(creator_id=user_id)

        await call.message.edit_text(
            f"<b>📁 Вы удалили все позиции<code>({get_positions}шт)</code> и товары<code>({get_items}шт)</code> ☑</b>")
    else:
        await call.message.edit_text("<b>📁 Вы отменили удаление всех позиций ✅</b>")

#################### УДАЛЕНИЕ ТОВАРОВ ###################
# Кнопки с подтверждением удаления всех категорий
@dp.message_handler(IsShopAdmin(), text="🎁 Удалить все товары ❌", state="*")
async def product_item_remove(message: Message, state: FSMContext):
    await state.finish()

    await message.answer("<b>🎁 Вы действительно хотите удалить все товары? ❌</b>\n",
                         reply_markup=item_remove_confirm_inl)

##################################### УДАЛЕНИЕ ВСЕХ ТОВАРОВ ####################################
# Согласие на удаление всех товаров
@dp.callback_query_handler(IsShopAdmin(), text_startswith="confirm_remove_item:", state="*")
async def product_item_remove(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    if get_action == "yes":
        user_id = call.from_user.id

        get_items = len(get_all_my_itemsnx(creator_id=user_id))
        remove_itemx(creator_id=user_id)

        await call.message.edit_text(f"<b>🎁 Вы удалили все товары<code>({get_items}шт)</code> ☑</b>")
    else:
        await call.message.edit_text("<b>🎁 Вы отменили удаление всех товаров ✅</b>")


# Удаление определённых товаров
@dp.message_handler(IsShopAdmin(), text="🎁 Удалить товары 🖍", state="*")
async def product_item_delete(message: Message, state: FSMContext):
    await state.finish()

    await state.set_state("here_items_delete")
    await message.answer("<b>🖍 Вводите айди товаров, которые нужно удалить</b>\n"
                         "❕ Получить айди товаров можно при изменении позиции\n"
                         "❕ Если хотите удалить несколько товаров, отправьте ID товаров через запятую или пробел. Пример:\n"
                         "<code>▶ 123456,123456,123456</code>\n"
                         "<code>▶ 123456 123456 123456</code>")

################################################################################################
####################################### УДАЛЕНИЕ ТОВАРОВ ######################################
# Принятие айди товаров для их удаления
@dp.message_handler(IsShopAdmin(), state="here_items_delete")
async def product_item_delete_get(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id

    remove_ids, cancel_ids = [], []  # Айди удалённых и ненайденных товаров
    get_item_ids_one, get_item_ids_two = [], [[]]
    save_ids = []

    if "," in message.text:
        get_item_ids_one = clear_list(message.text.split(","))
    else:
        get_item_ids_one = clear_list([message.text])

    get_item_ids_two.extend(
        item.split(" ") for item in get_item_ids_one if " " in item
    )
    if len(get_item_ids_two) == 1:
        get_item_ids_two.append(get_item_ids_one)

    for check_item in get_item_ids_two:
        save_ids.extend(iter(clear_list(check_item)))
    save_ids = clear_list(save_ids)

    for item_id in save_ids:
        #check_item = get_itemx(item_id=item_id)
        check_item = get_itemx(item_id=item_id, creator_id=user_id)
        if check_item is not None:
            remove_itemx(item_id=item_id)
            remove_ids.append(item_id)
        else:
            cancel_ids.append(item_id)

    remove_ids = ", ".join(remove_ids)
    cancel_ids = ", ".join(cancel_ids)

    await message.answer(f"<b>✅ Успешно удалённые товары:\n"
                         f"▶ <code>{remove_ids}</code>\n"
                         f"➖➖➖➖➖➖➖➖➖➖\n"
                         f"❌ Ненайденные товары:\n"
                         f"▶ <code>{cancel_ids}</code></b>")
###############################################################################################
################################################################################################
####################################### ДОБАВЛЕНИЕ ПОЗИЦИЙ #####################################
# Следующая страница выбора категорий для создания позиций
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_create_nextp:", state="*")
async def product_position_create_next(call: CallbackQuery, state: FSMContext):
    print('выбора категорий для создания позиций  user_menu.py 126')
    remover = int(call.data.split(":")[1])
    print(remover)

    await call.message.edit_text("<b>📁 Выберите категорию для позиции ➕</b>",
                                 reply_markup=position_create_next_page_fp(remover))


# Предыдущая страница выбора категорий для создания позиций
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_create_backp:", state="*")
async def product_position_create_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text("<b>📁 Выберите категорию для позиции ➕</b>",
                                 reply_markup=position_create_back_page_fp(remover))


@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_shop_create_here:", state="*")
async def product_position_create(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])

    await state.update_data(here_cache_change_shop_id=category_id)

    if len(get_all_categoriesx()) >= 1:
        await call.message.answer("<b>📁 Выберите категорию для позиции</b>",
                                  reply_markup=position_create_open_fp(0))
    else:
        await call.message.answer("<b>❌ Отсутствуют категории для создания позиции.</b>")


# Выбор категории для создания позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_create_here:", state="*")
async def product_position_create_select_category(call: CallbackQuery, state: FSMContext):
    print('position_create_here - user_menu 160')
    category_id = int(call.data.split(":")[1])

    await state.update_data(here_cache_change_category_id=category_id)

    await state.set_state("here_position_name")
    await call.message.edit_text("<b>📁 Введите название для позиции 🏷</b>")


# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Заготовка под принятие города магазином
# Принятие города для создания позиции
# @dp.message_handler(IsShopAdmin(), state="here_position_city")
# async def product_position_create_name(message: Message, state: FSMContext):
#     print(f'Принятие города для создания позиции  admin_products_shop.py 344')
#     city_user = get_city_user(message.from_user.id)
# Принятие имени для создания позиции


@dp.message_handler(IsShopAdmin(), state="here_position_name")
async def product_position_create_name(message: Message, state: FSMContext):
    print('Принятие имени для создания позиции  user_menu.py 355')
    if len(message.text) <= 100:
        await state.update_data(here_position_name=clear_html(message.text),
                                here_position_city=get_citytext_user(message.from_user.id)[0]
                                , position_city_id=get_city_user(message.from_user.id)[0])

        await state.set_state("here_position_price")
        await message.answer("<b>📁 Введите цену для позиции 💰</b>")
    else:
        await message.answer("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "📁 Введите название для позиции 🏷")


# Принятие цены позиции для её создания
@dp.message_handler(IsShopAdmin(), state="here_position_price")
async def product_position_create_price(message: Message, state: FSMContext):
    print('Принятие цены позиции  admin_products.py 366')
    if message.text.isdigit():
        if 0 <= int(message.text) <= 10000000:
            await state.update_data(here_position_price=message.text)

            await state.set_state("here_position_description")
            await message.answer("<b>📁 Введите описание для позиции 📜</b>\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.")
        else:
            await message.answer("<b>❌ Цена не может быть меньше 0 или больше 10 000 000.</b>\n"
                                 "📁 Введите цену для позиции 💰")
    else:
        await message.answer("<b>❌ Данные были введены неверно.</b>\n"
                             "📁 Введите цену для позиции 💰")


# Принятие описания позиции для её создания
@dp.message_handler(IsShopAdmin(), state="here_position_description")
async def product_position_create_description(message: Message, state: FSMContext):
    print('Принятие описания позиции  admin_products.py 386')

    try:
        if len(message.text) <= 600:
            if message.text != "0":
                cache_msg = await message.answer(message.text)
                await cache_msg.delete()

            await state.update_data(here_position_description=message.text)

            await state.set_state("here_position_photo")
            await message.answer("<b>📁 Отправьте изображение для позиции 📸</b>\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.")
        else:
            await message.answer("<b>❌ Описание не может превышать 600 символов.</b>\n"
                                 "📁 Введите новое описание для позиции 📜\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.")
    except CantParseEntities:
        await message.answer("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📁 Введите описание для позиции 📜\n"
                             "❕ Вы можете использовать HTML разметку\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.")


# Принятие изображения позиции для её создания
@dp.message_handler(IsShopAdmin(), content_types="photo", state="here_position_photo")
@dp.message_handler(IsShopAdmin(), text="0", state="here_position_photo")
async def product_position_create_photo(message: Message, state: FSMContext):
    print('Принятие изображения позиции  admin_products.py 418')
    async with state.proxy() as data:
        position_user_id = message.from_user.id
        position_city = data['here_position_city']
        position_city_id = data['position_city_id']
        position_name = clear_html(data['here_position_name'])
        position_price = data['here_position_price']
        catategory_id = data['here_cache_change_category_id']
        position_description = data['here_position_description']
    await state.finish()

    position_photo = "" if "text" in message else message.photo[-1].file_id
    add_positionx(position_city, position_city_id, position_name, position_price, position_description, position_photo,
                  catategory_id, position_user_id)

    #async def on_notify(dp: Dispatcher, msg, markup):
    #    await send_admins(msg, markup="default")
    await notify(dp, f"Создана позиция: {position_name}, пользователем ID: {position_user_id}")

    await message.answer("<b>📁 Позиция была успешно создана ✅</b>")


################################################################################################
####################################### ИЗМЕНЕНИЕ ПОЗИЦИЙ #####################################
# Возвращение к начальным категориям для редактирования позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_category_return", state="*")
async def product_position_edit_return(call: CallbackQuery, state: FSMContext):
    await call.message.edit_text("<b>📁 Выберите категорию с нужной позицией 🖍</b>",
                                 reply_markup=position_edit_category_open_fp(0))


# Следующая страница категорий для редактирования позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_category_nextp:", state="*")
async def product_position_edit_category_next(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text("<b>📁 Выберите категорию с нужной позицией 🖍</b>",
                                 reply_markup=position_edit_category_next_page_fp(remover))


# Предыдущая страница категорий для редактирования позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_category_backp:", state="*")
async def product_position_edit_category_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text("<b>📁 Выберите категорию с нужной позицией 🖍</b>",
                                 reply_markup=position_edit_category_back_page_fp(remover))


# Выбор категории с нужной позицией
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_category:", state="*")
async def product_position_edit_category_open(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])

    if len(get_positionsx(category_id=category_id)) >= 1:
        await call.message.edit_text("<b>📁 Выберите нужную вам позицию 🖍</b>",
                                     reply_markup=position_edit_open_fp(0, category_id))
    else:
        await call.answer("📁 Позиции в данной категории отсутствуют")


# Следующая страница позиций для их изменения
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_nextp:", state="*")
async def product_position_edit_next(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])

    await call.message.edit_text("<b>📁 Выберите категорию с нужной позицией 🖍</b>",
                                 reply_markup=position_edit_next_page_fp(remover, category_id))


# Предыдущая страница позиций для их изменения
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_backp:", state="*")
async def product_position_edit_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])

    await call.message.edit_text("<b>📁 Выберите категорию с нужной позицией 🖍</b>",
                                 reply_markup=position_edit_back_page_fp(remover, category_id))


# Выбор позиции для редактирования
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit:", state="*")
async def product_position_edit_open(call: CallbackQuery, state: FSMContext):
    print('Выбор позиции для редактирования api_sqlite.py 496')
    position_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])
    user_id = call.from_user.id

    # IsProductShopAdmin()
    adminspos = check_position_owner(user_id, position_id)
    if adminspos is True:

        get_message, get_photo = get_position_admin(position_id)

        if get_photo is not None:
            await call.message.delete()
            await call.message.answer_photo(get_photo, get_message,
                                            reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await call.message.edit_text(get_message,
                                         reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await call.answer("<b>❗ У Вас нет прав редактировать данную позицию.</b>")


# Возвращение к выбору позиции для изменения
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_return", state="*")
async def product_position_edit_return(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])

    if len(get_positionsx(category_id=category_id)) >= 1:
        await call.message.delete()
        await call.message.answer("<b>📁 Выберите нужную вам позицию 🖍</b>",
                                  reply_markup=position_edit_open_fp(remover, category_id))
    else:
        await call.answer("<b>❗ Позиции в данной категории отсутствуют</b>")


######################################## САМО ИЗМЕНЕНИЕ ПОЗИЦИИ ########################################
# Изменение имени позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_name", state="*")
async def product_position_edit_name(call: CallbackQuery, state: FSMContext):
    print('Изменение имени позиции api_sqlite.py 529')
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_name")
    await call.message.delete()
    await call.message.answer("<b>📁 Введите новое название для позиции 🏷</b>")


# Принятие имени позиции для её изменения
@dp.message_handler(IsShopAdmin(), state="here_change_position_name")
async def product_position_edit_name_get(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        async with state.proxy() as data:
            position_id = data['here_cache_category_id']
            category_id = data['here_cache_position_id']
            remover = data['here_cache_position_remover']
        await state.finish()

        update_positionx(position_id, position_name=clear_html(message.text))
        get_message, get_photo = get_position_admin(position_id)

        if get_photo is not None:
            await message.answer_photo(get_photo, get_message,
                                       reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await message.answer(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await message.answer("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "📁 Введите новое название для позиции 🏷")


# Изменение цены позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_price", state="*")
async def product_position_edit_price(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_price")
    await call.message.delete()
    await call.message.answer("<b>📁 Введите новую цену для позиции 💰</b>")


# Принятие цены позиции для её изменения
@dp.message_handler(IsShopAdmin(), state="here_change_position_price")
async def product_position_edit_price_get(message: Message, state: FSMContext):
    if message.text.isdigit():
        if 0 <= int(message.text) <= 10000000:
            async with state.proxy() as data:
                position_id = data['here_cache_category_id']
                category_id = data['here_cache_position_id']
                remover = data['here_cache_position_remover']
            await state.finish()

            update_positionx(position_id, position_price=message.text)
            get_message, get_photo = get_position_admin(position_id)

            if get_photo is not None:
                await message.answer_photo(get_photo, get_message,
                                           reply_markup=position_edit_open_finl(position_id, category_id, remover))
            else:
                await message.answer(get_message,
                                     reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await message.answer("<b>❌ Цена не может быть меньше 0 или больше 10 000 000.</b>\n"
                                 "📁 Введите цену для позиции 💰")
    else:
        await message.answer("<b>❌ Данные были введены неверно.</b>\n"
                             "📁 Введите цену для позиции 💰")


# Изменение описания позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_description", state="*")
async def product_position_edit_description(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_description")
    await call.message.delete()
    await call.message.answer("<b>📁 Введите новое описание для позиции 📜</b>\n"
                              "❕ Вы можете использовать HTML разметку\n"
                              "❕ Отправьте <code>0</code> чтобы пропустить.")


# Принятие описания позиции для её изменения
@dp.message_handler(IsShopAdmin(), state="here_change_position_description")
async def product_position_edit_description_get(message: Message, state: FSMContext):
    async with state.proxy() as data:
        position_id = data['here_cache_category_id']
        category_id = data['here_cache_position_id']
        remover = data['here_cache_position_remover']

    try:
        if len(message.text) <= 600:
            await state.finish()

            if message.text != "0":
                cache_msg = await message.answer(message.text)
                await cache_msg.delete()

            update_positionx(position_id, position_description=message.text)
            get_message, get_photo = get_position_admin(position_id)

            if get_photo is not None:
                await message.answer_photo(get_photo, get_message,
                                           reply_markup=position_edit_open_finl(position_id, category_id, remover))
            else:
                await message.answer(get_message,
                                     reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await message.answer("<b>❌ Описание не может превышать 600 символов.</b>\n"
                                 "📁 Введите новое описание для позиции 📜\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.")
    except CantParseEntities:
        await message.answer("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📁 Введите новое описание для позиции 📜\n"
                             "❕ Вы можете использовать HTML разметку\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.")


# Изменение изображения позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_photo", state="*")
async def product_position_edit_photo(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_photo")
    await call.message.delete()
    await call.message.answer("<b>📁 Отправьте новое изображение для позиции 📸</b>\n"
                              "❕ Отправьте <code>0</code> чтобы пропустить.")


# Принятие нового фото для позиции
@dp.message_handler(IsShopAdmin(), content_types="photo", state="here_change_position_photo")
@dp.message_handler(IsShopAdmin(), text="0", state="here_change_position_photo")
async def product_position_edit_photo_get(message: Message, state: FSMContext):
    async with state.proxy() as data:
        position_id = data['here_cache_category_id']
        category_id = data['here_cache_position_id']
        remover = data['here_cache_position_remover']
    await state.finish()

    position = get_positionx(position_id=position_id)
    print(position['position_name'])

    position_photo = "" if "text" in message else message.photo[-1].file_id
    update_positionx(position_id, position_photo=position_photo)
    get_message, get_photo = get_position_admin(position_id)
    await notify(dp, f"Была отредактирована позиция: {position['position_name']}")

    if get_photo is not None:
        await message.answer_photo(get_photo, get_message,
                                   reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await message.answer(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover))


# ---------------------------  Добавлено 12.08.22 ------------------------------------------

# Изменение города продукта
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_city", state="*")
async def product_position_edit_description(call: CallbackQuery, state: FSMContext):
    print('Изменение города продукта  admin_products.py 715')
    print(call.data)
    category_id = int(call.data.split(":")[2])
    position_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[3])

    current_city = get_city_user(call.from_user.id)[0]

    # await state.update_data(here_cache_category_id=category_id)
    # await state.update_data(here_cache_position_id=position_id)
    # await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_city")
    await state.update_data({'position_id': position_id, 'category_id': category_id, 'remover': remover})
    await call.message.delete()
    await call.message.answer("<b>📁 Выберите другой город 🏙</b>\n"
                              "❕ Вы можете использовать геолокацию или выбрать город из списка\n"
                              f"❕  Город товара: <code>{current_city}</code>", reply_markup=geo_1_kb())


# принятие новой геопозиции для позиции
@dp.callback_query_handler(text_startswith='geo_chosen_cities', state='here_change_city')
async def geo_5(cb: CallbackQuery, state: FSMContext):
    info = int(str(cb.data).split('#')[1])
    if info == 0:
        async with state.proxy() as data:
            city = data['city']
            position_id = int(data['position_id'])
            category_id = data['category_id']
            remover = data['remover']
            city_id = data['city_id']

    else:
        async with state.proxy() as data:
            position_id = int(data['position_id'])
            category_id = data['category_id']
            remover = data['remover']

        city_id = info
        city = get_city_info(info)

    await state.finish()
    update_position_city(city[0], city_id, position_id)

    # update_positionx(position_id)
    get_message, get_photo = get_position_admin(position_id)

    if get_photo is not None:
        await cb.message.answer_photo(get_photo, get_message,
                                      reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await cb.message.answer(get_message,
                                reply_markup=position_edit_open_finl(position_id, category_id, remover))


################################################################################################
# Просмотр истории покупок
@dp.callback_query_handler(text="user_history", state="*")
async def user_history(call: CallbackQuery, state: FSMContext):
    last_purchases = last_purchasesx(call.from_user.id, 5)

    if len(last_purchases) >= 1:
        await call.answer("🎁 Последние 5 покупок")
        await call.message.delete()

        for purchases in last_purchases:
            link_items = await upload_text(call, purchases['purchase_item'])

            await call.message.answer(f"<b>🧾 Чек: <code>#{purchases['purchase_receipt']}</code></b>\n"
                                      f"🎁 Товар: <code>{purchases['purchase_position_name']} | {purchases['purchase_count']}шт | {purchases['purchase_price']}₽</code>\n"
                                      f"🕰 Дата покупки: <code>{purchases['purchase_date']}</code>\n"
                                      f"🔗 Товары: <a href='{link_items}'>кликабельно</a>")

        await call.message.answer(open_profile_my(call.from_user.id), reply_markup=profile_open_inl)
    else:
        await call.answer("❗ У вас отсутствуют покупки", True)


# Возвращение к профилю
@dp.callback_query_handler(text="user_profile", state="*")
async def user_profile_return(call: CallbackQuery, state: FSMContext):
    await call.message.edit_text(open_profile_my(call.from_user.id), reply_markup=profile_open_inl)


# Возвращение к корзине
@dp.callback_query_handler(text="user_cart", state="*")
async def user_cart_return(call: CallbackQuery, state: FSMContext):
    user_id = call.from_user.id
    orderdata = get_params_orderx(user_id=user_id)
    #cart_state = orderdata['order_state']
    for order in orderdata:
        #await call.message.edit_text(open_cart_my(call.from_user.id), reply_markup=cart_open_+{'cart_state'}+_inl)
        if order['order_state'] == 'created':
            await call.message.answer(open_cart_my(user_id), reply_markup=cart_open_created_inl)
        if order['order_state'] == 'delivery':
            await call.message.answer(open_cart_my(user_id), reply_markup=cart_open_delivery_inl)
        if order['order_state'] == 'submited':
            await call.message.answer(f"<b>🎁 Активных заказов нет.</b>\n")

################################################################################################
######################################### ПОКУПКА ТОВАРА #######################################
########################################### КАТЕГОРИИ ##########################################
# Открытие категорий для покупки
@dp.callback_query_handler(text_startswith="buy_category_open", state="*")
async def user_purchase_category_open(call: CallbackQuery, state: FSMContext):
    print('Открытие категорий для покупки user_menu.py 133')
    category_id = int(call.data.split(":")[1])

    get_category = get_categoryx(category_id=category_id)
    city = get_city_user(call.from_user.id)[0]
    get_positions = get_position_on_city(category_id, city)  # get_positionsx(category_id=category_id)

    if len(get_positions) >= 1:
        await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                     reply_markup=products_item_position_open_fp(0, category_id, city))
    else:
        await call.answer(f"❕ Товары в категории {get_category['category_name']} отсутствуют")


# Вернуться к категориям для покупки
@dp.callback_query_handler(text_startswith="buy_category_return", state="*")
async def user_purchase_category_return(call: CallbackQuery, state: FSMContext):
    get_categories = get_all_categoriesx()
    get_settings = get_settingsx()
    city = None
    if get_settings['type_trade'] != 'digital':
        city = get_city_user(call.from_user.id)[0]

    if len(get_categories) >= 1:
        await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                     reply_markup=products_item_category_open_fp(0, city))
    else:
        await call.message.edit_text("<b>🎁 Товары в данное время отсутствуют.</b>")
        await call.answer("❗ Категории были изменены или удалены")


# Следующая страница категорий для покупки
@dp.callback_query_handler(text_startswith="buy_category_nextp", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                 reply_markup=products_item_category_next_page_fp(remover))


# Предыдущая страница категорий для покупки
@dp.callback_query_handler(text_startswith="buy_category_backp", state="*")
async def user_purchase_category_prev_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                 reply_markup=products_item_category_back_page_fp(remover))

############################################ МАГАЗИН => КАТЕГОРИИ #############################

########################################### МАГАЗИНЫ ##########################################
# Открытие магазина для покупки
@dp.callback_query_handler(text_startswith="buy_shop_open", state="*")
async def user_purchase_category_open(call: CallbackQuery, state: FSMContext):
    print('Открытие магазина для покупки user_menu.py 133')
    shop_id = int(call.data.split(":")[1])

    get_shop = get_shopsxx(shop_id=shop_id)
    user_id = call.from_user.id
    city_id = get_city_user(user_id)[0]
    get_positions = get_shopposition_on_city(shop_id, city_id)  # get_positionsx(category_id=category_id)

    if len(get_positions) >= 1:
        await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                     reply_markup=products_shitem_position_open_fp(0, shop_id, city_id))
    else:
        await call.answer(f"❕ Товары в магазине {get_shop['name']} отсутствуют")


# Вернуться к категориям для покупки
@dp.callback_query_handler(text_startswith="buy_parcategory_return", state="*")
async def user_purchase_category_return(call: CallbackQuery, state: FSMContext):
    get_categories = get_all_categoriesx()
    get_settings = get_settingsx()
    city_id = None
    if get_settings['type_trade'] != 'digital':
        city_id = get_city_user(call.from_user.id)[0]

    if len(get_categories) >= 1:
        await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                     reply_markup=products_item_shop_open_fp(0, shop_id, city_id))
    else:
        await call.message.edit_text("<b>🎁 Товары в данное время отсутствуют.</b>")
        await call.answer("❗ Категории были изменены или удалены")


# Следующая страница категорий для покупки
@dp.callback_query_handler(text_startswith="buy_category_nextp", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                 reply_markup=products_item_category_next_page_fp(remover))


# Предыдущая страница категорий для покупки
@dp.callback_query_handler(text_startswith="buy_category_backp", state="*")
async def user_purchase_category_prev_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                 reply_markup=products_item_category_back_page_fp(remover))


########################################### ПОЗИЦИИ ##########################################
# Открытие позиции для покупки
@dp.callback_query_handler(text_startswith="buy_parposition_open", state="*")
async def user_purchase_position_open(call: CallbackQuery, state: FSMContext):
    print('Карточка товара: user_menu.py  1194')
    position_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])
    shop_id = int(call.data.split(":")[5])

    print(position_id, remover, category_id, shop_id)

    get_position = get_positionx(position_id=position_id)
    #if category_id != 0: get_category = get_categoryx(category_id=category_id)
    #else: get_category['category_name'] = 0
    get_items = get_itemsx(position_id=position_id)
    get_settings = get_settingsx()
    get_shop = get_shopx(shop_id=shop_id)

    if get_position['position_description'] == "0":
        text_description = ""
    else:
        text_description = f"\n📜 Описание:\n" \
                           f"{get_position['position_description']}"
    #get_shop['name']
    send_msg = f"<b>Карточка:</b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"🏷 Название: <code>{get_position['position_name']}</code>\n" \
               f"🏙 Магазин: <code>{get_shop['name']}</code>\n" \
               f"🏙 Город: <code>{get_position['position_city']}</code>\n" \
               f"🗃 Категория: <code></code>\n" \
               f"💰 Стоимость: <code>{get_position['position_price']}₽</code>\n" \
               f"{text_description}"
    #{get_category['category_name']}
    #f"📦 Остаток: <code>{len(get_items)}шт</code>" \
    print(get_settings['type_trade'])
    tt = get_settings['type_trade']

    if tt == "digital":
        if len(get_position['position_photo']) >= 5:
            await call.message.delete()
            await call.message.answer_photo(get_position['position_photo'],
                                            send_msg, reply_markup=products_open_finl(position_id, remover, category_id))
        else:
            await call.message.edit_text(send_msg,
                                         reply_markup=products_open_finl(position_id, remover, category_id))

    elif len(get_position['position_photo']) >= 5:
        await call.message.delete()
        await call.message.answer_photo(get_position['position_photo'],
                                        send_msg, reply_markup=products_open_cart_finl(position_id, remover, category_id))
    else:
        await call.message.edit_text(send_msg,
                                     reply_markup=products_open_cart_finl(position_id, remover, category_id))


# Вернуться к позициям для покупки
@dp.callback_query_handler(text_startswith="buy_parposition_return", state="*")
async def user_purchase_position_return(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])
    shop_id = int(call.data.split(":")[4])

    get_positions = get_all_positionsx()
    city = get_city_user(call.from_user.id)[0]

    if len(get_positions) >= 1:
        await call.message.delete()
        await call.message.answer("<b>🎁 Выберите нужный вам товар:</b>",
                                  reply_markup=products_shitem_position_open_fp(remover, category_id, city_id, shop_id))
    else:
        await call.message.edit_text("<b>🎁 Товары в данное время отсутствуют.</b>")
        await call.answer("❗ Позиции были изменены или удалены")


# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="buy_parcategory_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                 reply_markup=products_item_category_swipe_fp(remover))

# Следующая страница позиций для покупки
@dp.callback_query_handler(text_startswith="buy_parposition_nextp", state="*")
async def user_purchase_position_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])
    shop_id = int(call.data.split(":")[4])

    await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                 reply_markup=products_item_shop_next_page_fp(remover, city_id, shop_id))

# Предыдущая страница позиций для покупки
@dp.callback_query_handler(text_startswith="buy_parposition_backp", state="*")
async def user_purchase_position_prev_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    #category_id = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])
    shop_id = int(call.data.split(":")[4])

    await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                 reply_markup=buy_shopposition_return_page_fp(remover, city_id, shop_id))

# Открытие позиции для покупки
@dp.callback_query_handler(text_startswith="buy_position_open", state="*")
async def user_purchase_position_open(call: CallbackQuery, state: FSMContext):
    print('Карточка товара: user_menu.py  152')
    position_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])

    get_position = get_positionx(position_id=position_id)
    get_category = get_categoryx(category_id=category_id)
    get_items = get_itemsx(position_id=position_id)
    get_settings = get_settingsx()

    if get_position['position_description'] == "0":
        text_description = ""
    else:
        text_description = f"\n📜 Описание:\n" \
                           f"{get_position['position_description']}"

    send_msg = f"<b>Карточка:</b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"🏷 Название: <code>{get_position['position_name']}</code>\n" \
               f"🏙 Город: <code>{get_position['position_city']}</code>\n" \
               f"🗃 Категория: <code>{get_category['category_name']}</code>\n" \
               f"💰 Стоимость: <code>{get_position['position_price']}₽</code>\n" \
               f"{text_description}"

    #f"📦 Остаток: <code>{len(get_items)}шт</code>" \
    print(get_settings['type_trade'])
    tt = get_settings['type_trade']

    if tt == "digital":
        if len(get_position['position_photo']) >= 5:
            await call.message.delete()
            await call.message.answer_photo(get_position['position_photo'],
                                            send_msg, reply_markup=products_open_finl(position_id, remover, category_id))
        else:
            await call.message.edit_text(send_msg,
                                         reply_markup=products_open_finl(position_id, remover, category_id))

    elif len(get_position['position_photo']) >= 5:
        await call.message.delete()
        await call.message.answer_photo(get_position['position_photo'],
                                        send_msg, reply_markup=products_open_cart_finl(position_id, remover, category_id))
    else:
        await call.message.edit_text(send_msg,
                                     reply_markup=products_open_cart_finl(position_id, remover, category_id))



# Вернуться к позициям для покупки
@dp.callback_query_handler(text_startswith="buy_position_return", state="*")
async def user_purchase_position_return(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])

    get_positions = get_all_positionsx()
    city = get_city_user(call.from_user.id)[0]

    if len(get_positions) >= 1:
        await call.message.delete()
        await call.message.answer("<b>🎁 Выберите нужный вам товар:</b>",
                                  reply_markup=products_item_position_open_fp(remover, category_id, city))
    else:
        await call.message.edit_text("<b>🎁 Товары в данное время отсутствуют.</b>")
        await call.answer("❗ Позиции были изменены или удалены")


# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="buy_category_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                 reply_markup=products_item_category_swipe_fp(remover))

# Следующая страница позиций для покупки
@dp.callback_query_handler(text_startswith="buy_position_nextp", state="*")
async def user_purchase_position_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    user_id = call.from_user.id
    city_id = get_city_user(user_id=user_id)

    await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                 reply_markup=products_item_position_next_page_fp(remover, category_id, city_id))

# Предыдущая страница позиций для покупки
@dp.callback_query_handler(text_startswith="buy_position_backp", state="*")
async def user_purchase_position_prev_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    user_id = call.from_user.id
    city_id = get_city_user(user_id=user_id)

    await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                 reply_markup=buy_position_return_page_fp(remover, category_id, city_id))


########################################### ПОКУПКА ##########################################
# Выбор количества товаров в корзине
@dp.callback_query_handler(text_startswith="add_item_cart", state="*")
async def user_purchase_addcart(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])
    print("Добавление в корзину")
    get_position = get_positionx(position_id=position_id)
    get_items = get_itemsx(position_id=position_id)
    get_user = get_userx(user_id=call.from_user.id)
    get_count = len(get_items)

    if get_count == 1:
        await state.update_data(here_cache_position_id=position_id)
        await state.finish()

        await call.message.delete()
        await call.message.answer(f"<b>1 шт. в наличии. Добавить товар(ы) в корзину?</b>\n"
                                  f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                  f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                  f"📦 Остаток: <code>1шт</code>\n"
                                  f"💰 Сумма к покупке: <code>{get_position['position_price']}₽</code>",
                                  reply_markup=products_addcart_confirm_finl(position_id, 1))
    elif get_count >= 1:
        await state.update_data(here_cache_position_id=position_id)
        await state.set_state("here_itemsadd_cart")

        await call.message.delete()
        await call.message.answer(f"<b>🎁 Введите количество товаров для покупки</b>\n"
                                  f"▶ От <code>1</code> до <code>{get_count}</code>\n"
                                  f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                  f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n"
                                  f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>")
    else:
        await call.answer("🎁 Товара нет в наличии")


# Принятие количества товаров в корзине
@dp.message_handler(state="here_itemsadd_cart")
async def user_purchase_select_count(message: Message, state: FSMContext):
    position_id = (await state.get_data())['here_cache_position_id']
    get_position = get_positionx(position_id=position_id)
    get_user = get_userx(user_id=message.from_user.id)
    get_items = get_itemsx(position_id=position_id)

    if get_position['position_price'] != 0:
        get_count = int(get_user['user_balance'] / get_position['position_price'])
        get_count = min(get_count, len(get_items))
    else:
        get_count = len(get_items)

    send_message = f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                   f"🎁 Введите количество товаров для покупки\n" \
                   f"▶ От <code>1</code> до <code>{get_count}</code>\n" \
                   f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                   f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n" \
                   f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>"
    print("test")
    if message.text:  # .isdigit()
        get_count = int(message.text)
        amount_pay = int(get_position['position_price']) * get_count

        if len(get_items) >= 1:
            if 1 <= get_count <= len(get_items):
                # if int(get_user['user_balance']) >= amount_pay:
                await state.finish()
                await message.answer(f"<b>🎁 Вы действительно хотите добавить в корзину товар(ы)?</b>\n"
                                     f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                     f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                     f"📦 Остаток: <code>{get_count}шт</code>\n"
                                     f"💰 Сумма добавляемых товаров: <code>{amount_pay}₽</code>",
                                     reply_markup=products_addcart_confirm_finl(position_id, get_count))
                # else:
                needed_to_refill = amount_pay - int(get_user['user_balance'])
                await state.finish()
                await message.answer(f"<b>🎁 Вы действительно хотите добавить в корзину товар(ы)?</b>\n"
                                     f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                     f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                     f"📦 Остаток: <code>{get_count}шт</code>\n"
                                     f"💰 Сумма добавляемых товаров: <code>{amount_pay}₽</code>",
                                     f"💰 Сумма к пополнению: <code>{needed_to_refill}₽</code>",
                                     reply_markup=products_addcart_confirm_finl(position_id, get_count))

            else:
                await message.answer(f"<b>❌ Неверное количество товаров.</b>\n{send_message}")
        else:
            await state.finish()
            await message.answer("<b>🎁 Товар который вы хотели купить, закончился</b>")
    else:
        await message.answer(f"<b>❌ Данные были введены неверно.</b>\n{send_message}")


# Подтверждение добавления товара в корзину
@dp.callback_query_handler(text_startswith="xaddcart_item", state="*")
async def user_addcart_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    get_count = int(call.data.split(":")[3])

    if get_action == "yes":
        await call.message.edit_text("<b>🔄 Ждите, товары подготавливаются</b>")

        get_position = get_positionx(position_id=position_id)
        get_items = get_itemsx(position_id=position_id)
        get_user = get_userx(user_id=call.from_user.id)

        amount_pay = int(get_position['position_price'] * get_count)

        if 1 <= get_count <= len(get_items):
            save_items, send_count, split_len = buy_itemx(get_items, get_count)

            # уточнение цены за количество в наличии
            if get_count != send_count:
                amount_pay = int(get_position['position_price'] * send_count)
                get_count = send_count

            receipt = get_unix()
            add_time = get_date()
            print(add_time)

            await call.message.delete()

            # if split_len == 0:
            #    await call.message.answer("\n\n".join(save_items), parse_mode="None")
            # else:
            #    for item in split_messages(save_items, split_len):
            #        await call.message.answer("\n\n".join(item), parse_mode="None")
            #        await asyncio.sleep(0.3)
            await asyncio.sleep(0.3)
            #users_order = get_user_orderx(get_user['user_id'])
            users_order = get_params_orderx(user_id=get_user['user_id'], order_state='created')
            print(users_order)
            alength = len(users_order)
            i = 0
            for i in range(alength):
                print(users_order[i]['order_id'])

            print('test2')
            #print(users_order['order_id'])

            if not users_order:
                create_orderx(call.from_user.id, get_user['user_login'], get_user['user_name'], 'created', str(add_time),
                              receipt)
                users_order = get_params_orderx(user_id=get_user['user_id'], order_state='created')
                #print(users_order['order_id'])
            print('test3')
            for i in range(alength):
                print(users_order[i]['order_id'])
            order_id = users_order[i]['order_id']
            # price = int(get_position['position_price'])
            add_order_itemx(order_id, position_id, get_count, get_position['position_price'], receipt, get_position['position_user_id'])
            # add_order_itemx(1, 1, 1, 1, 1)

            await call.message.answer(f"<b>✅ Вы успешно добавили товар(ы) в корзину</b>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🧾 Чек: <code>#{receipt}</code>\n"
                                      f"🎁 Товар: <code>{get_position['position_name']} | {get_count}шт | {amount_pay}₽</code>\n"
                                      f"🕰 Дата покупки: <code>{add_time}</code>",
                                      reply_markup=menu_frep(call.from_user.id))
        else:
            await call.message.answer("<b>🎁 Товар который вы хотели купить закончился или изменился.</b>",
                                      reply_markup=menu_frep(call.from_user.id))
    elif len(get_all_categoriesx()) >= 1:
        await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                     reply_markup=products_item_category_open_fp(0,0))
    else:
        await call.message.edit_text("<b>✅ Вы отменили покупку товаров.</b>")


# Удаление корзины
@dp.callback_query_handler(text_startswith="del_user_cart", state="*")
async def del_user_cart(call: CallbackQuery, state: FSMContext):
    await state.finish()
    await call.message.edit_text("<b> Удалить корзину и ее позиции?</b>",
                                 reply_markup=confirm_delete_user_cart_inl)

# Подтверждение удаления корзины
@dp.callback_query_handler(text_startswith="confirm_del_user_cart", state="*")
async def confirm_del_user_cart(call: CallbackQuery, state: FSMContext):

    user_id=call.from_user.id
    print(user_id)
    order=get_orderx(user_id=user_id)
    print(order)
    order_id=order['order_id']
    print(order_id)
    remove_ordersx(order_id=order_id)
    remove_orders_itemx(order_id=order_id)
    print("|||| -   - ||||")
    await call.message.edit_text("<b>✅ Вы удалили корзину.</b>")


#######################################################################################
# **************************  CHECK OUT CART ******************************************
#######################################################################################

# Оформление заказа по корзине - Адрес
@dp.callback_query_handler(text="checkout_start", state="*")
async def checkout_start(call: CallbackQuery, state: FSMContext):
    # user_id = int(call.data.split(":")[2])
    user_id = call.from_user.id
    get_user = get_userx(user_id=user_id)
    ub = get_user['user_balance']
    cart_sum = calc_cart_summ(user_id=user_id)
    delivery = 200
    order_total = cart_sum + delivery
    adr = geo = phone = 0
    users_order = get_user_orderx(user_id)
    order_id = users_order['order_id']
    touser_id = get_cart_sellersx(order_id)

    print(user_id)

    if get_user['user_address'] != "":
        print("Адрес есть")
        adr = 1
    if get_user['user_geocode'] != "":
        print("Геокод есть")
        geo = 1
    if get_user['user_phone'] != "":
        print("Телефон есть")
        phone = 1

    await call.message.answer(f"<b> Начинаем оформление заказа.</b>\n")

    if phone == 0:
        await state.set_state("enter_phone_auto")
        # await call.message.delete()
        # await call.message.answer(f"<b> Введите пожалуйста адрес доставки.</b>\n")

    if adr == 0:
        await state.set_state("enter_address_manualy")

    if ub < order_total:
        await state.set_state("user_balance_lower_than_cart")
        await call.message.delete()
        await call.message.answer(f"<b>Суммы на Вашем балансе не достаточно для оформления заказа.</b>\n"
                                  f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                  f" Баланс: <code>{ub}</code>\n"
                                  f" Сумма заказа: <code>{order_total}</code>\n",
                                  reply_markup=order_user_refill)
    else:
        await state.set_state("checkout_finish")
        await call.message.answer(f"<b>Продолхить оформление заказа:.</b>\n",
                                  reply_markup=checkout_step2_accept)

    #await state.finish()


# Принятие адреса для доставки
#@dp.message_handler(state="checkout_finish")
#async def checkout_finish(message: Message, state: FSMContext):
@dp.callback_query_handler(text="checkout_finish", state="*")
async def checkout_finish(call: CallbackQuery, state: FSMContext):
    print('checkout_finish')
#проверка - есть вопросы без ответов
    touser_id = call.from_user.id
    cm = get_user_messagesx(to_uid=touser_id, state='created')
    if len(cm) > 0:
        print(f"Messages present:{str(touser_id)}")
#статус заказа - delivery
    order_data = get_orderx(user_id=touser_id)
    order_id = order_data['order_id']
    os = update_orderx(order_id=order_id, order_state='delivery')
    await call.message.answer("<b>Начинаем доставку товара Вашей корзины.</b>")
    print('Сумма заказа на холде')
#холд суммы заказа
    validity = 5
    state = 'created'
    cart_sum = calc_cart_summ(user_id=touser_id)
    delivery = 200
    amount = cart_sum + delivery
    #amount = order_data['order_total']
    buyer = touser_id
    order_sellers = get_order_sellers(order_id)
    print(order_sellers)
    if(len(order_sellers)>1): print("продавцов более 1")
    #for seller in order_sellers:
    print(type(order_sellers))
    order_sellers = order_sellers.strip('[[')
    order_sellers = order_sellers.strip(']]')
    #seller=list(order_sellers)
    h = create_holdx(
        int(order_id),
        int(buyer),
        int(str(order_sellers)),
        int(amount),
        validity,
        state,
    )
    i = update_userx(user_id = buyer, user_hold = amount)
    await call.message.answer(f"<b>Денежные средства в размере {amount}р. успешно заблокированы до \n"
                              f"подтверждения получения покупателем товара.</b>")


# Оформление заказа по корзине - Адрес
@dp.callback_query_handler(text="submit_order", state="*")
async def submit_order(call: CallbackQuery, state: FSMContext):
    #buyer
    user_id = call.from_user.id
    buyer_data = get_userx(user_id=user_id)
    print(buyer_data)
    order_data = get_orderx(user_id=user_id)
    order_id = order_data['order_id']
    print(order_id)
    order_sellers = get_order_sellers(order_id)
    print(order_sellers)
    if(len(order_sellers)>1): print("продавцов более 1")
    #for seller in order_sellers:
    print(type(order_sellers))
    order_sellers = order_sellers.strip('[[')
    order_sellers = order_sellers.strip(']]')
    print(order_sellers)
    hold_data = get_orders_holdsx(order_id)
    #hold_data = hold_data.strip('[')
    #hold_data = hold_data.strip(']')
    print(hold_data[0]['seller'])
    #seller
    seller_data = get_userx(user_id=hold_data[0]['seller'])
    print(seller_data)
    #hold_data['seller']
#изменение статуса заказа   submitted
    os = update_orderx(order_id=order_id, order_state='submitted', active=0)
#снятие холда с суммы заказа
    a = update_holdx(order_id = order_id, state = 'released')
#транзакция
    seller_rest = int(seller_data['user_balance'])+int(hold_data[0]['amount'])
    buyer_rest = int(buyer_data['user_balance'])-int(hold_data[0]['amount'])
    #списание у покупателя
    b = update_userx(user_id, user_balance=buyer_rest)
    #пополнение у продавца
    c = update_userx(order_sellers, user_balance=seller_rest)

    receipt = get_unix()
    buy_time = get_date()

    await call.message.answer(f"<b>Покупка завершена, возвращайтесь!</b>\n")


@dp.callback_query_handler(text="reply_toorder_message", state="*")
async def reply_toorder_message(call: CallbackQuery, state: FSMContext):
    print('reply_toorder_message')
    # order_id = int(call.data.split(":")[1])
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    print(user_id)
    get_user = get_userx(user_id=user_id)

    # get_user = get_userx(user_id=call.from_user.id)
    await state.set_state("reply_toorder_message_fin")

    # await call.message.delete()
    await call.message.answer(f"<b>Пожалуйста, введите сообщение для покупателя:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")


# Принятие адреса для доставки
@dp.message_handler(state="reply_toorder_message_fin")
async def reply_toorder_message_fin(message: Message, state: FSMContext):
    print('reply_toorder_message_fin')
    # user_id = int(call.data.split(":")[1])
    # order_id = int(message.data.split(":")[1])
    user_id = message.from_user.id
    get_user = get_userx(user_id=user_id)
    users_order = get_user_orderx(user_id)
    order_id = users_order['order_id']
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        messagetxt = str(message.text)
        print(str(user_id) + messagetxt)
        touser_id = get_cart_sellersx(order_id)
        print(touser_id)

        add_messagex(from_id=user_id, to_id=touser_id, order_id = order_id, txtmessage=messagetxt, photo='', state='responded')

    await message.delete()
    await message.answer(f"<b>✅ Было отправлено следующее сообщение покупателю:</b>\n"
                         + messagetxt, reply_markup=cart_enter_message_finl(user_id))

    cm = get_user_messagesx(to_uid=touser_id, state='responded')
    if len(cm) > 0:
        print(f"Messages present:{str(touser_id)}")

    await dp.bot.send_message(
        chat_id=touser_id,
        text=f"Сообщение/вопрос по заказу от продавца:{messagetxt}",
        reply_markup=reply_order_message_finl(order_id),
    )



@dp.callback_query_handler(text="enter_message_manualy", state="*")
async def enter_message_manualy(call: CallbackQuery, state: FSMContext):
    print('enter_message_manualy')
    # order_id = int(call.data.split(":")[1])
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    print(user_id)
    get_user = get_userx(user_id=user_id)

    # get_user = get_userx(user_id=call.from_user.id)
    await state.set_state("enter_message_manualy_fin")

    # await call.message.delete()
    await call.message.answer(f"<b>Пожалуйста, введите сообщение для продавца:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")


# Принятие адреса для доставки
@dp.message_handler(state="enter_message_manualy_fin")
async def enter_message_manualy_fin(message: Message, state: FSMContext):
    print('enter_message_manualy_fin')
    # user_id = int(call.data.split(":")[1])
    # order_id = int(message.data.split(":")[1])
    user_id = message.from_user.id
    get_user = get_userx(user_id=user_id)
    users_order = get_user_orderx(user_id)
    order_id = users_order['order_id']
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        messagetxt = str(message.text)
        print(str(user_id) + messagetxt)
        touser_id = get_cart_sellersx(order_id)
        print(touser_id)

        add_messagex(from_id=user_id, to_id=touser_id, order_id = order_id, txtmessage=messagetxt, photo='', state='created')

    await message.delete()
    await message.answer(f"<b>✅ Было отправлено следующее сообщение продавцу:</b>\n"
                         + messagetxt, reply_markup=cart_enter_message_finl(user_id))

    cm = get_user_messagesx(to_uid=touser_id, state='created')
    if len(cm) > 0:
        print(f"Messages present:{str(touser_id)}")

    await dp.bot.send_message(
        chat_id=touser_id,
        text=f"Сообщение/вопрос по заказу от покупателя:{messagetxt}",
        reply_markup=reply_order_message_finl(order_id),
    )


@dp.callback_query_handler(text_startswith="enter_phone_auto", state="*")
async def enter_phone_man(call: CallbackQuery, state: FSMContext):
    print('enter_phone_auto')
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("enter_phone_auto_fin")

    button_phone = KeyboardButton(text="Делись!", request_contact=True)
    keyboard = ReplyKeyboardMarkup(row_width=1, resize_keyboard=True, one_time_keyboard=True)
    keyboard.add(button_phone)
    await call.message.answer(
        "<b>✅ Вы можете поделиться своим номером телефона.</b>",
        reply_markup=menu_frep(message.from_user.id),
    )

    # get_user = get_userx(user_id=call.from_user.id)

    # await state.finish()

    # await Person.contact.set()

    '''await call.message.delete()
    await call.message.answer(f"<b>🎁 Введите Ваш номер телефона:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")'''


@dp.message_handler(content_types=['contact'], state="enter_phone_auto_fin")  # content_types=ContentType.CONTACT,
async def contacts(message: Message, state: FSMContext):
    phone = message.contact.phone_number

    print(phone)
    phone = str(message.text)
    phone = message.contact.phone_number
    update_userx(message.from_user.id, user_phone=phone)

    await message.answer(f"Ваш номер сохранен в Вашем личном кабинете: {message.contact.phone_number}",
                         reply_markup=ReplyKeyboardRemove())  # , reply_markup=types.ReplyKeyboardRemove()
    await state.finish()

    await message.answer(f"<b>✅ Номер телефон был успешно изменен на следующий:</b>\n"
                         + str(phone), reply_markup=accept_saved_phone(message.from_user.id))


'''
    await message.answer("🔸 Мы снова с Вами!.\n"
                     "🔸 Если не появились вспомогательные кнопки\n"
                     "▶ Введите /start",
                     reply_markup=menu_frep(message.from_user.id)) '''


# Принятие адреса для доставки
@dp.message_handler(state="enter_phone_auto_fin2")
async def user_get_phone(message: Message, state: FSMContext):
    print('enter_phone_auto_fin')
    # user_id = int(call.data.split(":")[1])
    phone = message.contact.phone_number
    # phone = int(message.data.split(":")[1])
    get_user = get_userx(user_id=message.from_user.id)
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    print(phone)

    # if message.text:
    #    phone = str(message.text)
    #    update_userx(message.from_user.id, user_phone=phone)

    await message.delete()
    await message.answer(f"<b>✅ Номер телефон был успешно изменен на следующий:</b>\n"
                         + phone, reply_markup=accept_saved_phone(message.from_user.id))


@dp.callback_query_handler(text_startswith="enter_phone_manualy", state="*")
async def enter_phone_man(call: CallbackQuery, state: FSMContext):
    print('enter_phone_manualy')
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)

    # get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("enter_phone_manualy_fin")

    await call.message.delete()
    await call.message.answer(f"<b>🎁 Введите Ваш номер телефона:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")


# Принятие адреса для доставки
@dp.message_handler(state="enter_phone_manualy_fin")
async def user_enter_phone(message: Message, state: FSMContext):
    print('enter_phone_manualy_fin')
    # user_id = int(call.data.split(":")[1])
    get_user = get_userx(user_id=message.from_user.id)
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        phone = str(message.text)
        update_userx(message.from_user.id, user_phone=phone)

    await message.delete()
    await message.answer(f"<b>✅ Номер телефон был успешно изменен на следующий:</b>\n"
                         + phone, reply_markup=accept_saved_phone(message.from_user.id))


@dp.callback_query_handler(text_startswith="enter_address_manualy", state="*")
async def enter_address_man(call: CallbackQuery, state: FSMContext):
    print('enter_address_manualy')
    # user_id = int(call.data.split(":")[1])
    # user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)

    # get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("enter_address_manualy_fin")

    await call.message.delete()
    await call.message.answer(f"<b>🎁 Введите Ваш адрес:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")


# Принятие адреса для доставки
@dp.message_handler(state="enter_address_manualy_fin")
async def user_enter_addr(message: Message, state: FSMContext):
    print('enter_address_manualy_fin')
    #user_id = int(message.split(":")[1])
    user_id = message.from_user.id
    get_user = get_userx(user_id=user_id)
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        address = str(message.text)
        update_userx(message.from_user.id, user_address=address)

    await message.delete()
    await message.answer(f"<b>✅ Адрес доставки был успешно изменен на следующий:</b>\n"
                         + address, reply_markup=accept_saved_adr(message.from_user.id))


# Выбор количества товаров для покупки
@dp.callback_query_handler(text_startswith="buy_item_select", state="*")
async def buy_item_select(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])

    get_position = get_positionx(position_id=position_id)
    get_items = get_itemsx(position_id=position_id)
    get_user = get_userx(user_id=call.from_user.id)

    if get_position['position_price'] != 0:
        get_count = int(get_user['user_balance'] / get_position['position_price'])
        get_count = min(get_count, len(get_items))
    else:
        get_count = len(get_items)

    if int(get_user['user_balance']) >= int(get_position['position_price']):
        if get_count == 1:
            await state.update_data(here_cache_position_id=position_id)
            await state.finish()

            await call.message.delete()
            await call.message.answer(f"<b>🎁 Вы действительно хотите купить товар(ы)?</b>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                      f"📦 Количество: <code>1шт</code>\n"
                                      f"💰 Сумма к покупке: <code>{get_position['position_price']}₽</code>",
                                      reply_markup=products_confirm_finl(position_id, 1))
        elif get_count >= 1:
            await state.update_data(here_cache_position_id=position_id)
            await state.set_state("here_item_count")

            await call.message.delete()
            await call.message.answer(f"<b>🎁 Введите количество товаров для покупки</b>\n"
                                      f"▶ От <code>1</code> до <code>{get_count}</code>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n"
                                      f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>")
        else:
            await call.answer("🎁 Товаров нет в наличии")
    else:
        #await call.answer("❗ У вас недостаточно средств. Пополните баланс", True)
        #await call.message.delete()
        await call.message.answer(
            "<b>❗ У вас недостаточно средств. Пополните баланс</b>",
            reply_markup=charge_button_add(0),
        )


# -------------------------------------------------------------------------------------
# Выбор количества товаров для покупки
@dp.callback_query_handler(text_startswith="buy_item_select", state="*")
async def user_purchase_select(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])

    get_position = get_positionx(position_id=position_id)
    get_items = get_itemsx(position_id=position_id)
    get_user = get_userx(user_id=call.from_user.id)

    if get_position['position_price'] != 0:
        get_count = int(get_user['user_balance'] / get_position['position_price'])
        get_count = min(get_count, len(get_items))
    else:
        get_count = len(get_items)

    if int(get_user['user_balance']) >= int(get_position['position_price']):
        if get_count == 1:
            await state.update_data(here_cache_position_id=position_id)
            await state.finish()

            await call.message.delete()
            await call.message.answer(f"<b>🎁 Вы действительно хотите купить товар(ы)?</b>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                      f"📦 Количество: <code>1шт</code>\n"
                                      f"💰 Сумма к покупке: <code>{get_position['position_price']}₽</code>",
                                      reply_markup=products_confirm_finl(position_id, 1))
        elif get_count >= 1:
            await state.update_data(here_cache_position_id=position_id)
            await state.set_state("here_item_count")

            await call.message.delete()
            await call.message.answer(f"<b>🎁 Введите количество товаров для покупки</b>\n"
                                      f"▶ От <code>1</code> до <code>{get_count}</code>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n"
                                      f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>")
        else:
            await call.answer("🎁 Товаров нет в наличии")
    else:
        #await call.answer("❗ У вас недостаточно средств. Пополните баланс", True)
        #await call.message.delete()
        await call.message.answer(
            "<b>❗ У вас недостаточно средств. Пополните баланс</b>",
            reply_markup=charge_button_add(0),
        )


# Принятие количества товаров для покупки
@dp.message_handler(state="here_item_count")
async def user_purchase_select_count(message: Message, state: FSMContext):
    position_id = (await state.get_data())['here_cache_position_id']

    get_position = get_positionx(position_id=position_id)
    get_user = get_userx(user_id=message.from_user.id)
    get_items = get_itemsx(position_id=position_id)

    if get_position['position_price'] != 0:
        get_count = int(get_user['user_balance'] / get_position['position_price'])
        get_count = min(get_count, len(get_items))
    else:
        get_count = len(get_items)

    send_message = f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                   f"🎁 Введите количество товаров для покупки\n" \
                   f"▶ От <code>1</code> до <code>{get_count}</code>\n" \
                   f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                   f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n" \
                   f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>"

    if message.text.isdigit():
        get_count = int(message.text)
        amount_pay = int(get_position['position_price']) * get_count

        if len(get_items) >= 1:
            if 1 <= get_count <= len(get_items):
                if int(get_user['user_balance']) >= amount_pay:
                    await state.finish()
                    await message.answer(f"<b>🎁 Вы действительно хотите купить товар(ы)?</b>\n"
                                         f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                         f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                         f"📦 Количество: <code>{get_count}шт</code>\n"
                                         f"💰 Сумма к покупке: <code>{amount_pay}₽</code>",
                                         reply_markup=products_confirm_finl(position_id, get_count))
                else:
                    await message.answer(
                        f"<b>❌ Недостаточно средств на счете.</b>\n{send_message}"
                    )
            else:
                await message.answer(f"<b>❌ Неверное количество товаров.</b>\n{send_message}")
        else:
            await state.finish()
            await message.answer("<b>🎁 Товар который вы хотели купить, закончился</b>")
    else:
        await message.answer(f"<b>❌ Данные были введены неверно.</b>\n{send_message}")


# Подтверждение покупки товара
@dp.callback_query_handler(text_startswith="xbuy_item", state="*")
async def user_purchase_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    get_count = int(call.data.split(":")[3])

    if get_action == "yes":
        await call.message.edit_text("<b>🔄 Ждите, товары подготавливаются</b>")

        get_position = get_positionx(position_id=position_id)
        get_items = get_itemsx(position_id=position_id)
        get_user = get_userx(user_id=call.from_user.id)

        amount_pay = int(get_position['position_price'] * get_count)

        if 1 <= get_count <= len(get_items):
            if int(get_user['user_balance']) >= amount_pay:
                save_items, send_count, split_len = buy_itemx(get_items, get_count)

                if get_count != send_count:
                    amount_pay = int(get_position['position_price'] * send_count)
                    get_count = send_count

                receipt = get_unix()
                buy_time = get_date()

                await call.message.delete()
                if split_len == 0:
                    await call.message.answer("\n\n".join(save_items), parse_mode="None")
                else:
                    for item in split_messages(save_items, split_len):
                        await call.message.answer("\n\n".join(item), parse_mode="None")
                        await asyncio.sleep(0.3)

                update_userx(get_user['user_id'], user_balance=get_user['user_balance'] - amount_pay)
                add_purchasex(get_user['user_id'], get_user['user_login'], get_user['user_name'], receipt, get_count,
                              amount_pay, get_position['position_price'], get_position['position_id'],
                              get_position['position_name'], "\n".join(save_items), buy_time, receipt,
                              get_user['user_balance'], int(get_user['user_balance'] - amount_pay))

                await notify(dp, f"Продана позиция: {get_position['position_name']}")
                await call.message.answer(f"<b>✅ Вы успешно купили товар(ы)</b>\n"
                                          f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                          f"🧾 Чек: <code>#{receipt}</code>\n"
                                          f"🎁 Товар: <code>{get_position['position_name']} | {get_count}шт | {amount_pay}₽</code>\n"
                                          f"🕰 Дата покупки: <code>{buy_time}</code>",
                                          reply_markup=menu_frep(call.from_user.id))
            else:
                await call.message.answer("<b>❗ На вашем счёте недостаточно средств</b>")
        else:
            await call.message.answer("<b>🎁 Товар который вы хотели купить закончился или изменился.</b>",
                                      reply_markup=menu_frep(call.from_user.id))
    elif len(get_all_categoriesx()) >= 1:
        await call.message.edit_text("<b>🎁 Выберите нужный вам товар:</b>",
                                     reply_markup=products_item_category_open_fp(0,0))
    else:
        await call.message.edit_text("<b>✅ Вы отменили покупку товаров.</b>")



tgbot >handlers>user_menu_i18n.py:
# - *- coding: utf- 8 - *-
#from pathlib import Path
import os
import asyncio
import json
import gettext
from pathlib import Path
from contextvars import ContextVar
#import i18n

from aiogram.dispatcher import FSMContext
from aiogram import Bot
from aiogram import Dispatcher
from aiogram.utils.deep_linking import get_start_link, decode_payload
from aiogram.types import CallbackQuery, Message, KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove
from aiogram.contrib.middlewares.i18n import I18nMiddleware
from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR
#from aiogram.contrib.middlewares.i18n import I18nMiddleware
from tgbot.middlewares.i18n import I18nMiddleware
#from tgbot.middlewares.i18n import setup_middleware

from tgbot.keyboards.inline_admin import category_edit_open_finl, position_edit_open_finl, category_edit_delete_finl, \
    position_edit_clear_finl, position_edit_delete_finl, payment_choice_finl, artist_edit_open_finl, select_place_finl
from tgbot.keyboards.inline_user import user_support_finl, products_open_finl, products_confirm_finl, \
    products_addcart_confirm_finl, payment_as_choice_finl, accept_saved_adr, accept_saved_phone, \
    cart_enter_message_finl, give_number_inl, reply_order_message_finl, refill_choice_finl, charge_button_add, \
    switch_category_shop_finl, shop_creation_request_finl, event_open_finl, enter_promocode_finl, cart_open_created_finl, \
    cart_open_delivery_finl, edit_delivery_settings_finl, position_select_type_finl, checkout_step2_accept_finl, confirm_cart_del_finl
from tgbot.keyboards.inline_z_all import category_remove_confirm_inl, position_remove_confirm_inl, \
    item_remove_confirm_inl, close_inl, confirm_delete_user_cart_inl
from tgbot.keyboards.inline_z_all import refill_open_inl, profile_open_inl, checkout_step2_accept, order_user_refill, partners_list_inl, profile_seller_open_inl
from tgbot.keyboards.inline_z_page import *
from tgbot.keyboards.reply_z_all import finish_load_rep
from tgbot.keyboards.reply_z_all import menu_frep, items_sh_frep, events_frep
from tgbot.keyboards.shop_keyboards import shop_edit_open_fp
from tgbot.loader import dp
from tgbot.loader import bot
from tgbot.services.api_qiwi import QiwiAPI
from tgbot.services.api_sqlite_shop import *
from tgbot.services.api_sqlite import *
from tgbot.utils.const_functions import get_date, split_messages, get_unix, clear_list
from tgbot.utils.misc.bot_filters import IsShopAdmin, IsAdminorShopAdmin, IsAdmin
from tgbot.utils.misc_functions import user_refill_my, calc_cart_summ, calc_order_summ, open_cart_orders, open_profile_my, upload_text, get_faq, send_admins
from tgbot.utils.misc_functions import get_position_admin, upload_text, get_artist_admin
from tgbot.keyboards.location_keyboards import geo_1_kb
from tgbot.services.location_function import update_position_city, get_city_info, is_location, update_artist_city
from tgbot.services.location_stat import geo_choice
from tgbot.keyboards.location_keyboards import geo_11_kb


#i18n
#I18N_DOMAIN = 'mybot'
#BASE_DIR = Path(__file__).parent
#BASE_DIR = 'tgbot' #Path(__file__).parent
#rd = Path(__file__).parents
#BASE_DIR = rd[1]
#LOCALES_DIR = f"{BASE_DIR}{os.sep}locales"
#LOCALES_DIR = f"{os.sep}locales"
#print(LOCALES_DIR)
# Setup i18n middleware
#ctx_locale = Locale('ru')
print(":")
#i18n = I18nMiddleware(LOCALES_DIR)
#dp.middleware.setup(i18n)
#i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
#dp.middleware.setup(i18n)
#dp.middleware.setup(i18n)
#I18nMiddleware.setup_middlewares(i18n)
##print(i18n)
# Alias for gettext method
##_ = i18n.gettext
#i18n = setup_middleware(dp)
#_ = i18n.gettext
#print(i18n.find_locales())

#_ = i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
#_ = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
#_ = i18n
#lang1 = gettext.translation('mybot', languages=['ru'])
#lang1.install()
#t = gettext.translation('mybot', LOCALES_DIR, fallback=True)
#_ = t.gettext
#t = gettext.translation('mybot', LOCALES_DIR, fallback=True)
#_ = t.gettext
#print(i18n.get_user_locale())

#print(i18n.gettext("<b>📁 Enter type of goods, what you want to sell:</b>", locale='ru'))

#print(i18n.t("<b>📁 Enter type of goods, what you want to sell:</b>"))
#translate = gettext.translation('mybot', LOCALES_DIR, fallback=True)
#_ = translate.gettext
#translate = gettext.translation('mybot', LOCALES_DIR, fallback=True)
#translate = current.install()
#_ = translate.gettext

#print(i18n.find_locales())
#print(i18n.get_user_locale())
#print(i18n.reload())
#print(i18n.available_locales())
#print(i18n.trigger(action='pre_process', args={}))
#i18n.add_translation('<b>📁 Enter type of goods, what you want to sell:</b>', 'Тест')
#print(i18n.t("<b>📁 Enter type of goods, what you want to sell:</b>"))

i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
dp.middleware.setup(i18n)

_ = i18n


async def notify(dp: Dispatcher, msg):
    print('Уведомление!')
    await send_admins(msg, markup="default")
################################################################################################

# Заявка на продавца магазина
# Открытие товаров
@dp.message_handler(text="Я продавец", state="*")
async def user_seller_request(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']
    print(lang)

    await state.set_state("here_seller_request_direction")
    #await message.answer("<b>📁 Enter type of goods, what you want to sell:</b>")
    await message.answer(_("<b>📁 Введите тип товара, который Вы будете продавать:</b>", locale=lang)) #, locale=locale.language
    #await message.answer(_("<b>📁 Введите вид товаров или услуг, которые Вы предлагаете:</b>"))

# Открытие товаров
@dp.message_handler(text="Админ Афиши", state="*")
async def user_seller_request(message: Message, state: FSMContext):
    # await state.finish()
    await state.set_state("here_afisha_admin_request_direction")
    await message.answer(_("<b>📁 Опишите пожалуйста события или среду, которые Вы создаете:</b>", locale=lang))

# Управление событиями
@dp.message_handler(IsAdminorShopAdmin(), text="🎫 Управление событиями 🖍", state="*")
async def admin_products(message: Message, state: FSMContext):
    await state.finish()
    await message.answer("<b>🎫 Редактирование событий.</b>", reply_markup=events_frep())

# Управление товарами
@dp.message_handler(IsShopAdmin(), text="🎁 Управление товарами дмаг.🖍", state="*")
async def shopadmin_products(message: Message, state: FSMContext):
    await state.finish()
    await message.answer(_("<b>🎁 Редактирование товаров дмаг.</b>", locale=lang), reply_markup=items_sh_frep())

@dp.message_handler(text="🗃 Создать категорию ➕", state="*")
async def product_category_create(message: Message, state: FSMContext):
    await state.finish()
    await state.set_state("here_category_name")
    await message.answer(_("<b>🗃 Введите название для категории 🏷</b>", locale=lang))

# Начальные категории для изменения позиции
@dp.message_handler(IsShopAdmin(), text="📁 Изменить позицию 🖍", state="*")  # !!!!!!!   Изменить позицию
async def product_position_edit(message: Message, state: FSMContext):
    print('📁 Изменить позицию 🖍  user_menu.py 56')
    await state.finish()

    await message.answer(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                         reply_markup=position_edit_category_open_fp(0))

# Открытие товаров
@dp.message_handler(text="🎁 Купить", state="*")
async def user_shop(message: Message, state: FSMContext):
    print('Открытие категорий товаров  user_menu.py 166')
    await state.finish()

    get_settings = get_settingsx()
    if(get_settings['type_trade'] != 'digital'):
        city_id = get_city_user(message.from_user.id)[0]

        if len(get_category_in_city(city_id)) >= 1:
            await message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                 reply_markup=products_item_category_swipe_fp(0, city_id))
        else:
            await message.answer(_("<b>🎁 В вашем городе товаров нет, выберите другой город</b>\n\n"
                                 "🏙 Изменить город вы можете в личном кабинете"), locale=lang)
    else:
        await message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                             reply_markup=products_item_category_swipe_fp(0,0))

# Открытие товаров
@dp.callback_query_handler(text_startswith="privateMarket", state="*")
async def private_user_shop(call: CallbackQuery, state: FSMContext):
    print('Открытие барахолки user_menu.py 186')
    await state.finish()
    category_id, remover, level, parent, city_id = 0, 0, 0, 0, 0
    print("<*|||privateMarket|||*>")
    action = "open"
    user_id = call.from_user.id
    lang = get_user_lang(user_id)['user_lang']
    print(lang)

    get_settings = get_settingsx()
    if(get_settings['type_trade'] != 'digital'):
        city_id = get_city_user(call.from_user.id)[0]

        if len(get_category_in_city(city_id)) >= 1:
            await call.message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                 reply_markup=position_people_create_open_fp(category_id, remover, level, parent, city_id, action))
        else:
            await call.message.answer(_("<b>🎁 В вашем городе товаров нет, выберите другой город</b>\n\n"
                                 "🏙 Изменить город вы можете в личном кабинете", locale=lang))
    else:
        await call.message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                             reply_markup=position_people_create_open_fp(category_id, remover, level, parent, city_id, action))


# Открытие товаров
@dp.message_handler(text="🌐 Продать", state="*")
async def user_shop(message: Message, state: FSMContext):
    print('Открытие категорий товаров  user_menu.py 65')
    await state.finish()

    source = "people"
    action = "create"

    get_settings = get_settingsx()
    if (get_settings['type_trade'] != 'digital'):
        city_id = get_city_user(message.from_user.id)[0]
                #await message.answer("<b>🎁 Выберите нужный вам товар:</b>",
                #                     reply_markup=products_item_category_swipe_fp(0, city_id))
            #else:
            #    await message.answer("<b>🎁 В</b>\n\n"
            #                         "🏙 Изменить город вы можете в личном кабинете")
    #get_categories = get_category_in_city(city_id)
    #if len(get_category_in_city(city_id)) >= 1:
    #if len(get_all_shopx()) >= 1:
    await message.answer(_("<b>📁 Выберите категорию для Вашей позиции</b>", locale=lang),
                         reply_markup=position_people_create_open_fp(0, 0, 0, 0, city_id, action))

# Открытие товаров
@dp.message_handler(text="🎁 Магазины", state="*")
async def user_shop(message: Message, state: FSMContext):
    print('Открытие магазинов товаров  user_menu.py 65')
    await state.finish()

    get_settings = get_settingsx()
    if(get_settings['type_trade'] != 'digital'):
        city_id = get_city_user(message.from_user.id)[0]
        #get_categories = get_category_in_city(city_id)
        if len(get_shops_on_city(city=city_id)) >= 1:
            await message.answer(_("<b>🎁 Выберите нужный вам магазин:</b>", locale=lang),
                                 reply_markup=products_item_shop_swipe_fp(0, city_id))
        else:
            await message.answer(_("<b>🎁 В вашем городе товаров нет, выберите другой город</b>\n\n"
                                 "🏙 Изменить город вы можете в личном кабинете"), locale=lang)
    else: #if len(get_all_categoriesx()) >= 1
        await message.answer(_("<b>🎁 Выберите нужный вам магазин:</b>", locale=lang),
                             reply_markup=products_item_shop_swipe_fp(0, 0))


# Открытие товаров
@dp.message_handler(text="Афиша", state="*")
async def user_afisha(message: Message, state: FSMContext):
    print('Открытие афишы  user_menu.py 115')
    await state.finish()

    if is_location(message.from_user.id) == True:
        #await message.answer("🔸 Афиша работает только в случае, если у Вас выбран город.\n"
        #                 "🔸 Если не появились вспомогательные кнопки\n"
        #                 "▶ Введите /start",
        #                 reply_markup=menu_frep(message.from_user.id))
        city_id = get_city_user(message.from_user.id)[0]
        print(city_id)
        if len(get_events_in_cityx(city_id, flagallc=1, position_type=1)) >= 1:
            await message.answer(_("<b>Выберите интересное для Вас:</b>", locale=lang),
                                 reply_markup=events_in_city_swipe_fp(0, city_id))

    else:
        await geo_choice.location.set()
        await message.answer('Отправьте локацию или выберите город из списка', reply_markup=geo_11_kb())

# события в заведении
# заведения в городе
# события в городе
'''
    get_settings = get_settingsx()
    if(get_settings['type_trade'] != 'digital'):
        city_id = get_city_user(message.from_user.id)[0]
        #get_categories = get_category_in_city(city_id)
        if len(get_events_in_city(city_id=city_id)) >= 1:
            await message.answer("<b>Выберите интересное для Вас:</b>",
                                 reply_markup=events_in_city_swipe_fp(0, city_id))
        else:
            await message.answer("<b>🎁 В вашем городе товаров нет, выберите другой город</b>\n\n"
                                 "🏙 Изменить город вы можете в личном кабинете")
    else: #if len(get_all_categoriesx()) >= 1
        await message.answer("<b>Выберите интересное для Вас:</b>",
                             reply_markup=events_in_city_swipe_fp(0, 0))'''


# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="events_city_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    city_id = int(call.data.split(":")[2])

    if remover == 0:
        await call.message.answer(_("<b>События в городе, выберите что-нибудь интересное:</b>", locale=lang),
                                  reply_markup=events_in_city_swipe_fp(remover, city_id))
    else:
        await call.message.edit_text(_("<b>События в городе, выберите что-нибудь интересное:</b>", locale=lang),
                                     reply_markup=events_in_city_swipe_fp(remover, city_id))

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="events_place_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    place_id = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])

    if remover == 0:
        await call.message.answer(_("<b>События в месте, выберите что-нибудь интересное:</b>", locale=lang),
                                  reply_markup=events_in_place_swipe_fp(remover, place_id, city_id))
    else:
        await call.message.edit_text(_("<b>События в месте, выберите что-нибудь интересное:</b>", locale=lang),
                                     reply_markup=events_in_place_swipe_fp(remover, place_id, city_id))


# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="places_city_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    city_id = int(call.data.split(":")[2])

    await call.message.edit_text(_("<b>События в городе, выберите что-нибудь интересное:</b>", locale=lang),
                                 reply_markup=places_in_city_swipe_fp(remover, city_id))

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="open_inline_support", state="*")
async def open_inline_support(call: CallbackQuery, state: FSMContext):
    user_support = get_settingsx()['misc_support']
    if str(user_support).isdigit():
        get_user = get_userx(user_id=user_support)
        await call.message.answer(_("<b>Напишите, что Вы хотите добавить, мы добавим.:</b>", locale=lang),
                                  reply_markup=user_support_finl(get_user['user_login']))
        return
    else:
        update_settingsx(misc_support="None")
        await message.answer(f"☎ Поддержка. Измените их в настройках бота.\n➖➖➖➖➖➖➖➖➖➖\n{BOT_DESCRIPTION}",
                             disable_web_page_preview=True)

# Открытие позиции для покупки
@dp.callback_query_handler(text_startswith="book_event_open:", state="*")
async def user_purchase_position_open(call: CallbackQuery, state: FSMContext):
    print('Карточка товара: user_menu.py  152')
    event_id = int(call.data.split(":")[1])
    place_id = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])

    #category_id = int(call.data.split(":")[2])
    #remover = int(call.data.split(":")[3])
    #city_id = int(call.data.split(":")[4])
    #print(position_id, category_id, remover, city_id)

    city_id = get_city_user(call.from_user.id)[0]
    get_event = get_eventxx(event_id=event_id)
    #get_category = get_categoryx(category_id=category_id)
    #get_items = get_itemsx(position_id=position_id)
    get_settings = get_settingsx()
    print(get_event)

    if get_event['event_description'] == "0":
        text_description = ""
    else:
        text_description = f"\n📜 Описание:\n" \
                           f"{get_event['event_description']}"

    send_msg = f"<b>Мероприятие:</b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"🏷 Название: <code>{get_event['event_name']}</code>\n" \
               f"🏙 Город: <code>{get_event['event_city']}</code>\n" \
               f"{text_description}"

    #f"📦 Остаток: <code>{len(get_items)}шт</code>" \
    print(get_settings['type_trade'])
    tt = get_settings['type_trade']

    if (
        tt != "digital"
        and len(get_event['event_photo']) >= 5
        or tt == "digital"
        and len(get_position['event_photo']) >= 5
    ):
        print("\|")
        await call.message.delete()
        await call.message.answer_photo(get_event['event_photo'],
                                        send_msg, reply_markup=event_open_finl(event_id, 0, place_id, city_id))
    else:
        print("\||")
        await call.message.edit_text(send_msg,
                                     reply_markup=event_open_finl(event_id, 0, place_id, city_id))

# Открытие пополнения счета
@dp.message_handler(text="💰 Пополнить", state="*")
async def user_refill_b(message: Message, state: FSMContext):
    await state.finish()
    await message.answer(user_refill_my(message.from_user.id), reply_markup=refill_open_inl)

#refiil_way(message.from_user.id)

# Открытие профиля
@dp.message_handler(text="👤 Профиль", state="*")
async def user_profile(message: Message, state: FSMContext):
    get_user = get_userx(user_id=message.from_user.id)
    if get_user['user_role'] in ["ShopAdmin", "Admin"]:
        await state.finish()
        await message.answer(open_profile_my(message.from_user.id), reply_markup=profile_seller_open_inl)
    else:
        await state.finish()
        await message.answer(open_profile_my(message.from_user.id), reply_markup=profile_open_inl)

# Открытие профиля
@dp.message_handler(text="Партнеры", state="*")
async def open_partners_list(message: Message, state: FSMContext):
    await state.finish()
    await message.answer("Наши славные партнеры:", reply_markup=partners_list_inl)

# Открытие корзины
@dp.message_handler(text=['🧮 Корзина', '🚛 Заказы'], state="*")
async def user_cart(message: Message, state: FSMContext):
    await state.finish()
    orderdata = []
    if message.text == '🧮 Корзина': #заказы покупателя
        user_id = message.from_user.id
        orderdata = get_params_orderx(user_id=user_id)
        if len(orderdata) == 0:
            await message.answer("В Вашей корзине пока нет товаров. Посмотрите категории[кнопка Купить] или товары Магазинов.")

    if message.text == '🚛 Заказы': #заказы продавца | представление от заказа к строке
        user_id = message.from_user.id
        if user_id in get_userx(user_role='ShopAdmin'):
            orderdata = get_params_orderxx(owner_uid=user_id)
            #orderdata = get_seller_orderx(owner_uid=adminuser_id)
        elif user_id in get_admins():
            orderdata = get_alladmin_orderx()
        else:
            await message.answer("Недостаточно доступа для просмотра заказов!")

    if message.text == '🚛 Заказы А': #заказы админа площадки
        user_id = message.from_user.id
        orderdata = get_params_orderxx(owner_uid=user_id)

    print(orderdata)

    for order in orderdata:
        print(order['order_state'])
        if order['order_state'] == 'delivery':
            await message.answer(open_cart_orders(order['order_id'], user_id), reply_markup=cart_open_delivery_finl(order_id=order['order_id']))
        if order['order_state'] == 'created':
            await message.answer(open_cart_orders(order['order_id'], user_id), reply_markup=cart_open_created_finl(order_id=order['order_id']))
        if order['order_state'] == 'submited':
            await message.answer(f"<b>Активных заказов нет.</b>\n")

# Открытие FAQ
@dp.message_handler(text=["ℹ FAQ", "/faq"], state="*")
async def user_faq(message: Message, state: FSMContext):
    await state.finish()

    send_message = get_settingsx()['misc_faq']
    if send_message == "None":
        send_message = f"ℹ Информация. Измените её в настройках бота.\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n{BOT_DESCRIPTION}"

    await message.answer(get_faq(message.from_user.id, send_message), disable_web_page_preview=True)

###############################################################################################
##### ***** ###### *****         СОЗДАНИЕ АРТИСТА
###############################################################################################
# -----------------------------------------------------------------------------------------------------------
# Создание нового магазина
@dp.message_handler(IsAdminorShopAdmin(), text="🏪 Создать артиста ➕", state="*")
async def product_shop_create(message: Message, state: FSMContext):
    await state.finish()
    print("user_menu - создание артиста")
    print("-")
    user_id = message.from_user.id
    print(user_id)
    my_artist = check_user_artist_exist(user_id)
    print(my_artist)
    if my_artist == True:
        print("|")
        await message.answer(f"<b>🏪 Артист уже существует 🏷 Выбирайте его в каталоге при создании позиций: {my_artist} </b>", parse_mode='HTML')
    else:
        print("||")
        await state.set_state("here_artist_name")
        await message.answer(_("<b>🏪 Введите название артиста или коллектива 🏷</b>", locale=lang), parse_mode='HTML')


# принятие названия магазина, запрос описания
@dp.message_handler(IsAdminorShopAdmin(), state="here_artist_name")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        print("admin_products_shop - создание артиста")
        await state.update_data(data={'name': message.text})
        await state.set_state('here_artist_description')
        await message.answer(_("<b>🏪 Введите Bio артиста 📜</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')
    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "🏪 Введите название для артиста 🏷", locale=lang), parse_mode='HTML')

# принятие описания магазина, запрос адреса
@dp.message_handler(IsAdminorShopAdmin(), state="here_artist_description")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 600:
        if message.text == '0':
            await state.update_data(data={'description': 'None'})
        else:
            await state.update_data(data={'description': message.text})
        await state.set_state('here_artist_webadress')
        await message.answer(_("<b>🏪 Отправьте веб-сайт артиста 📍</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


    else:
        await message.answer(_("<b>❌ Описание не может превышать 600 символов.</b>\n"
                             "🏪 Введите новое Bio для артиста 📜\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


# принятие адреса магазина, запрос номера
@dp.message_handler(IsAdminorShopAdmin(), state="here_artist_webadress")
async def product_category_create_name(message: Message, state: FSMContext):
    if message.text == '0':
        await state.update_data(data={'webaddress': 'None'})
    else:
        await state.update_data(data={'webaddress': message.text})
    await state.set_state('here_artist_logo')
    await message.answer(_("<b>🏪 Отправьте лого артиста 📷</b>\n"
                         "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')

# принятие лого магазина, запрос лого
@dp.message_handler(IsAdminorShopAdmin(), content_types=['photo','text'], state="here_artist_logo")
async def product_category_create_logo(message: Message, state: FSMContext):
    logo = message.photo[0].file_id if message.content_type == 'photo' else None
    async with state.proxy() as data:
        print(data)
        name = data['name']
        description = data['description']
        webaddress = data['webaddress']

    await state.finish()

    type_trade = get_settingsx()
    if type_trade['type_trade'] != "digital":
        city = get_city_user3(message.from_user.id)
        print(city)
        city_id = city[0]
        geocode = city[1]
        city_name = city[2]
    else:
        city_id = 0
        geocode = ''
        city_name = ''
    add_artistx(name, description, webaddress, message.from_user.id, logo, city_id, geocode, city_name)
    await message.answer(_("<b>🏪 Карточка артиста была успешно создана ✅</b>", locale=lang), parse_mode='HTML')


# -----------------------------------------------------------------------------------------------------------
# Открытие страниц выбора магазина для редактирования
@dp.message_handler(IsAdminorShopAdmin(), text="🏪 Изменить артиста 🖍", state="*")
async def artist_list_edit(message: Message, state: FSMContext):
    await state.finish()
    user_id=message.from_user.id
    #if get_my_shopx(user_id):
    artists = get_artistsxx(admin=user_id)
    #shops = get_all_shopx()
    #shops = get_all_shopx()
    #print(f'shops {shops}')
    print(artists)

    if len(artists) >= 1:
        await message.answer("<b>🏪 Выберите артиста для изменения 🖍</b>",
                             reply_markup=artist_edit_open_fp(0, user_id))
    else:
        await message.answer("<b>🏪 Ваши артисты отсутствуют 🖍</b>")


# Смена страницы выбора магазина
@dp.message_handler(IsAdminorShopAdmin(), text_startswith="change_artist_edit_pg:", state="*")
async def artist_list_edit_pg(call: CallbackQuery, state: FSMContext):
    await state.finish()
    remover = int(str(call.data).split(':')[1])
    #user_id = message.from_user.id
    user_id = int(str(call.data).split(':')[2])
    artists = get_artistsxx(admin=user_id)

    if len(artists) >= 1:
        await call.message.answer("<b>🏪 Выберите артиста для изменения 🖍</b>",
                                  reply_markup=artist_edit_open_fp(remover, user_id))
    else:
        await call.message.answer("<b>🏪 Артисты отсутствуют 🖍</b>")


# Выбор позиции для редактирования
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit:", state="*")
async def artist_edit_open(call: CallbackQuery, state: FSMContext):
    print('Выбор артиста для редактирования api_sqlite.py 496')
    artist_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    print(artist_id, user_id, remover)

    get_message, get_photo = get_artist_admin(artist_id)

    if get_photo is not None and get_photo != '':
        await call.message.delete()
        await call.message.answer_photo(get_photo, get_message,
                                        reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
    else:
        await call.message.edit_text(get_message,
                                     reply_markup=artist_edit_open_finl(artist_id, user_id, remover))


# Возвращение к выбору позиции для изменения
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit_return", state="*")
async def artist_edit_return(call: CallbackQuery, state: FSMContext):
    user_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    user_id = call.from_user.id
    print(user_id)
    artists = get_artistsxx(admin=user_id)
    #shops = get_all_shopx()
    #shops = get_all_shopx()
    #print(f'shops {shops}')
    print(artists)

    if len(artists) >= 1:
        await call.message.delete()
        await call.message.answer("<b>📁 Выберите нужного Вам артиста 🖍</b>",
                                  reply_markup=artist_edit_open_fp(0, user_id))
    else:
        await call.answer("<b>❗ У Вас отсутствуют Артисты</b>")


# Создание новой позиции
@dp.message_handler(IsAdminorShopAdmin(), text="📁 Создать позицию ➕", state="*")
async def product_position_create(message: Message, state: FSMContext):
    await state.finish()
    print("APS 182")

    #if len(get_all_shopx()) >= 1:
    await message.answer(_("<b>📁 Выберите категорию для позиции</b>", locale=lang),
                         reply_markup=position_create_open_fp(0))
    #else:
    #await message.answer(_("<b>❌ Отсутствуют магазины для создания позиции.</b>")

###############################################################################################
##### ***** ###### *****         СОЗДАНИЕ АРТИСТА
###############################################################################################
# -----------------------------------------------------------------------------------------------------------
# Создание нового магазина
@dp.message_handler(IsAdminorShopAdmin(), text="📁 Создать событие ➕", state="*")
async def product_shop_create(message: Message, state: FSMContext):
    await state.finish()
    print("user_menu - создание события")
    print("-")
    user_id = message.from_user.id
    print(user_id)
    my_event = check_user_events_exist(user_id)
    print(my_event)
    city_id = get_city_user3(user_id)[2]
    print(city_id)

    if my_event == True:
        print("|")
        await message.answer(f"<b>🏪 Событие уже существует 🏷 Выбирайте его в каталоге при создании отзывов: {my_event} </b>", parse_mode='HTML')
    else:
        #if len(get_all_shopx()) >= 1:
        await state.set_state("here_event_name")
        await message.answer("<b>🏪 Введите название события 🏷</b>", parse_mode='HTML')

        '''await message.answer("<b>📁 Выберите место события или укажите <code>0</code></b>",
                             reply_markup=select_place_in_city_swipe_fp(city_id))'''

# Создание новой позиции
@dp.message_handler(IsAdminorShopAdmin(), text_startswith="here_event_place:", state="*")
async def product_position_create(message: Message, state: FSMContext):
    place = int(str(message.data).split(':')[1])
    await state.update_data(data={'place_id': place})

    print("||")
    await state.set_state("here_event_name")
    await message.answer("<b>🏪 Введите название события 🏷</b>", parse_mode='HTML')


# Создание новой позиции
@dp.message_handler(IsAdminorShopAdmin(), text_startswith="here_event_place2:", state="*")
async def product_position_create(call: CallbackQuery, state: FSMContext):
    place = int(str(call.data).split(':')[1])
    await state.update_data(data={'place_id': place})

    print("||")
    await state.set_state("here_event_name")
    await message.answer("<b>🏪 Введите название события 🏷</b>", parse_mode='HTML')


# принятие названия магазина, запрос описания
@dp.message_handler(IsAdminorShopAdmin(), state="here_event_name")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        print("admin_products_shop - создание события")
        await state.update_data(data={'name': message.text})
        await state.set_state('here_event_description')
        await message.answer("<b>🏪 Введите Bio ведущих 📜</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", parse_mode='HTML')
    else:
        await message.answer("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "🏪 Введите название для ведущих 🏷", parse_mode='HTML')


# принятие описания магазина, запрос адреса
@dp.message_handler(IsAdminorShopAdmin(), state="here_event_description")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 600:
        if message.text == '0':
            await state.update_data(data={'description': 'None'})
        else:
            await state.update_data(data={'description': message.text})
        await state.set_state('here_event_webadress')
        await message.answer("<b>🏪 Отправьте описание события 📍</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", parse_mode='HTML')
    else:
        await message.answer("<b>❌ Описание не может превышать 600 символов.</b>\n"
                             "🏪 Введите веб-сайт события 📜\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", parse_mode='HTML')


# принятие адреса магазина, запрос номера
@dp.message_handler(IsAdminorShopAdmin(), state="here_event_webadress")
async def product_category_create_name(message: Message, state: FSMContext):
    if message.text == '0':
        await state.update_data(data={'webaddress': 'None'})
    else:
        await state.update_data(data={'webaddress': message.text})
    await state.set_state('here_event_logo')
    await message.answer("<b>🏪 Отправьте лого события 📷</b>\n"
                         "❕ Отправьте <code>0</code> чтобы пропустить.", parse_mode='HTML')


# принятие лого магазина, запрос лого
@dp.message_handler(IsAdminorShopAdmin(), content_types=['photo','text'], state="here_event_logo")
async def product_category_create_logo(message: Message, state: FSMContext):
    logo = message.photo[0].file_id if message.content_type == 'photo' else None
    async with state.proxy() as data:
        print(data)
        name = data['name']
        description = data['description']
        webaddress = data['webaddress']

    await state.finish()

    type_trade = get_settingsx()
    if type_trade['type_trade'] != "digital":
        city = get_city_user3(message.from_user.id)
        print(city)
        city_id = city[0]
        geocode = city[1]
        city_name = city[2]
    else:
        city_id = 0
        geocode = ''
        city_name = ''
    add_eventx(name, description, webaddress, message.from_user.id, logo, city_id, geocode, city_name)
    await message.answer("<b>🏪 Карточка события была успешно создана ✅</b>", parse_mode='HTML')


# -----------------------------------------------------------------------------------------------------------
# Создание нового магазина
@dp.message_handler(IsAdminorShopAdmin(), text="🏪 Создать магазин ➕", state="*")
async def product_shop_create(message: Message, state: FSMContext):
    await state.finish()
    print("user_menu - создание магазина")
    print("-")
    user_id = message.from_user.id
    print(user_id)
    my_shop = check_user_shop_exist(user_id)
    print(my_shop)
    if my_shop == True:
        print("|")
        await message.answer(f"<b>🏪 Магазин уже существует 🏷 Выбирайте его в каталоге при создании позиций: {my_shop} </b>", parse_mode='HTML')
    else:
        print("||")
        await state.set_state("here_shop_name")
        await message.answer(_("<b>🏪 Введите название для магазина 🏷</b>", locale=lang), parse_mode='HTML')


# принятие названия магазина, запрос описания
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_name")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        print("admin_products_shop - создание магазина")
        await state.update_data(data={'name': message.text})
        await state.set_state('here_shop_description')
        await message.answer(_("<b>🏪 Введите описание для магазина 📜</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')
    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "🏪 Введите название для магазина 🏷", locale=lang), parse_mode='HTML')


# принятие описания магазина, запрос адреса
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_description")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 600:
        if message.text == '0':
            await state.update_data(data={'description': 'None'})
        else:
            await state.update_data(data={'description': message.text})
        await state.set_state('here_shop_adress')
        await message.answer(_("<b>🏪 Отправьте адресс магазина 📍</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


    else:
        await message.answer(_("<b>❌ Описание не может превышать 600 символов.</b>\n"
                             "🏪 Введите новое описание для магазина 📜\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


# принятие адреса магазина, запрос номера
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_adress")
async def product_category_create_name(message: Message, state: FSMContext):
    if message.text == '0':
        await state.update_data(data={'address': 'None'})
    else:
        await state.update_data(data={'address': message.text})
    await state.set_state('here_shop_phone')
    await message.answer(_("<b>🏪 Отправьте телефон магазина ☎️</b>\n"
                         "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


# принятие номера магазина, запрос лого
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_phone")
async def product_category_create_name(message: Message, state: FSMContext):
    if message.text == '0':
        await state.update_data(data={'phone': 'None'})
    else:
        await state.update_data(data={'phone': message.text})
    await state.set_state('here_shop_logo')
    await message.answer(_("<b>🏪 Отправьте лого магазина 📷</b>\n"
                         "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


# принятие лого магазина, запрос лого
@dp.message_handler(IsAdminorShopAdmin(), content_types=['photo','text'], state="here_shop_logo")
async def product_category_create_logo(message: Message, state: FSMContext):
    logo = message.photo[0].file_id if message.content_type == 'photo' else None
    async with state.proxy() as data:
        print(data)
        name = data['name']
        description = data['description']
        address = data['address']
        phone = data['phone']

    await state.finish()

    type_trade = get_settingsx()
    if type_trade['type_trade'] != "digital":
        city = get_city_user3(message.from_user.id)
        print(city)
        city_id = city[0]
        geocode = city[1]
        city_name = city[2]
    else:
        city_id = 0
        geocode = ''
        city_name = ''
    add_shopx(name, description, address, phone, message.from_user.id, logo, city_id, geocode, city_name)
    await message.answer(_("<b>🏪 Магазин был успешно создан ✅</b>", locale=lang), parse_mode='HTML')

# -----------------------------------------------------------------------------------------------------------
# Открытие страниц выбора магазина для редактирования
@dp.message_handler(IsAdminorShopAdmin(), text="🏪 Изменить магазин 🖍112", state="*")
async def product_category_edit(message: Message, state: FSMContext):
    await state.finish()

    shops = get_all_shopx()
    print(f'shops {shops}')

    if len(shops) >= 1:
        await message.answer(_("<b>🏪 Выберите магазин для изменения 🖍</b>", locale=lang),
                             reply_markup=shop_edit_open_fp(0, shops))
    else:
        await message.answer(_("<b>🏪 Магазины отсутствуют 🖍</b>", locale=lang))


# -----------------------------------------------------------------------------------------------------------
# Открытие страниц выбора магазина для редактирования
@dp.message_handler(IsAdminorShopAdmin(), text="🏪 Изменить магазин 🖍", state="*")
async def shop_list_edit(message: Message, state: FSMContext):
    await state.finish()
    user_id=message.from_user.id

    if user_id in get_admins():
        shops = get_shopsxy()
    else:
        shops = get_shopsxx(admin=user_id)
    print(shops)

    if len(shops) >= 1:
        await message.answer(_("<b>🏪 Выберите магазин для изменения 🖍</b>", locale=lang),
                             reply_markup=shop_edit_open_fp(0, user_id))
    else:
        await message.answer(_("<b>🏪 Ваши магазины отсутствуют 🖍</b>", locale=lang))


# Смена страницы выбора магазина
@dp.message_handler(IsAdminorShopAdmin(), text_startswith="change_shop_edit_pg:", state="*")
async def shop_list_edit(call: CallbackQuery, state: FSMContext):
    await state.finish()
    if len(shops) >= 1:
        page = int(str(call.data).split(':')[1])

        await call.message.answer(_("<b>🏪 Выберите магазин для изменения 🖍</b>", locale=lang),
                                  reply_markup=shop_edit_open_fp(page, 0))
    else:
        await call.message.answer(_("<b>🏪 Магазины отсутствуют 🖍</b>", locale=lang))


# Открытие сообщения с ссылкой на поддержку
@dp.message_handler(text=["☎ Поддержка", "/support"], state="*")
async def user_support(message: Message, state: FSMContext):
    await state.finish()

    user_support = get_settingsx()['misc_support']
    if str(user_support).isdigit():
        get_user = get_userx(user_id=user_support)

        if len(get_user['user_login']) >= 1:
            await message.answer(_("<b>☎ Нажмите кнопку ниже для связи с Администратором.</b>", locale=lang),
                                 reply_markup=user_support_finl(get_user['user_login']))
            return
        else:
            update_settingsx(misc_support="None")

    await message.answer(f"☎ Поддержка. Измените их в настройках бота.\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n{BOT_DESCRIPTION}",
                         disable_web_page_preview=True)

# Создание запроса на продавца
@dp.message_handler(state="here_seller_request_direction")
async def user_seller(message: Message, state: FSMContext):
    await state.finish()
    # message.answer(message.text)
    seller_request = create_seller_request(message.from_user.id, message.text)
    await message.answer("👌 Ваш запрос успешно отправлен.")

# Просмотр истории покупок
@dp.callback_query_handler(text="create_seller_request5", state="*")
async def user_seller(call: CallbackQuery, state: FSMContext):
    seller_request = create_seller_request(call.from_user.id)
    await call.answer("🎁 Запрос успешно создан")
    await notify(dp, "Поступил новый запрос продавца!")
    # await bot.send_message(get_admins(), "ntcnnnnnn")

# Подтверждение удаления всех позиций
@dp.message_handler(IsShopAdmin(), text="📁 Удалить все позиции ❌", state="*")
async def product_position_remove(message: Message, state: FSMContext):
    await state.finish()

    await message.answer(_("<b>📁 Вы действительно хотите удалить все позиции? ❌</b>\n"
                         "❗ Так же будут удалены все товары", locale=lang),
                         reply_markup=position_remove_confirm_inl)

# Удаление позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_delete", state="*")
async def product_position_edit_delete(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await call.message.delete()
    await call.message.answer(_("<b>📁 Вы действительно хотите удалить позицию? ❌</b>", locale=lang),
                              reply_markup=position_edit_delete_finl(position_id, category_id, remover))


# Подтверждение удаления позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_delete", state="*")
async def product_position_edit_delete_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])
    remover = int(call.data.split(":")[4])

    if get_action == "yes":
        remove_itemx(position_id=position_id)
        remove_positionx(position_id=position_id)

        await call.answer("📁 Вы успешно удалили позицию и её товары ✅")

        if len(get_positionsx(category_id=category_id)) >= 1:
            await call.message.edit_text(_("<b>📁 Выберите нужную вам позицию 🖍</b>", locale=lang),
                                         reply_markup=position_edit_open_fp(remover, category_id))
        else:
            await call.message.delete()
    else:
        get_message, get_photo = get_position_admin(position_id)

        if get_photo is not None:
            await call.message.delete()
            await call.message.answer_photo(get_photo, get_message,
                                            reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await call.message.edit_text(get_message,
                                         reply_markup=position_edit_open_finl(position_id, category_id, remover))


# Согласие очистики позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_clear", state="*")
async def product_position_edit_clear_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])
    remover = int(call.data.split(":")[4])

    if get_action == "yes":
        remove_itemx(position_id=position_id)
        await call.answer("📁 Вы успешно удалили все товары позиции ✅")

    get_message, get_photo = get_position_admin(position_id)

    if get_photo is not None:
        await call.message.delete()
        await call.message.answer_photo(get_photo, get_message,
                                        reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await call.message.edit_text(get_message,
                                     reply_markup=position_edit_open_finl(position_id, category_id, remover))


# Открытие способов пополнения
@dp.message_handler(IsShopAdmin(), text="🖲 Способы пополнения", state="*")
async def payment_systems(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id

    await message.answer(_("<b>🖲 Выберите способ пополнения</b>", locale=lang), reply_markup=payment_as_choice_finl(user_id))


# Включение/выключение самих способов пополнения
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="change_payment7:")
async def payment_systems_edit7(call: CallbackQuery):
    way_pay = call.data.split(":")[1]
    way_status = call.data.split(":")[2]
    user_id = json.dumos(call.data.split(":")[3])
    print("Админ магазина")
    # print(call.data.split(":")[0])
    print(call.from_user.id)
    user_id = call.from_user.id

    count = get_upaycount(user_id)
    print(count['paycount'])
    if count['paycount'] == 0:
        cur = create_upayments_row(user_id)
    else:
        get_payment = get_upaymentx(user_id)

    if get_payment['qiwi_login'] != "None" and get_payment['qiwi_token'] != "None" or way_status == "False":
        if way_pay == "Form":
            if get_payment['qiwi_secret'] != "None" or way_status == "False":
                update_upaymentx(user_id, way_form=way_status)
            else:
                await call.answer(
                    "❗ Приватный ключ отсутствует. Измените киви и добавьте приватный ключ для включения оплаты по Форме",
                    True)
        elif way_pay == "ForYm":
            if get_payment['yoo_token'] != "None" or way_status == "False":
                update_upaymentx(user_id, way_formy=way_status)
            else:
                await call.answer(
                    "❗ Номер счета отсутствует. Измените YooMoney и добавьте токен для включения оплаты по Форме YooMoney",
                    True)
        elif way_pay == "Number":
            update_update_upaymentx(user_id, way_number=way_status)
        elif way_pay == "Nickname":
            status, response = await (await QiwiAPI(call)).get_nickname()
            if status:
                update_upaymentx(user_id, way_nickname=way_status, qiwi_nickname=response)
            else:
                await call.answer(response, True)
    else:
        await call.answer("❗ Добавьте киви кошелёк перед включением Способов пополнений.", True)

    try:
        await call.message.edit_text(_("<b>🖲 Выберите способ пополнения</b>", locale=lang), reply_markup=payment_as_choice_finl())
    except Exception:
        pass


####################################### QIWI ######################################
# Изменение QIWI кошелька
@dp.message_handler(IsShopAdmin(), text="🥝 Изменить QIWI 🖍", state="*")
async def payment_qiwi_edit(message: Message, state: FSMContext):
    await state.finish()

    await state.set_state("here_qiwi_login")
    await message.answer(_("<b>🥝 Введите <code>номер (через +7, +380)</code> QIWI кошелька 🖍</b>", locale=lang))


# Проверка работоспособности QIWI
@dp.message_handler(IsAdminorShopAdmin(), text="🥝 Проверить QIWI ♻", state="*")
async def payment_qiwi_check(message: Message, state: FSMContext):
    print("||| Проверка КИВИ админом площадки. |||")
    await state.finish()
    user_id = message.from_user.id
    print(user_id)

    await (await QiwiAPI(message, suser_id=user_id, check_pass=True)).pre_checker()


# Баланс QIWI
@dp.message_handler(IsAdminorShopAdmin(), text="🥝 Баланс QIWI 👁", state="*")
async def payment_qiwi_balance(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id

    await (await QiwiAPI(message, suser_id=user_id)).get_balance()


######################################## ПРИНЯТИЕ QIWI ########################################
# Принятие логина для QIWI
@dp.message_handler(IsShopAdmin(), state="here_qiwi_login")
async def payment_qiwi_edit_login(message: Message, state: FSMContext):
    if message.text.startswith("+"):
        await state.update_data(here_qiwi_login=message.text)

        await state.set_state("here_qiwi_token")
        await message.answer(
            "<b>🥝 Введите <code>токен API</code> QIWI кошелька 🖍</b>\n"
            "❕ Получить можно тут 👉 <a href='https://qiwi.com/api'><b>Нажми на меня</b></a>\n"
            "❕ При получении токена, ставьте только первые 3 галочки.",
            disable_web_page_preview=True
        )
    else:
        await message.answer(_("<b>❌ Номер должен начинаться с + <code>(+7..., +380...)</code></b>\n"
                             "🥝 Введите <code>номер (через +7, +380)</code> QIWI кошелька 🖍", locale=lang))


# Принятие токена для QIWI
@dp.message_handler(IsShopAdmin(), state="here_qiwi_token")
async def payment_qiwi_edit_token(message: Message, state: FSMContext):
    await state.update_data(here_qiwi_token=message.text)

    await state.set_state("here_qiwi_secret")
    await message.answer(
        "<b>🥝 Введите <code>Секретный ключ 🖍</code></b>\n"
        "❕ Получить можно тут 👉 <a href='https://qiwi.com/p2p-admin/transfers/api'><b>Нажми на меня</b></a>\n"
        "❕ Вы можете пропустить добавление оплаты по Форме, отправив: <code>0</code>",
        disable_web_page_preview=True
    )


# Принятие приватного ключа для QIWI
@dp.message_handler(IsAdminorShopAdmin(), state="here_qiwi_secret")
async def payment_qiwi_edit_secret(message: Message, state: FSMContext):
    async with state.proxy() as data:
        qiwi_login = data['here_qiwi_login']
        qiwi_token = data['here_qiwi_token']
        if message.text == "0": qiwi_secret = "None"
        if message.text != "0": qiwi_secret = message.text
        user_id = message.from_user.id

    await state.finish()

    cache_message = await message.answer(_("<b>🥝 Проверка введённых QIWI данных... 🔄</b>", locale=lang))
    await asyncio.sleep(0.5)

    await (await QiwiAPI(cache_message, qiwi_login, qiwi_token, qiwi_secret, add_pass=True, suser_id=user_id)).pre_checker()


################################################################################################
###################################### УДАЛЕНИЕ ВСЕХ ПОЗИЦИЙ ###################################
# Согласие на удаление всех позиций и товаров
@dp.callback_query_handler(IsShopAdmin(), text_startswith="confirm_remove_position:", state="*")
async def product_position_remove(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    print("SA DEL POSITIONS")
    user_id = call.from_user.id
    print(user_id)

    if get_action == "yes":

        get_positions = len(get_all_my_positionsnx(position_user_id=user_id))
        print(get_positions)
        get_items = len(get_all_my_itemsnx(creator_id=user_id))
        print(get_items)

        remove_positionx(position_user_id=user_id)
        remove_itemx(creator_id=user_id)

        await call.message.edit_text(
            f"<b>📁 Вы удалили все позиции<code>({get_positions}шт)</code> и товары<code>({get_items}шт)</code> ☑</b>")
    else:
        await call.message.edit_text(_("<b>📁 Вы отменили удаление всех позиций ✅</b>", locale=lang))

#################### УДАЛЕНИЕ ТОВАРОВ ###################
# Кнопки с подтверждением удаления всех категорий
@dp.message_handler(IsShopAdmin(), text="🎁 Удалить все товары ❌", state="*")
async def product_item_remove(message: Message, state: FSMContext):
    await state.finish()

    await message.answer(_("<b>🎁 Вы действительно хотите удалить все товары? ❌</b>\n", locale=lang),
                         reply_markup=item_remove_confirm_inl)

##################################### УДАЛЕНИЕ ВСЕХ ТОВАРОВ ####################################
# Согласие на удаление всех товаров
@dp.callback_query_handler(IsShopAdmin(), text_startswith="confirm_remove_item:", state="*")
async def product_item_remove(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    if get_action == "yes":
        user_id = call.from_user.id

        get_items = len(get_all_my_itemsnx(creator_id=user_id))
        remove_itemx(creator_id=user_id)

        await call.message.edit_text(f"<b>🎁 Вы удалили все товары<code>({get_items}шт)</code> ☑</b>")
    else:
        await call.message.edit_text(_("<b>🎁 Вы отменили удаление всех товаров ✅</b>", locale=lang))


# Удаление определённых товаров
@dp.message_handler(IsShopAdmin(), text="🎁 Удалить товары 🖍", state="*")
async def product_item_delete(message: Message, state: FSMContext):
    await state.finish()

    await state.set_state("here_items_delete")
    await message.answer(_("<b>🖍 Вводите айди товаров, которые нужно удалить</b>\n"
                         "❕ Получить айди товаров можно при изменении позиции\n"
                         "❕ Если хотите удалить несколько товаров, отправьте ID товаров через запятую или пробел. Пример:\n"
                         "<code>▶ 123456,123456,123456</code>\n"
                         "<code>▶ 123456 123456 123456</code>", locale=lang))

################################################################################################
####################################### УДАЛЕНИЕ ТОВАРОВ ######################################
# Принятие айди товаров для их удаления
@dp.message_handler(IsAdminorShopAdmin(), state="here_items_delete")
async def product_item_delete_get(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id

    remove_ids, cancel_ids = [], []  # Айди удалённых и ненайденных товаров
    get_item_ids_one, get_item_ids_two = [], [[]]
    save_ids = []

    if "," in message.text:
        get_item_ids_one = clear_list(message.text.split(","))
    else:
        get_item_ids_one = clear_list([message.text])

    get_item_ids_two.extend(
        item.split(" ") for item in get_item_ids_one if " " in item
    )
    if len(get_item_ids_two) == 1:
        get_item_ids_two.append(get_item_ids_one)

    for check_item in get_item_ids_two:
        save_ids.extend(iter(clear_list(check_item)))
    save_ids = clear_list(save_ids)

    for item_id in save_ids:
        #check_item = get_itemx(item_id=item_id)
        check_item = get_itemx(item_id=item_id, creator_id=user_id)
        if check_item is not None:
            remove_itemx(item_id=item_id)
            remove_ids.append(item_id)
        else:
            cancel_ids.append(item_id)

    remove_ids = ", ".join(remove_ids)
    cancel_ids = ", ".join(cancel_ids)

    await message.answer(f"<b>✅ Успешно удалённые товары:\n"
                         f"▶ <code>{remove_ids}</code>\n"
                         f"➖➖➖➖➖➖➖➖➖➖\n"
                         f"❌ Ненайденные товары:\n"
                         f"▶ <code>{cancel_ids}</code></b>")
###############################################################################################
################################################################################################
####################################### ДОБАВЛЕНИЕ ПОЗИЦИЙ #####################################
# Следующая страница выбора категорий для создания позиций
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="position_create_nextp:", state="*")
async def product_position_create_next(call: CallbackQuery, state: FSMContext):
    print('выбора категорий для создания позиций  user_menu.py 126')
    remover = int(call.data.split(":")[1])
    print(remover)

    await call.message.edit_text(_("<b>📁 Выберите категорию для позиции ➕</b>", locale=lang),
                                 reply_markup=position_create_next_page_fp(remover))

# Предыдущая страница выбора категорий для создания позиций
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="position_create_backp:", state="*")
async def product_position_create_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text(_("<b>📁 Выберите категорию для позиции ➕</b>", locale=lang),
                                 reply_markup=position_create_back_page_fp(remover))


# Выбор категории для создания позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="position_people_create_here:", state="*")
async def product_position_create_select_category(call: CallbackQuery, state: FSMContext):
    print('position_people_create_here - user_menu 160')
    category_id = int(call.data.split(":")[1])
    await state.update_data(here_cache_change_category_id=category_id)
    await state.update_data(here_position_source="people")

    await state.set_state("here_position_name")
    await call.message.edit_text(_("<b>📁 Введите название для позиции 🏷</b>", locale=lang))


# Выбор категории для создания позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="position_people_open_here:", state="*")
async def product_position_open_select_category(call: CallbackQuery, state: FSMContext):
    print('position_people_open_here - user_menu 160')
    category_id = int(call.data.split(":")[1])
    print(category_id)
    get_category = get_category_people(category_id=category_id)
    city_id = get_city_user(call.from_user.id)[0]
    get_positions = get_people_positions_in_cityx(category_id=category_id, position_city_id=city_id, flagallc=1, position_type=1)  # get_positionsx(category_id=category_id)
    print(category_id, city_id)
    if len(get_positions) >= 1:
        source = "people"

        await call.message.edit_text(f"<b>🎁 Товары частных лиц в категории: {get_category['category']}</b>",
                                     reply_markup=products_item_position_swipe_fp(0, category_id, city_id, source))
    else:
        await call.answer(f"❕ Товары в категории {get_category['category']} отсутствуют")


# Выбор категории для создания позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="position_create_here:", state="*")
async def product_position_create_select_category(call: CallbackQuery, state: FSMContext):
    print('position_create_here - user_menu 160')
    category_id = int(call.data.split(":")[1])
    await state.update_data(here_cache_change_category_id=category_id)
    await state.update_data(here_position_source="commercial")

    print('position_addtoshop - user_menu 555')
    user_id = call.from_user.id
    get_user_shops = get_shopsxx(admin=user_id)
    if len(get_user_shops) >= 1:
        await call.message.edit_text(_("<b>Выберите магазин для добавления позиции.</b>", locale=lang),
                                     reply_markup=position_select_shop_fp(0))
    else:
        await call.message.edit_text(_("<b>У Вас еще нет магазина на площадке, но Вы можете его создать.</b>", locale=lang),
                                     reply_markup=shop_creation_request_finl())
        await state.set_state("here_position_addtoshop")


# Выбор категории для создания позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="here_position_addtoshop:", state="*")
async def product_position_create_select_category(call: CallbackQuery, state: FSMContext):
    print('here_position_addtoshop: - user_menu 566')
    key = call.data.split(":")[1]
    if key != "NoCreate":
        shop_id = int(call.data.split(":")[1])
        await state.update_data(here_cache_change_shop_id=shop_id)

        await state.set_state("here_position_name")
        await call.message.edit_text(_("<b>📁 Введите название для позиции 🏷</b>", locale=lang))


# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Заготовка под принятие города магазином
# Принятие города для создания позиции
# @dp.message_handler(IsShopAdmin(), state="here_position_city")
# async def product_position_create_name(message: Message, state: FSMContext):
#     print(f'Принятие города для создания позиции  admin_products_shop.py 344')
#     city_user = get_city_user(message.from_user.id)
# Принятие имени для создания позиции


@dp.message_handler(IsAdminorShopAdmin(), state="here_position_name")
async def product_position_create_name(message: Message, state: FSMContext):
    print('Принятие имени для создания позиции  user_menu.py 1084')
    if len(message.text) <= 100:
        await state.update_data(here_position_name=clear_html(message.text),
                                here_position_city=get_citytext_user(message.from_user.id)[0]
                                , position_city_id=get_city_user(message.from_user.id)[0])

        await state.set_state("here_position_type")
        await message.answer(_("<b>📁 Введите тип позиции 1 - реальная, 2 - цифровая</b>", locale=lang), reply_markup=position_select_type_finl())
    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "📁 Введите название для позиции 🏷", locale=lang))


@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="here_position_type:", state="*")
async def product_position_create_type(call: CallbackQuery, state: FSMContext):
    print('Принятие имени для создания позиции  user_menu.py 1084')
    position_type_txt = call.data.split(":")[1]
    position_type = 1 if position_type_txt == "real" else 2
    #print(message.text)
    if len(position_type_txt) <= 7:
        await state.update_data(here_position_type=position_type, #clear_html(message.text),
                                here_position_city=get_citytext_user(call.from_user.id)[0]
                                , position_city_id=get_city_user(call.from_user.id)[0])

        await state.set_state("here_position_price")
        await call.message.answer(_("<b>📁 Введите цену для позиции 💰</b>", locale=lang))
    else:
        await call.message.answer(_("<b>❌ Тип позиции не может отличаться от перечисленных значений. 1 или 2.</b>\n"
                             "📁 Введите тип позиции 🏷", locale=lang))


# Принятие цены позиции для её создания
@dp.message_handler(IsAdminorShopAdmin(), state="here_position_price")
async def product_position_create_price(message: Message, state: FSMContext):
    print('Принятие цены позиции  admin_products.py 366')
    if message.text.isdigit():
        if 0 <= int(message.text) <= 10000000:
            await state.update_data(here_position_price=message.text)
        else:
            await message.answer(_("<b>❌ Цена не может быть меньше 0 или больше 10 000 000.</b>\n"
                                 "📁 Введите цену для позиции 💰", locale=lang))
    else:
        await message.answer(_("<b>❌ Данные были введены неверно.</b>\n"
                             "📁 Введите цену для позиции 💰", locale=lang))

    position_data = await state.get_data()
    print(position_data['here_position_type'])
    position_type = position_data['here_position_type']

    if position_type == 1:
        await state.set_state("here_position_rest")
        await message.answer(_("<b>📁 Введите остаток для позиции 📜</b>", locale=lang))

    elif position_type == 2:
        await state.set_state("here_position_rest")
        await product_position_create_in_rest(message, state)


# Принятие цены позиции для её создания
@dp.message_handler(IsAdminorShopAdmin(), state="here_position_rest")
async def product_position_create_in_rest(message: Message, state: FSMContext):
    print('Принятие остатка позиции  admin_products.py 366')
    #position_data = await state.get_data()
    async with state.proxy() as data:
        #print(position_data['here_position_type'])
        print(data['here_position_type'])
        #position_type = position_data['here_position_type']
        position_type = data['here_position_type']
    if position_type == 1:
        if message.text.isdigit():
            if 0 <= int(message.text) <= 10000:
                await state.update_data(here_position_rest=message.text)
            else:
                await message.answer(_("<b>❌ Остаток не может быть меньше 0 или больше 10 000.</b>\n"
                                     "📁 Введите остаток позиции 💰", locale=lang))
        else:
            await message.answer(_("<b>❌ Данные были введены неверно.</b>\n"
                                 "📁 Введите остаток позиции 💰", locale=lang))
    elif position_type == 2:
        await state.update_data(here_position_rest=0)

    await state.set_state("here_position_description")
    await message.answer(_("<b>📁 Введите описание для позиции 📜</b>\n"
                         "❕ Вы можете использовать HTML разметку\n"
                         "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))


# Принятие описания позиции для её создания
@dp.message_handler(IsAdminorShopAdmin(), state="here_position_description")
async def product_position_create_description(message: Message, state: FSMContext):
    print('Принятие описания позиции  admin_products.py 386')

    try:
        if len(message.text) <= 900:
            if message.text != "0":
                cache_msg = await message.answer(message.text)
                await cache_msg.delete()

            await state.update_data(here_position_description=message.text)

            await state.set_state("here_position_photo")
            await message.answer(_("<b>📁 Отправьте изображение для позиции 📸</b>\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))
        else:
            await message.answer(_("<b>❌ Описание не может превышать 600 символов.</b>\n"
                                 "📁 Введите новое описание для позиции 📜\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))
    except CantParseEntities:
        await message.answer(_("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📁 Введите описание для позиции 📜\n"
                             "❕ Вы можете использовать HTML разметку\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))


# Принятие изображения позиции для её создания
@dp.message_handler(IsAdminorShopAdmin(), content_types="photo", state="here_position_photo")
@dp.message_handler(IsAdminorShopAdmin(), text="0", state="here_position_photo")
async def product_position_create_photo(message: Message, state: FSMContext):
    print('Принятие изображения позиции  admin_products.py 418')
    async with state.proxy() as data:
        position_user_id = message.from_user.id
        position_city = data['here_position_city']
        position_city_id = data['position_city_id']
        position_name = clear_html(data['here_position_name'])
        position_price = data['here_position_price']
        position_type = data['here_position_type']
        if position_type == 1:
            position_rest = data['here_position_rest']
        elif position_type == 2:
            position_rest = 0
        catategory_id = data['here_cache_change_category_id']
        position_source = data['here_position_source']
        if position_source == "commercial":
            position_shop_id = data['here_cache_change_shop_id']
        elif position_source == "people":
            position_shop_id = 0
        position_description = data['here_position_description']
        position_source = data['here_position_source']
    await state.finish()

    position_photo = "" if "text" in message else message.photo[-1].file_id
    add_positionx(position_city, position_city_id, position_name, position_price, position_type, position_rest, position_description, position_photo,
                  catategory_id, position_shop_id, position_user_id, position_source)

    #async def on_notify(dp: Dispatcher, msg, markup):
    #    await send_admins(msg, markup="default")
    await notify(dp, f"Создана позиция: {position_name}, пользователем ID: {position_user_id}")

    await message.answer(_("<b>📁 Позиция была успешно создана ✅</b>", locale=lang))


################################################################################################
####################################### ИЗМЕНЕНИЕ ПОЗИЦИЙ #####################################
# Возвращение к начальным категориям для редактирования позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_category_return", state="*")
async def product_position_edit_return(call: CallbackQuery, state: FSMContext):
    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                                 reply_markup=position_edit_category_open_fp(0))


# Следующая страница категорий для редактирования позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_category_nextp:", state="*")
async def product_position_edit_category_next(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                                 reply_markup=position_edit_category_next_page_fp(remover))


# Предыдущая страница категорий для редактирования позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_category_backp:", state="*")
async def product_position_edit_category_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                                 reply_markup=position_edit_category_back_page_fp(remover))


# Выбор категории с нужной позицией
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_category:", state="*")
async def product_position_edit_category_open(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])

    if len(get_positionsx(category_id=category_id)) >= 1:
        await call.message.edit_text(_("<b>📁 Выберите нужную вам позицию 🖍</b>", locale=lang),
                                     reply_markup=position_edit_open_fp(0, category_id))
    else:
        await call.answer("📁 Позиции в данной категории отсутствуют")


# Следующая страница позиций для их изменения
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_nextp:", state="*")
async def product_position_edit_next(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])

    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                                 reply_markup=position_edit_next_page_fp(remover, category_id))


# Предыдущая страница позиций для их изменения
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_backp:", state="*")
async def product_position_edit_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])

    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                                 reply_markup=position_edit_back_page_fp(remover, category_id))


# Выбор позиции для редактирования
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit:", state="*")
async def product_position_edit_open(call: CallbackQuery, state: FSMContext):
    print('Выбор позиции для редактирования api_sqlite.py 496')
    position_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])
    user_id = call.from_user.id

    # IsProductShopAdmin()
    adminspos = check_position_owner(user_id, position_id)
    if adminspos is True:

        get_message, get_photo = get_position_admin(position_id)

        if get_photo is not None:
            await call.message.delete()
            await call.message.answer_photo(get_photo, get_message,
                                            reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await call.message.edit_text(get_message,
                                         reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await call.answer("<b>❗ У Вас нет прав редактировать данную позицию.</b>")


# Возвращение к выбору позиции для изменения
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_return", state="*")
async def product_position_edit_return(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])

    if len(get_positionsx(category_id=category_id)) >= 1:
        await call.message.delete()
        await call.message.answer(_("<b>📁 Выберите нужную вам позицию 🖍</b>", locale=lang),
                                  reply_markup=position_edit_open_fp(remover, category_id))
    else:
        await call.answer("<b>❗ Позиции в данной категории отсутствуют</b>")


######################################## САМО ИЗМЕНЕНИЕ ПОЗИЦИИ ########################################
# Изменение имени позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_name", state="*")
async def product_position_edit_name(call: CallbackQuery, state: FSMContext):
    print('Изменение имени позиции api_sqlite.py 529')
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_name")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Введите новое название для позиции 🏷</b>", locale=lang))


# Принятие имени позиции для её изменения
@dp.message_handler(IsShopAdmin(), state="here_change_position_name")
async def product_position_edit_name_get(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        async with state.proxy() as data:
            position_id = data['here_cache_position_id']
            category_id = data['here_cache_category_id']
            remover = data['here_cache_position_remover']
        await state.finish()

        update_positionx(position_id, position_name=clear_html(message.text))
        get_message, get_photo = get_position_admin(position_id)

        if get_photo is not None:
            await message.answer_photo(get_photo, get_message,
                                       reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await message.answer(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "📁 Введите новое название для позиции 🏷", locale=lang))

# Изменение цены позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_price", state="*")
async def product_position_edit_price(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_price")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Введите новую цену для позиции 💰</b>", locale=lang))


# Принятие цены позиции для её изменения
@dp.message_handler(IsShopAdmin(), state="here_change_position_price")
async def product_position_edit_price_get(message: Message, state: FSMContext):
    if message.text.isdigit():
        if 0 <= int(message.text) <= 10000000:
            async with state.proxy() as data:
                position_id = data['here_cache_category_id']
                category_id = data['here_cache_position_id']
                remover = data['here_cache_position_remover']
            await state.finish()

            update_positionx(position_id, position_price=message.text)
            get_message, get_photo = get_position_admin(position_id)

            if get_photo is not None:
                await message.answer_photo(get_photo, get_message,
                                           reply_markup=position_edit_open_finl(position_id, category_id, remover))
            else:
                await message.answer(get_message,
                                     reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await message.answer(_("<b>❌ Цена не может быть меньше 0 или больше 10 000 000.</b>\n"
                                 "📁 Введите цену для позиции 💰", locale=lang))
    else:
        await message.answer(_("<b>❌ Данные были введены неверно.</b>\n"
                             "📁 Введите цену для позиции 💰", locale=lang))


# Изменение описания позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_description", state="*")
async def product_position_edit_description(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_description")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Введите новое описание для позиции 📜</b>\n"
                              "❕ Вы можете использовать HTML разметку\n"
                              "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))


# Принятие описания позиции для её изменения
@dp.message_handler(IsShopAdmin(), state="here_change_position_description")
async def product_position_edit_description_get(message: Message, state: FSMContext):
    async with state.proxy() as data:
        position_id = data['here_cache_category_id']
        category_id = data['here_cache_position_id']
        remover = data['here_cache_position_remover']

    try:
        if len(message.text) <= 600:
            await state.finish()

            if message.text != "0":
                cache_msg = await message.answer(message.text)
                await cache_msg.delete()

            update_positionx(position_id, position_description=message.text)
            get_message, get_photo = get_position_admin(position_id)

            if get_photo is not None:
                await message.answer_photo(get_photo, get_message,
                                           reply_markup=position_edit_open_finl(position_id, category_id, remover))
            else:
                await message.answer(get_message,
                                     reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await message.answer(_("<b>❌ Описание не может превышать 600 символов.</b>\n"
                                 "📁 Введите новое описание для позиции 📜\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))
    except CantParseEntities:
        await message.answer(_("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📁 Введите новое описание для позиции 📜\n"
                             "❕ Вы можете использовать HTML разметку\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))


# Изменение изображения позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_photo", state="*")
async def product_position_edit_photo(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_photo")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Отправьте новое изображение для позиции 📸</b>\n"
                              "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))


# Принятие нового фото для позиции
@dp.message_handler(IsShopAdmin(), content_types="photo", state="here_change_position_photo")
@dp.message_handler(IsShopAdmin(), text="0", state="here_change_position_photo")
async def product_position_edit_photo_get(message: Message, state: FSMContext):
    async with state.proxy() as data:
        position_id = data['here_cache_category_id']
        category_id = data['here_cache_position_id']
        remover = data['here_cache_position_remover']
    await state.finish()

    position = get_positionx(position_id=position_id)
    print(position['position_name'])

    position_photo = "" if "text" in message else message.photo[-1].file_id
    update_positionx(position_id, position_photo=position_photo)
    get_message, get_photo = get_position_admin(position_id)
    await notify(dp, f"Была отредактирована позиция: {position['position_name']}")

    if get_photo is not None:
        await message.answer_photo(get_photo, get_message,
                                   reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await message.answer(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover))

# Изменение города продукта
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="shop_edit_city", state="*")
async def product_position_edit_description2(call: CallbackQuery, state: FSMContext):
    print('Изменение города продукта  admin_products.py 715')
    print(call.data)
    category_id = int(call.data.split(":")[2])
    position_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[3])

    current_city = get_city_user(call.from_user.id)[0]
    get_user_shops = get_shopsxx(admin=user_id)
    if len(get_user_shops) >= 1:
        await call.message.edit_text(_("<b>Выберите магазин для добавления позиции.</b>", locale=lang),
                                     reply_markup=position_select_shop_fp(0))

    await state.set_state("here_change_shop")

    # await state.update_data(here_cache_category_id=category_id)
    # await state.update_data(here_cache_position_id=position_id)
    # await state.update_data(here_cache_position_remover=remover)


    #await state.update_data({'position_id': position_id, 'category_id': category_id, 'remover': remover})
    #await call.message.delete()
    #await call.message.answer("<b>📁 Выберите другой город 🏙</b>\n"
    #                          "❕ Вы можете использовать геолокацию или выбрать город из списка\n"
    #                          f"❕  Город товара: <code>{current_city}</code>", reply_markup=geo_1_kb())


# ---------------------------  Добавлено 12.08.22 ------------------------------------------

# Изменение города продукта
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="position_edit_city", state="*")
async def product_position_edit_city(call: CallbackQuery, state: FSMContext):
    print('Изменение города продукта  admin_products.py 715')
    print(call.data)
    category_id = int(call.data.split(":")[2])
    position_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[3])

    current_city = get_city_user(call.from_user.id)[0]

    # await state.update_data(here_cache_category_id=category_id)
    # await state.update_data(here_cache_position_id=position_id)
    # await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_city")
    await state.update_data({'position_id': position_id, 'category_id': category_id, 'remover': remover})
    await call.message.delete()
    await call.message.answer("<b>📁 Выберите другой город 🏙</b>\n"
                              "❕ Вы можете использовать геолокацию или выбрать город из списка\n"
                              f"❕ Город товара: <code>{current_city}</code>", reply_markup=geo_1_kb())


# принятие новой геопозиции для позиции
@dp.callback_query_handler(text_startswith='geo_chosen_cities', state='here_change_city')
async def geo_5(cb: CallbackQuery, state: FSMContext):
    info = int(str(cb.data).split('#')[1])
    if info == 0:
        async with state.proxy() as data:
            city = data['city']
            position_id = int(data['position_id'])
            category_id = data['category_id']
            remover = data['remover']
            city_id = data['city_id']

    else:
        async with state.proxy() as data:
            position_id = int(data['position_id'])
            category_id = data['category_id']
            remover = data['remover']

        city_id = info
        city = get_city_info(info)

    await state.finish()
    update_position_city(city, city_id, position_id)

    # update_positionx(position_id)
    get_message, get_photo = get_position_admin(position_id)

    if get_photo is not None:
        await cb.message.answer_photo(get_photo, get_message,
                                      reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await cb.message.answer(get_message,
                                reply_markup=position_edit_open_finl(position_id, category_id, remover))

######################################## САМО ИЗМЕНЕНИЕ ПОЗИЦИИ ########################################
# Изменение имени позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit_name", state="*")
async def tgartist_edit_name(call: CallbackQuery, state: FSMContext):
    print('Изменение имени артиста api_sqlite.py 529')
    artist_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_artist_id=artist_id)
    await state.update_data(here_cache_user_id=user_id)
    await state.update_data(here_cache_artist_remover=remover)

    await state.set_state("here_change_artist_name")
    await call.message.delete()
    await call.message.answer("<b>📁 Введите новое название для артиста 🏷</b>")


# Принятие имени артиста для его изменения
@dp.message_handler(IsAdminorShopAdmin(), state="here_change_artist_name")
async def artist_edit_name_get(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        async with state.proxy() as data:
            artist_id = data['here_cache_artist_id']
            user_id = data['here_cache_user_id']
            remover = data['here_cache_artist_remover']
        await state.finish()

        update_artistx(artist_id, name=clear_html(message.text))
        get_message, get_photo = get_artist_admin(artist_id)

        if get_photo is not None:
            await message.answer_photo(get_photo, get_message,
                                       reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
        else:
            await message.answer(get_message, reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "📁 Введите новое название для артиста 🏷", locale=lang))
################################################################################################
# РЕДАКТИРОВАНИЕ ОПИСАНИЯ АРТИСТА
###################################
# Изменение описания артиста
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit_description", state="*")
async def artist_edit_description(call: CallbackQuery, state: FSMContext):
    artist_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_artist_id=artist_id)
    await state.update_data(here_cache_user_id=user_id)
    await state.update_data(here_cache_artist_remover=remover)

    await state.set_state("here_change_artist_description")
    await call.message.delete()
    await call.message.answer("<b>📁 Введите новое описание для артиста 📜</b>\n"
                              "❕ Вы можете использовать HTML разметку\n"
                              "❕ Отправьте <code>0</code> чтобы пропустить.")


# Принятие описания позиции для её изменения
@dp.message_handler(IsAdminorShopAdmin(), state="here_change_artist_description")
async def product_artist_edit_description_get(message: Message, state: FSMContext):
    async with state.proxy() as data:
        artist_id = data['here_cache_artist_id']
        user_id = data['here_cache_user_id']
        remover = data['here_cache_artist_remover']

    try:
        if len(message.text) <= 600:
            await state.finish()

            if message.text != "0":
                cache_msg = await message.answer(message.text)
                await cache_msg.delete()

            update_artistx(artist_id, description=clear_html(message.text))
            get_message, get_photo = get_artist_admin(artist_id)

            if get_photo is not None:
                await message.answer_photo(get_photo, get_message,
                                           reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
            else:
                await message.answer(get_message,
                                     reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
        else:
            await message.answer(_("<b>❌ Описание не может превышать 600 символов.</b>\n"
                                 "📁 Введите новое описание для артиста 📜\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))
    except CantParseEntities:
        await message.answer(_("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📁 Введите новое описание для артиста 📜\n"
                             "❕ Вы можете использовать HTML разметку\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang))
##############################################################################################
########################## ARTIST _____ EDIT ________ PHOTO
##############################################################################################
# Изменение изображения позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit_photo", state="*")
async def artist_edit_photo(call: CallbackQuery, state: FSMContext):
    artist_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_artist_id=artist_id)
    await state.update_data(here_cache_user_id=user_id)
    await state.update_data(here_cache_artist_remover=remover)

    await state.set_state("here_change_artist_photo")
    await call.message.delete()
    await call.message.answer("<b>📁 Отправьте новое изображение для артиста 📸</b>\n"
                              "❕ Отправьте <code>0</code> чтобы пропустить.")


# Принятие нового фото для позиции
@dp.message_handler(IsAdminorShopAdmin(), content_types="photo", state="here_change_artist_photo")
@dp.message_handler(IsAdminorShopAdmin(), text="0", state="here_change_artist_photo")
async def product_artist_edit_photo_get(message: Message, state: FSMContext):
    async with state.proxy() as data:
        artist_id = data['here_cache_artist_id']
        user_id = data['here_cache_user_id']
        remover = data['here_cache_artist_remover']
    await state.finish()

    artist = get_artistx(artist_id = artist_id)
    print(artist['name'])

    artist_photo = "" if "text" in message else message.photo[-1].file_id
    update_artistx(artist_id, logo=artist_photo)
    get_message, get_photo = get_artist_admin(artist_id)
    await notify(dp, f"Был отредактирован артист: {artist['name']}")

    if get_photo is not None:
        await message.answer_photo(get_photo, get_message,
                                   reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
    else:
        await message.answer(get_message, reply_markup=artist_edit_open_finl(artist_id, user_id, remover))


# Изменение города продукта
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit_city", state="*")
async def product_position_edit_description(call: CallbackQuery, state: FSMContext):
    print('Изменение города артиста  admin_products.py 715')
    print(call.data)
    artist_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    current_city = get_city_artist(artist_id=artist_id)[0]

    # await state.update_data(here_cache_category_id=category_id)
    # await state.update_data(here_cache_position_id=position_id)
    # await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_city_artist")
    await state.update_data({'artist_id': artist_id, 'user_id': user_id, 'remover': remover})
    await call.message.delete()
    await call.message.answer("<b>📁 Выберите другой город 🏙</b>\n"
                              "❕ Вы можете использовать геолокацию или выбрать город из списка\n"
                              f"❕ Город артиста: <code>{current_city}</code>", reply_markup=geo_1_kb())


# принятие новой геопозиции для позиции
@dp.callback_query_handler(text_startswith='geo_chosen_cities', state='here_change_city_artist')
async def geo_5(cb: CallbackQuery, state: FSMContext):
    info = int(str(cb.data).split('#')[1])
    if info == 0:
        async with state.proxy() as data:
            city = data['city']
            artist_id = int(data['artist_id'])
            user_id = data['user_id']
            remover = data['remover']
            city_id = data['city_id']

    else:
        async with state.proxy() as data:
            artist_id = int(data['artist_id'])
            user_id = data['user_id']
            remover = data['remover']

        city_id = info
        city = get_city_info(info)

    await state.finish()
    update_artist_city(city, city_id, artist_id)

    # update_positionx(position_id)
    get_message, get_photo = get_artist_admin(artist_id)

    if get_photo is not None:
        await cb.message.answer_photo(get_photo, get_message,
                                      reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
    else:
        await cb.message.answer(get_message,
                                reply_markup=artist_edit_open_finl(artist_id, user_id, remover))

# Удаление позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit_delete", state="*")
async def artist_edit_delete(call: CallbackQuery, state: FSMContext):
    artist_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_artist_id=artist_id)
    await state.update_data(here_cache_user_id=user_id)
    await state.update_data(here_cache_artist_remover=remover)

    await call.message.delete()
    await call.message.answer(_("<b>📁 Вы действительно хотите удалить позицию? ❌</b>", locale=lang),
                              reply_markup=artist_edit_delete_finl())


# Подтверждение удаления позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_delete", state="*")
async def artist_edit_delete_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    async with state.proxy() as data:
        artist_id = data['here_cache_artist_id']
        user_id = data['here_cache_user_id']
        remover = data['here_cache_artist_remover']
    await state.finish()

    if get_action == "yes":
        #remove_itemx(position_id=position_id)
        remove_artistx(artist_id=artist_id)

        await call.answer("📁 Вы успешно удалили артиста ✅")

        if len(get_artistx(admin=user_id)) >= 1:
            await call.message.edit_text("<b>📁 Выберите нужного Вам артиста 🖍</b>",
                                         reply_markup=artist_edit_open_fp(remover, user_id))
        else:
            await call.message.delete()
    else:
        get_message, get_photo = get_artist_admin(artist_id)

        if get_photo is not None:
            await call.message.delete()
            await call.message.answer_photo(get_photo, get_message,
                                            reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
        else:
            await call.message.edit_text(get_message,
                                         reply_markup=artist_edit_open_finl(artist_id, user_id, remover))

# Просмотр истории покупок
@dp.callback_query_handler(text="user_history", state="*")
async def user_history(call: CallbackQuery, state: FSMContext):
    last_purchases = last_purchasesx(call.from_user.id, 5)

    if len(last_purchases) >= 1:
        await call.answer("🎁 Последние 5 покупок")
        await call.message.delete()

        for purchases in last_purchases:
            link_items = await upload_text(call, purchases['purchase_item'])

            await call.message.answer(f"<b>🧾 Чек: <code>#{purchases['purchase_receipt']}</code></b>\n"
                                      f"🎁 Товар: <code>{purchases['purchase_position_name']} | {purchases['purchase_count']}шт | {purchases['purchase_price']}₽</code>\n"
                                      f"🕰 Дата покупки: <code>{purchases['purchase_date']}</code>\n"
                                      f"🔗 Товары: <a href='{link_items}'>кликабельно</a>")

        await call.message.answer(open_profile_my(call.from_user.id), reply_markup=profile_open_inl)
    else:
        await call.answer("❗ У вас отсутствуют покупки", True)


# Возвращение к профилю
@dp.callback_query_handler(text="user_profile", state="*")
async def user_profile_return(call: CallbackQuery, state: FSMContext):
    await call.message.edit_text(open_profile_my(call.from_user.id), reply_markup=profile_open_inl)


# Возвращение к корзине
@dp.callback_query_handler(text="user_cart", state="*")
async def user_cart_return(call: CallbackQuery, state: FSMContext):
    user_id = call.from_user.id
    get_user = get_userx(user_id=user_id)

    orderdata = get_params_orderx(user_id=user_id)

    #cart_state = orderdata['order_state']
    for order in orderdata:
        order_id = orderdata['order_id']
        #await call.message.edit_text(open_cart_orders(call.from_user.id), reply_markup=cart_open_+{'cart_state'}+_inl)
        if order['order_state'] == 'created':
            await call.message.answer(open_cart_orders(order_id, user_id), reply_markup=open_cart_created_finl(orderdata['order_id']))
        if order['order_state'] == 'delivery':
            await call.message.answer(open_cart_orders(order_id , user_id), reply_markup=open_cart_delivery_finl(orderdata['order_id']))
        if order['order_state'] == 'submited':
            await call.message.answer(f"<b>🎁 Активных заказов нет.</b>\n")

################################################################################################
######################################### ПОКУПКА ТОВАРА #######################################
########################################### КАТЕГОРИИ ##########################################
# Открытие категорий для покупки
@dp.callback_query_handler(text_startswith="buy_category_open:", state="*")
async def user_purchase_category_open(call: CallbackQuery, state: FSMContext):
    print('Открытие категорий для покупки user_menu.py 133')
    category_id = int(call.data.split(":")[1])

    source = "commercial"
    get_category = get_categoryx(category_id=category_id)
    city_id = get_city_user(call.from_user.id)[0]
    get_positions = get_positions_in_cityx(category_id=category_id, position_city_id=city_id, flagallc=1, position_type=1)  # get_positionsx(category_id=category_id)
    print(category_id, city_id)
    if len(get_positions) >= 1:
        await call.message.edit_text(f"<b>🎁 Товары категории: {get_category['category_name']}</b>",
                                     reply_markup=products_item_position_swipe_fp(0, category_id, city_id, "commercial"))
    else:
        await call.answer(f"❕ Товары в категории {get_category['category_name']} отсутствуют")

######################################### ПОКУПКА ТОВАРА #######################################
########################################### КАТЕГОРИИ ##########################################
# Открытие категорий для покупки
@dp.callback_query_handler(text_startswith="buy_people_category_open:", state="*")
async def user_purchase_category_open(call: CallbackQuery, state: FSMContext):
    print('Открытие категорий для покупки user_menu.py 133')
    category_id = int(call.data.split(":")[1])

    get_category = get_categoryx(category_id=category_id)
    city_id = get_city_user(call.from_user.id)[0]
    get_positions = get_positions_in_cityx(category_id=category_id, position_city_id=city_id, flagallc=1, position_type=1)  # get_positionsx(category_id=category_id)
    print(category_id, city_id)
    if len(get_positions) >= 1:
        source = "people"
        await call.message.edit_text(f"<b>🎁 Товары категории: {get_category['category_name']}</b>",
                                     reply_markup=products_item_position_swipe_fp(0, category_id, city_id, source))
    else:
        await call.answer(f"❕ Товары в категории {get_category['category_name']} отсутствуют")

# Вернуться к категориям для покупки
@dp.callback_query_handler(text_startswith="buy_category_return", state="*")
async def user_purchase_category_return(call: CallbackQuery, state: FSMContext):
    get_categories = get_all_categoriesx()
    get_settings = get_settingsx()
    city_id = 0
    if get_settings['type_trade'] != 'digital':
        city_id = get_city_user(call.from_user.id)[0]

    if len(get_categories) >= 1:
        await call.message.edit_text(f"<b>🎁 Товары категории: {get_category['category_name']}</b>",
                                     reply_markup=products_item_category_swipe_fp(0, city_id))
    else:
        await call.message.edit_text(_("<b>🎁 Товары в данное время отсутствуют.</b>", locale=lang))
        await call.answer("❗ Категории были изменены или удалены")


# Следующая страница категорий для покупки
@dp.callback_query_handler(text_startswith="buy_category_nextp", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text(f"<b>🎁 Товары категории: {get_category['category_name']}</b>",
                                 reply_markup=products_item_category_next_page_fp(remover))


# Предыдущая страница категорий для покупки
@dp.callback_query_handler(text_startswith="buy_category_backp", state="*")
async def user_purchase_category_prev_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text(f"<b>🎁 Товары категории: {get_category['category_name']}</b>",
                                 reply_markup=products_item_category_back_page_fp(remover))

############################################ МАГАЗИН => КАТЕГОРИИ #############################
########################################### МАГАЗИНЫ ##########################################
# Открытие магазина для покупки
@dp.callback_query_handler(text_startswith="buy_shop_open", state="*")
async def user_purchase_category_open(call: CallbackQuery, state: FSMContext):
    print('Открытие магазина для покупки user_menu.py 1902')
    shop_id = int(call.data.split(":")[1])
    #get_shop = get_shopx(shop_id=shop_id)
    get_shop = get_shopsxx(shop_id=shop_id)
    print(get_shop)
    #if get_shop[8] != None: logo = get_shop[8]
    user_id = call.from_user.id
    city_id = get_city_user(user_id)[0]
    get_positions = get_shopposition_on_city(shop_id, city_id)  # get_positionsx(category_id=category_id)

    if len(get_positions) >= 1:
        #if get_shop['logo'] != None or get_place['logo'] != '':
        logo = get_shop[0]['logo']
        await call.message.answer_photo(logo, f"<b>Магазин : {get_shop[0]['name']}</b>\n" \
                                              f"Адрес : {get_shop[0]['address']}\n" \
                                              f"Телефон : {get_shop[0]['phone']}\n" \
                                              f"О магазине : {get_shop[0]['description']}")
        #await call.message.answer_photo(logo, "<b>🎁 Выберите нужный вам товар:</b>",
        #                                    reply_markup=products_shopitem_position_swipe_fp(0, shop_id, city_id))
        #else:
        #media = types.MediaGroup()
        #media.attach_photo(types.InputFile('media/Starbucks_Logo.jpg'), 'Превосходная фотография')
        #media.attach_photo(types.InputFile('media/Starbucks_Logo_2.jpg'), 'Превосходная фотография 2')
        #await bot.send_media_group(call.message.chat.id, media=media)

        await call.message.answer(f"<b>🎁 Товары магазина: {get_shop[0]['name']}</b>",
                                  reply_markup=products_shopitem_position_swipe_fp(0, shop_id, city_id))
    else:
        await call.answer(f"❕ Товары в магазине {get_shop[2]} отсутствуют")


# Открытие магазина для покупки
@dp.callback_query_handler(text_startswith="book_place_open", state="*")
async def user_purchase_category_open(call: CallbackQuery, state: FSMContext):
    print('Открытие магазина для покупки user_menu.py 133')
    place_id = int(call.data.split(":")[1])
    #get_shop = get_shopx(shop_id=shop_id)
    get_place = get_placesx(place_id=place_id)
    print(get_place)
    #if get_shop[8] != None: logo = get_shop[8]
    user_id = call.from_user.id
    city_id = get_city_user(user_id)[0]
    print("|||")
    print(city_id, get_place['place_id'])
    #print(remover, place_id, city_id)
    #get_events = get_events_in_place(place_id)  # get_positionsx(category_id=category_id)

    if get_place['place_id'] != "":
        print("|||->")
        logo = get_place['logo']
        await call.message.answer_photo(logo, f"<b>Место : {get_place['name']}</b>\n" \
                                              f"Адрес : {get_place['address']}\n" \
                                              f"Телефон : {get_place['phone']}")

        await call.message.answer("<b>Выберите что-нибудь интересное:</b>",
                                  reply_markup=events_in_place_swipe_fp(0, place_id, city_id))
    else:
        await call.answer(f"❕Cобытия места не загружены: {get_place['name']}, уточнить можно по телефону: {get_place['phone']}")


# Открытие магазина для покупки
@dp.callback_query_handler(text_startswith="book_event_open", state="*")
async def user_evebt_in_city_open(call: CallbackQuery, state: FSMContext):
    print('Открытие городских событий user_menu.py 1368')
    event_id = int(call.data.split(":")[1])
    get_event = get_eventxx(event_id=event_id)
    #city_id = int(call.data.split(":")[1])
    #get_shop = get_shopx(shop_id=shop_id)
    #get_events_in_city
    #get_shop = get_shopsxx(place_id=place_id)
    print(get_event)
    #if get_shop[8] != None: logo = get_shop[8]
    user_id = call.from_user.id
    #city_id = get_city_user(user_id)[0]
    get_positions = get_shopposition_on_city(shop_id, city_id)  # get_positionsx(category_id=category_id)

    if len(get_positions) >= 1:
        #if get_shop['logo'] != None:
        logo = get_shop[0]['logo']
        await call.message.answer_photo(logo, f"<b>Магазин : {get_shop[0]['name']}</b>\n" \
                                              f"Адрес : {get_shop[0]['address']}\n" \
                                              f"Телефон : {get_shop[0]['phone']}\n" \
                                              f"О магазине : {get_shop[0]['description']}")
        #await call.message.answer_photo(logo, "<b>🎁 Выберите нужный вам товар:</b>",
        #                                    reply_markup=products_shopitem_position_swipe_fp(0, shop_id, city_id))
        #else:
        #media = types.MediaGroup()
        #media.attach_photo(types.InputFile('media/Starbucks_Logo.jpg'), 'Превосходная фотография')
        #media.attach_photo(types.InputFile('media/Starbucks_Logo_2.jpg'), 'Превосходная фотография 2')
        #await bot.send_media_group(call.message.chat.id, media=media)

        await call.message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                  reply_markup=products_shopitem_position_swipe_fp(0, shop_id, city_id))
    else:
        await call.answer(f"❕ Товары в магазине {get_shop[2]} отсутствуют")

########################################### ПОЗИЦИИ ##########################################
# Открытие позиции для покупки
@dp.callback_query_handler(text_startswith="book_event_open2:", state="*")
async def user_purchase_position_open(call: CallbackQuery, state: FSMContext):
    print('Карточка товара: user_menu.py  1194')
    event_id = int(call.data.split(":")[1])
    #link = await get_start_link(str(f"deep_link&event_id&{event_id}"), encode=True)

    print(event_id)
    get_event = get_eventx(event_id=event_id)
    #if category_id != 0: get_category = get_categoryx(category_id=category_id)
    #else: get_category['category_name'] = 0
    #get_items = get_itemsx(position_id=position_id)
    get_settings = get_settingsx()
    #get_shop = get_shopx(shop_id=shop_id)
    print("|")

    if get_event['event_description'] == "0":
        text_description = ""
    else:
        text_description = f"\n📜 Описание:\n" \
                           f"{get_event['event_description']}"
    #get_shop['name']
    send_msg = f"<b>Карточка:</b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"🏷 Название: <code>{get_position['position_name']}</code>\n" \
               f"🏙 Магазин: <code>{get_shop['name']}</code>\n" \
               f"🏙 Город: <code>{get_position['position_city']}</code>\n" \
               f"🗃 Категория: <code></code>\n" \
               f"💰 Стоимость: <code>{get_position['position_price']}₽</code>\n" \
               f"{text_description}"
    #{get_category['category_name']}
    #f"📦 Остаток: <code>{len(get_items)}шт</code>" \
    print(get_settings['type_trade'])
    tt = get_settings['type_trade']
    print("||")

    if tt != "digital":
        print("|||-")
        #    product_markup = products_open_finl(position_id, remover, category_id)
        # product_markup = products_open_cart_finl(position_id, remover, category_id)
        if len(get_position['position_photo']) >= 5:
            await call.message.delete()
            await call.message.answer_photo(get_position['position_photo'],
                                            send_msg, reply_markup=products_open_finl(1, position_id, remover, 0, shop_id))
        else:
            await call.message.edit_text(send_msg,
                                         reply_markup=products_open_finl(1, position_id, remover, 0, shop_id))
    else:
        print("|||--")
        if len(get_position['position_photo']) >= 5:
            await call.message.delete()
            await call.message.answer_photo(get_position['position_photo'],
                                            send_msg, reply_markup=products_open_finl(0, position_id, remover, 0, shop_id))
        else:
            await call.message.edit_text(send_msg,
                                         reply_markup=products_open_finl(0, position_id, remover, 0, shop_id))

# Вернуться к категориям для покупки
@dp.callback_query_handler(text_startswith="buy_parcategory_return", state="*")
async def user_purchase_category_return(call: CallbackQuery, state: FSMContext):
    get_categories = get_all_categoriesx()
    get_settings = get_settingsx()
    city_id = 0
    if get_settings['type_trade'] != 'digital':
        city_id = get_city_user(call.from_user.id)[0]

    if len(get_categories) >= 1:
        await call.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                     reply_markup=products_item_shop_open_fp(0, shop_id, city_id))
    else:
        await call.message.edit_text(_("<b>🎁 Товары в данное время отсутствуют.</b>", locale=lang))
        await call.answer("❗ Категории были изменены или удалены")

########################################### ПОЗИЦИИ ##########################################
# Открытие позиции для покупки
@dp.callback_query_handler(text_startswith="buy_parposition_open:", state="*")
async def user_purchase_position_open(call: CallbackQuery, state: FSMContext):
    print('Карточка товара: user_menu.py  um2082')
    if call.data.split(":")[4]: city_id = 0
    position_id = int(call.data.split(":")[1])
    #category_id = int(call.data.split(":")[2])
    shop_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    #city_id = int(call.data.split(":")[4])

    print(position_id, shop_id, remover, city_id)
    link = await get_start_link(str(f"deep_link&position_id&{position_id}"), encode=True)
    get_position = get_positionx(position_id=position_id)
    #if category_id != 0: get_category = get_categoryx(category_id=category_id)
    #else: get_category['category_name'] = 0
    get_items = get_itemsx(position_id=position_id)
    get_settings = get_settingsx()
    get_shop = get_shopx(shop_id=shop_id)
    print("|")

    if get_position['position_description'] == "0":
        text_description = ""
    else:
        text_description = f"\n📜 Описание:\n" \
                           f"{get_position['position_description']}"
    #get_shop['name']
    send_msg = f"<b>Карточка:</b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"🏷 Название: <code>{get_position['position_name']}</code>\n" \
               f"🏷 Ссылка: <code>{link}</code>\n" \
               f"🏙 Магазин: <code>{get_shop['name']}</code>\n" \
               f"🏙 Город: <code>{get_position['position_city']}</code>\n" \
               f"🗃 Категория: <code></code>\n" \
               f"💰 Стоимость: <code>{get_position['position_price']}₽</code>\n" \
               f"{text_description}"
    #{get_category['category_name']}
    #f"📦 Остаток: <code>{len(get_items)}шт</code>" \
    print(get_settings['type_trade'])
    tt = get_settings['type_trade']
    print("||")

    if tt != "digital":
        print("|||-")
        #    product_markup = products_open_finl(position_id, remover, category_id)
        # product_markup = products_open_cart_finl(position_id, remover, category_id)
        if len(get_position['position_photo']) >= 5:
            await call.message.delete()
            await call.message.answer_photo(get_position['position_photo'],
                                            send_msg, reply_markup=products_open_finl(1, position_id, remover, 0, shop_id))
        else:
            await call.message.edit_text(send_msg,
                                         reply_markup=products_open_finl(1, position_id, remover, 0, shop_id))
    else:
        print("|||--")
        if len(get_position['position_photo']) >= 5:
            await call.message.delete()
            await call.message.answer_photo(get_position['position_photo'],
                                            send_msg, reply_markup=products_open_finl(0, position_id, remover, 0, shop_id))
        else:
            await call.message.edit_text(send_msg,
                                         reply_markup=products_open_finl(0, position_id, remover, 0, shop_id))

# Вернуться к позициям для покупки
@dp.callback_query_handler(text_startswith="buy_parposition_return", state="*")
async def user_purchase_position_return(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    #category_id = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])
    shop_id = int(call.data.split(":")[2])
    print("buy_parposition_return")

    get_positions = get_all_positionsx()
    city_id = get_city_user(call.from_user.id)[0]

    if len(get_positions) >= 1:
        await call.message.delete()
        await call.message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                  reply_markup=products_shopitem_position_open_fp(remover, shop_id, city_id))
    else:
        await call.message.edit_text(_("<b>🎁 Товары в данное время отсутствуют.</b>", locale=lang))
        await call.answer("❗ Позиции были изменены или удалены")

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="buy_parcategory_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                 reply_markup=products_item_category_swipe_fp(remover))

# Переключение страницы позиций для покупки
@dp.callback_query_handler(text_startswith="buy_parposition_swipe:", state="*")
async def user_purchase_position_next_page(call: CallbackQuery, state: FSMContext):
    shop_id = call.data.split(":")[1]
    remover = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])

    get_shop = get_shopx(shop_id=shop_id)

    await call.message.edit_text(f"<b>🎁 Текущий магазин: <code>{get_shop['name']}</code></b>",
                                 reply_markup=products_shopitem_position_swipe_fp(remover, shop_id, city_id))

# Переключение страницы позиций для покупки
@dp.callback_query_handler(text_startswith="buy_position_swipe:", state="*")
async def user_purchase_position_next_page(call: CallbackQuery, state: FSMContext):
    category_id = call.data.split(":")[1]
    remover = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])

    source = "commercial"

    get_category = get_categoryx(category_id=category_id)

    await call.message.edit_text(f"<b>🎁 Текущая категория: <code>{get_category['category_name']}</code></b>",
                                 reply_markup=products_item_position_swipe_fp(remover, category_id, city_id, source))

# Открытие позиции для покупки
@dp.callback_query_handler(text_startswith="buy_position_open:", state="*")
async def user_purchase_position_open(call: CallbackQuery, state: FSMContext):
    print('Карточка товара: user_menu.py  152')
    position_id = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    city_id = int(call.data.split(":")[4])
    print(position_id, category_id, remover, city_id)
    get_category = ""
    category = ""
    #link = await get_start_link(str(f"buy_position_open:{position_id}:0:0:0"), encode=True)
    link = await get_start_link(str(f"deep_link&position_id&{position_id}"), encode=True)

    get_position = get_positionx(position_id=position_id)
    position_source = get_position['source']
    if position_source == "commercial":
        get_category = get_categoryx(category_id=category_id)
        category = get_category['category_name']
    elif position_source == "people":
        get_category = get_category_people(category_id=category_id)
        category = get_category['category']
    #get_items = get_itemsx(position_id=position_id)
    get_settings = get_settingsx()

    if get_position['position_description'] == "0":
        text_description = ""
    else:
        text_description = f"\n📜 Описание:\n" \
                           f"{get_position['position_description']}"

    send_msg = f"<b>Карточка:</b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"🏷 Название: <code>{get_position['position_name']}</code>\n" \
               f"🏷 Ссылка: <code>{link}</code>\n" \
               f"🏙 Город: <code>{get_position['position_city']}</code>\n" \
               f"🗃 Категория: <code>{category}</code>\n" \
               f"💰 Стоимость: <code>{get_position['position_price']}₽</code>\n" \
               f"{text_description}"

    #f"🏷 Ссылка: <code>{link}</code>\n" \
    #f"📦 Остаток: <code>{len(get_items)}шт</code>" \
    print(get_settings['type_trade'])
    tt = get_settings['type_trade']

    if tt == "digital":
        if len(get_position['position_photo']) >= 5:
            await call.message.delete()
            await call.message.answer_photo(get_position['position_photo'],
                                            send_msg, reply_markup=products_open_finl(0, position_id, remover, category_id, 0))
        else:
            await call.message.edit_text(send_msg,
                                         reply_markup=products_open_finl(0, position_id, remover, category_id, 0))

    elif len(get_position['position_photo']) >= 5:
        await call.message.delete()
        await call.message.answer_photo(get_position['position_photo'],
                                        send_msg, reply_markup=products_open_finl(1, position_id, remover, category_id, 0))
    else:
        await call.message.edit_text(send_msg,
                                     reply_markup=products_open_finl(1, position_id, remover, category_id, 0))

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="artist_edit_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])

    await call.message.edit_text(_("<b>🎁 Выберите нужного артиста:</b>", locale=lang),
                                 reply_markup=artist_edit_open_fp(remover, user_id))

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="buy_people_category_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    level = int(call.data.split(":")[3])
    parent = int(call.data.split(":")[4])
    city_id = int(call.data.split(":")[5])
    action = call.data.split(":")[6]


    await call.message.edit_text(_("<b>🌐 Выберите категорию:</b>", locale=lang),
                                 reply_markup=position_people_create_open_fp(category_id, remover, level, parent, city_id, action))

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="buy_category_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    city_id = int(call.data.split(":")[2])

    await call.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                 reply_markup=products_item_category_swipe_fp(remover, city_id))

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="buy_shop_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    city_id = int(call.data.split(":")[2])

    await call.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                 reply_markup=products_item_shop_swipe_fp(remover, city_id))

# Вернуться к позициям для покупки
@dp.callback_query_handler(text_startswith="buy_position_return", state="*")
async def user_purchase_position_return(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    shop_id = int(call.data.split(":")[3])

    #get_positions = get_all_positionsx()
    city_id = get_city_user(call.from_user.id)[0]
    print(remover, category_id, shop_id, city_id)
    print("buy_position_return")
    source = "commercial"

    #if len(get_positions) >= 1:
    await call.message.delete()
    if shop_id == 0:
        print("||||--=")
        await call.message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                  reply_markup=products_item_position_swipe_fp(remover, category_id, city_id, commercial))
    elif category_id == 0:
        print("||||--==---")
        await call.message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                  reply_markup=products_shopitem_position_swipe_fp(remover, shop_id, city_id, commercial))
    #else:
    #    await call.message.edit_text("<b>🎁 Товары в данное время отсутствуют.</b>")
    #    await call.answer("❗ Позиции были изменены или удалены")


########################################### ПОКУПКА ##########################################
# Выбор количества товаров в корзине
@dp.callback_query_handler(text_startswith="add_item_cart", state="*")
async def user_purchase_addcart(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])
    print("Добавление в корзину")
    get_position = get_positionx(position_id=position_id)
    print(get_position)
    get_user = get_userx(user_id=get_position['position_user_id'])

    get_payments = get_upaymentx(get_position['position_user_id'])

    if get_position['position_type'] == 1:
        get_count = get_position['position_rest']
    elif get_position['position_type'] == 2:
        get_items = get_itemsx(position_id=position_id)
        get_count = len(get_items)

    await state.update_data(here_cache_position_type = get_position['position_type'])
    await state.update_data(here_cache_get_count = get_count)

    if get_payments['way_freecredi'] == 'True':
        #skipchkbalance = 1
        await state.update_data(here_cache_skipchkbalance = 1)

    source = get_position['source']

    if get_count == 1:
        await state.update_data(here_cache_position_id=position_id)
        await state.finish()

        await call.message.delete()
        await call.message.answer(f"<b>1 шт. в наличии. Добавить товар(ы) в корзину?</b>\n"
                                  f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                  f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                  f"📦 Остаток: <code>1шт</code>\n"
                                  f"💰 Сумма к покупке: <code>{get_position['position_price']}₽</code>",
                                  reply_markup=products_addcart_confirm_finl(position_id, 1))
    elif get_count >= 1:
        await state.update_data(here_cache_position_id=position_id)
        await state.set_state("here_itemsadd_cart")

        await call.message.delete()
        await call.message.answer(f"<b>🎁 Введите количество товаров для покупки</b>\n"
                                  f"▶ От <code>1</code> до <code>{get_count}</code>\n"
                                  f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                  f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n"
                                  f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>")
    else:
        await call.answer("🎁 Товара нет в наличии")


# Принятие количества товаров в корзине
@dp.message_handler(state="here_itemsadd_cart")
async def user_purchase_select_count(message: Message, state: FSMContext):
    position_id = (await state.get_data())['here_cache_position_id']
    get_position = get_positionx(position_id=position_id)
    #user_id=message.from_user.id
    #данные пользователя
    get_user = get_userx(user_id=get_position['position_user_id'])
    #данные платежных систем
    get_payments = get_upaymentx(get_position['position_user_id'])
    #данные пользователя
    get_user = get_userx(user_id=message.from_user.id)

    skipchkbalance = 1 if get_payments['way_freecredi'] == 'True' else 0
    get_count = (await state.get_data())['here_cache_get_count']
    position_type = (await state.get_data())['here_cache_position_type']

    if position_type == 1:
        get_items = get_position['position_rest']
        get_count = get_position['position_rest']
        if get_position['position_price'] != 0 and skipchkbalance != 1:
            get_count_balance = int(get_user['user_balance'] / get_position['position_price'])

    elif position_type == 2:
        get_items = get_itemsx(position_id=position_id)
        get_count = len(get_items)
        get_count = min(get_count, len(get_items))

    #else:
    #    get_count = len(get_items)


    send_message = f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                   f"🎁 Введите количество товаров для покупки\n" \
                   f"▶ От <code>1</code> до <code>{get_count}</code>\n" \
                   f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                   f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n" \
                   f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>"

    if message.text:  # .isdigit()
        get_buy = int(message.text)
        amount_pay = int(get_position['position_price']) * get_buy
        print(get_count)


        if position_type == 1 and get_count >= 1: #len(get_items) >= 1 and position_type == 2
            #if int(get_user['user_balance']) >= amount_pay:
            await state.finish()
            await message.answer(f"<b>🎁 Вы действительно хотите добавить в корзину товар(ы)?</b>\n"
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                 f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                 f"📦 Остаток: <code>{get_count}шт</code>\n"
                                 f"💰 Сумма добавляемых товаров: <code>{amount_pay}₽</code>",
                                 reply_markup=products_addcart_confirm_finl(position_id, get_buy))
        else:
            await state.finish()
            await message.answer(_("<b>🎁 Товар который вы хотели купить, закончился</b>", locale=lang))
    else:
        await message.answer(f"<b>❌ Данные были введены неверно.</b>\n{send_message}")


# Подтверждение добавления товара в корзину
@dp.callback_query_handler(text_startswith="xaddcart_item", state="*")
async def user_addcart_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    get_buy = int(call.data.split(":")[3])
    get_position = get_positionx(position_id=position_id)
    if get_action == "yes":
        await call.message.edit_text(_("<b>🔄 Ждите, товары подготавливаются</b>", locale=lang))

        get_position = get_positionx(position_id=position_id)

        position_type = get_position['position_type']

        if position_type == 1:
            get_count = get_position['position_rest']
            get_items = get_count
        elif position_type == 2:
            get_items = get_itemsx(position_id=position_id)
            get_count = len(get_items)

        get_user = get_userx(user_id=call.from_user.id)

        amount_pay = int(get_position['position_price'] * get_buy)

        if position_type == 1:
            await notify(dp, f"Позиция: {get_position['position_name']} добавлена в корзину пользователем: {call.from_user.id}.")

            send_count = get_buy
            # уточнение цены за количество в наличии
            if get_buy != send_count:
                amount_pay = int(get_position['position_price'] * send_buy)

                #get_count = send_count

            receipt = get_unix()
            add_time = get_date()
            print(add_time)

            await call.message.delete()

            # if split_len == 0:
            #    await call.message.answer("\n\n".join(save_items), parse_mode="None")
            # else:
            #    for item in split_messages(save_items, split_len):
            #        await call.message.answer("\n\n".join(item), parse_mode="None")
            #        await asyncio.sleep(0.3)
            await asyncio.sleep(0.3)
            #users_order = get_user_orderx(get_user['user_id'])
            users_order = get_params_orderx(user_id=get_user['user_id'], order_state='created')
            print(users_order)
            alength = len(users_order)
            i = 0
            for i in range(alength):
                print(users_order[i]['order_id'])

            print('test2')
            #print(users_order['order_id'])

            if not users_order:
                create_orderx(call.from_user.id, get_user['user_login'], get_user['user_name'], 'created', str(add_time),
                              receipt)
                users_order = get_params_orderx(user_id=get_user['user_id'], order_state='created')
                #print(users_order['order_id'])
            print('test3')
            for i in range(alength):
                print(users_order[i]['order_id'])
            order_id = users_order[i]['order_id']
            # price = int(get_position['position_price'])

            add_order_itemx(call.from_user.id, order_id, position_id, get_buy, get_position['position_price'], receipt, get_position['position_user_id'])
            new_position_rest = int(get_position['position_rest']) - get_buy
            update_positionx(get_position['position_id'], position_rest=new_position_rest)
            # add_order_itemx(1, 1, 1, 1, 1)
            auser = (
                get_user['user_login']
                if len(get_user['user_login']) >= 1
                else get_user['user_id']
            )
            await notify(dp, f"Позиция: {get_position['position_name']} добавлена в корзину. Пользователь: @{auser}.")

            await call.message.answer(f"<b>✅ Вы успешно добавили товар(ы) в корзину</b>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🧾 Чек: <code>#{receipt}</code>\n"
                                      f"🎁 Товар: <code>{get_position['position_name']} | {get_count}шт | {amount_pay}₽</code>\n"
                                      f"🕰 Дата покупки: <code>{add_time}</code>",
                                      reply_markup=menu_frep(call.from_user.id))
        elif position_type == 2:
            if 1 <= get_buy <= len(get_items):
                save_items, send_count, split_len = buy_itemx(get_items, get_buy)
                await notify(dp, f"Позиция: {get_position['position_name']} добавлена в корзину пользователем: {call.from_user.id}.")
            await call.message.answer(_("<b>🎁 Товар который вы хотели купить закончился или изменился.</b>", locale=lang),
                                      reply_markup=menu_frep(call.from_user.id))
        else:
            await call.message.answer(_("<b>🎁 Товар который вы хотели купить закончился или изменился.</b>", locale=lang),
                                      reply_markup=menu_frep(call.from_user.id))
    elif len(get_all_categoriesx()) >= 1:
        await call.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                     reply_markup=category_edit_open_fp(0))
    else:
        await call.message.edit_text(_("<b>✅ Вы отменили покупку товаров.</b>", locale=lang))


# Удаление корзины
@dp.callback_query_handler(text_startswith="del_user_cart", state="*")
async def del_user_cart(call: CallbackQuery, state: FSMContext):
    order_id = int(call.data.split(":")[1])
    print("||||")
    await state.finish()
    await call.message.edit_text(_("<b> Удалить корзину и ее позиции?</b>", locale=lang),
                                 reply_markup=confirm_delete_user_cart_inl(order_id))

# Подтверждение удаления корзины
@dp.callback_query_handler(text_startswith="confirm_del_user_cart", state="*")
async def confirm_del_user_cart(call: CallbackQuery, state: FSMContext):
    order_id = int(call.data.split(":")[1])
    print(order_id)
    user_id=call.from_user.id
    print(user_id)
    #order=get_orderx(user_id=user_id)
    order_id=order['order_id']
    #возврат количества в товаров в позиции
    # перебор корзины = > количество каждой позиции - ++++ к остатку TODO
    orderdata = get_orderxo(order_id=order_id)
    print(orderdata)
    ouser_id = orderdata['user_id']
    oget_user = get_userx(user_id=ouser_id)
    user_role = oget_user['user_role']
    print(user_role)
    #получаем баланс пользователя
    ub = oget_user['user_balance']
    #username
    if oget_user['user_login']:
        userid = f"Логин пользователя: <code>@{oget_user['user_login']}</code>"
    else: userid = f"Телеграм ID: <code>{oget_user['user_id']}</code>"
    #позиции заказа
    get_positions = []
    get_positions = get_cart_positionsx(order_id=order_id)

    this_items = []
    this_itemst = this_itemst2 = this_itemst3 = ''
    for position in get_positions:
        current_position = get_positionx(position_id=position['position_id'])
        new_position_rest = current_position['position_rest'] + position['count']
        update_positionx(position['position_id'], position_rest=new_position_rest)

    remove_ordersx(order_id=order_id)
    remove_orders_itemx(order_id=order_id)

    print("|||| -   - ||||")
    await call.message.edit_text(f"<b>✅ Вы удалили корзину #{order_id}.</b>")


#######################################################################################
# **************************  CHECK OUT CART ******************************************
#######################################################################################

# Оформление заказа по корзине - Адрес
@dp.callback_query_handler(text_startswith="checkout_start", state="*")
async def checkout_start(call: CallbackQuery, state: FSMContext):
    order_id = int(call.data.split(":")[1])
    print(order_id)
    user_id = call.from_user.id
    get_user = get_userx(user_id=user_id)
    ub = get_user['user_balance']
    order_sum = calc_order_summ(order_id=order_id)
    dso = get_delivery_seller_options(order_id)['free_delivery_point']
    print(dso)
    #free_delivery_point = dso['free_delivery_point']
    #print(free_delivery_point)
    delivery_rate = get_delivery_seller_options(order_id)['delivery_rate']
    print(delivery_rate)
    #delivery = 200
    delivery = 0 if order_sum > dso else delivery_rate
    print(f"Доставка:{str(delivery)}")
    print("|||->")
    order_total = order_sum + delivery
    adr = geo = phone = 0
    #users_order = get_user_orderx(user_id)
    #order_id = users_order['order_id']
    touser_id = get_cart_sellersx(order_id)
    get_payment = get_upaymentx(user_id=touser_id) #True / False - постоплата
    freecredi_method = 1 if get_payment['way_freecredi'] else 0
    print(user_id)

    if get_user['user_address'] != "":
        print("Адрес есть")
        adr = 1
    if get_user['user_geocode'] != "":
        print("Геокод есть")
        geo = 1
    if get_user['user_phone'] != "":
        print("Телефон есть")
        phone = 1

    await call.message.answer(f"<b> Начинаем оформление заказа.</b>\n")

    if phone == 0:
        await state.set_state("enter_phone_auto")
        # await call.message.delete()
        # await call.message.answer(f"<b> Введите пожалуйста адрес доставки.</b>\n")

    if adr == 0:
        await state.set_state("enter_address_manualy")

    if ub < order_total and freecredi_method == 0:
        await state.set_state("user_balance_lower_than_cart")
        await call.message.delete()
        await call.message.answer(f"<b>Суммы на Вашем балансе не достаточно для оформления заказа.</b>\n"
                                  f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                  f" Баланс: <code>{ub}</code>\n"
                                  f" Сумма заказа: <code>{order_total}</code>\n",
                                  reply_markup=order_user_refill)
    else:
        await state.set_state("checkout_finish")
        await call.message.answer(f"<b>Продолхить оформление заказа:.</b>\n",
                                  reply_markup=checkout_step2_accept_finl(order_id))

    #await state.finish()


# Принятие адреса для доставки
#@dp.message_handler(state="checkout_finish")
#async def checkout_finish(message: Message, state: FSMContext):
@dp.callback_query_handler(text_startswith="checkout_finish:", state="*")
async def checkout_finish(call: CallbackQuery, state: FSMContext):
    order_id = int(call.data.split(":")[1])
    print('checkout_finish')
    print(order_id)
    #проверка - есть вопросы без ответов
    touser_id = call.from_user.id
    if cm := get_user_messagesx(to_uid=touser_id, state='created'):
        print(f"Messages present:{str(touser_id)}")
    #статус заказа - delivery
    print("|||->")
    #order_data = get_orderx(user_id=touser_id)
    #order_id = order_data['order_id']
    print("||||->>>>")
    print(order_id)
    os = update_orderx(order_id=order_id, order_state='delivery')
    await call.message.answer("<b>Начинаем доставку товара Вашей корзины.</b>")

    print('Сумма заказа на холде')
    order_sum = calc_order_summ(order_id=order_id)
    dso = get_delivery_seller_options(order_id)['free_delivery_point']
    print(dso)
    #free_delivery_point = dso['free_delivery_point']
    #print(free_delivery_point)
    delivery_rate = get_delivery_seller_options(order_id)['delivery_rate']
    print(delivery_rate)
    #delivery = 200
    delivery = 0 if order_sum > dso else delivery_rate
    print(f"Доставка:{str(delivery)}")
    print("||||-")
    amount = order_sum + delivery
    await notify(dp, f"Оформлен заказ: {order_id},\n"
                     f"пользователя: {touser_id}\n"
                     f"на сумму: {order_sum}\n"
                     f"с доставкой: {delivery}")

    #amount = order_data['order_total']
    buyer = touser_id
    print("||||--")
    order_sellers = get_order_sellers(order_id)
    print(order_sellers)
    if(len(order_sellers)>1): print("продавцов более 1")
    #for seller in order_sellers:
    print(type(order_sellers))
    order_sellers = order_sellers.strip('[[')
    order_sellers = order_sellers.strip(']]')
    #seller=list(order_sellers)
    get_payment = get_upaymentx(user_id=order_sellers) #True / False - постоплата
    freecredi_method = 1 if get_payment['way_freecredi'] else 0
    if freecredi_method == 0:
        state = 'created'
        validity = 5
        h = create_holdx(
            order_id,
            int(buyer),
            int(str(order_sellers)),
            int(amount),
            validity,
            state,
        )
        i = update_userx(user_id = buyer, user_hold = amount)
        await call.message.answer(f"<b>Денежные средства в размере {amount}р. успешно заблокированы до \n"
                                  f"подтверждения получения покупателем товара.</b>")
    elif freecredi_method == 1:
        await call.message.answer(
            "<b>Заказ начал выполняться. Подтвердите получение товара по факту.</b>"
        )

# Оформление заказа по корзине - Адрес
@dp.callback_query_handler(text_startswith="pay_after_delivery", state="*")
async def pay_after_delivery(call: CallbackQuery, state: FSMContext):
    order_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    print(order_id)
    order_sellers = get_order_sellers(order_id)
    print(order_sellers)
    if(len(order_sellers)>1): print("продавцов более 1")
    #for seller in order_sellers:
    print(type(order_sellers))
    order_sellers = order_sellers.strip('[[')
    order_sellers = order_sellers.strip(']]')
    print(order_sellers)
    get_payment = get_upaymentx(user_id=order_sellers) #True / False - постоплата
    if get_payment['way_freecredi']:
        freecredi_method = 1
        os = update_orderx(order_id=order_id, payafterdelivery=1)
        await call.message.answer(f"<b>Постоплата применена к заказу успешно!</b>\n")
    else:
        freecredi_method = 0
        await call.message.answer(f"<b>Постоплата не поддерживается продавцом по Вашему заказу!</b>\n")


# Оформление заказа по корзине - Адрес
@dp.callback_query_handler(text_startswith="submit_order", state="*")
async def submit_order(call: CallbackQuery, state: FSMContext):
    order_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    buyer_data = get_userx(user_id=user_id)
    print(buyer_data)
    #order_data = get_orderx(user_id=user_id)
    #order_id = order_data['order_id']

    order_sum = calc_order_summ(order_id=order_id)
    dso = get_delivery_seller_options(order_id)['free_delivery_point']
    print(dso)
    #free_delivery_point = dso['free_delivery_point']
    #print(free_delivery_point)
    delivery_rate = get_delivery_seller_options(order_id)['delivery_rate']
    print(delivery_rate)
    #delivery = 200
    delivery = 0 if order_sum > dso else delivery_rate
    print(f"Доставка:{str(delivery)}")
    print("||||-")
    amount = order_sum + delivery

    print(order_id)
    order_sellers = get_order_sellers(order_id)

    print(order_sellers)
    if(len(order_sellers)>1): print("продавцов более 1")
    #for seller in order_sellers:
    print(type(order_sellers))
    order_sellers = order_sellers.strip('[[')
    order_sellers = order_sellers.strip(']]')
    print(int(order_sellers))
    get_payment = get_upaymentx(user_id=int(order_sellers)) #True / False - постоплата
    print(get_payment)
    seller_data = ""
    if get_payment['way_freecredi']:
        freecredi_method = 1
        #транзакция с холдом
        seller_rest = int(seller_data['user_balance'])+int(amount)
    else:
        freecredi_method = 0
        hold_data = get_orders_holdsx(order_id)
        #hold_data = hold_data.strip('[')
        #hold_data = hold_data.strip(']')
        print(hold_data)
        #print(hold_data[0]['seller'])
        #seller
        seller_data = get_userx(user_id=hold_data[0]['seller'])
        print(seller_data)
        #hold_data['seller']
        #изменение статуса заказа   submitted
        #снятие холда с суммы заказа
        a = update_holdx(order_id = order_id, state = 'released')
        #транзакция с холдом
        seller_rest = int(seller_data['user_balance'])+int(hold_data[0]['amount'])
        buyer_rest = int(buyer_data['user_balance'])-int(hold_data[0]['amount'])
        #списание у покупателя
        b = update_userx(user_id, user_balance=buyer_rest)
    #buyer_rest = int(buyer_data['user_balance'])-int(hold_data[0]['amount'])
    #списание у покупателя
    #b = update_userx(user_id, user_balance=buyer_rest)
    #пополнение у продавца
    c = update_userx(order_sellers, user_balance=seller_rest)
    os = update_orderx(order_id=order_id, order_state='submitted', active=0)
    await call.message.answer(f"<b>Покупка завершена, возвращайтесь!</b>\n")

@dp.callback_query_handler(text="reply_toorder_message", state="*")
async def reply_toorder_message(call: CallbackQuery, state: FSMContext):
    print('reply_toorder_message')
    # order_id = int(call.data.split(":")[1])
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    print(user_id)
    get_user = get_userx(user_id=user_id)

    # get_user = get_userx(user_id=call.from_user.id)
    await state.set_state("reply_toorder_message_fin")

    # await call.message.delete()
    await call.message.answer(f"<b>Пожалуйста, введите сообщение для покупателя:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")

# Принятие адреса для доставки
@dp.message_handler(state="reply_toorder_message_fin")
async def reply_toorder_message_fin(message: Message, state: FSMContext):
    print('reply_toorder_message_fin')
    # user_id = int(call.data.split(":")[1])
    # order_id = int(message.data.split(":")[1])
    user_id = message.from_user.id
    get_user = get_userx(user_id=user_id)
    users_order = get_user_orderx(user_id)
    order_id = users_order['order_id']
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        messagetxt = str(message.text)
        print(str(user_id) + messagetxt)
        touser_id = get_cart_sellersx(order_id)
        print(touser_id)

        add_messagex(from_id=user_id, to_id=touser_id, order_id = order_id, txtmessage=messagetxt, photo='', state='responded')

    await message.delete()
    await message.answer(f"<b>✅ Было отправлено следующее сообщение покупателю:</b>\n"
                         + messagetxt, reply_markup=cart_enter_message_finl(user_id))

    cm = get_user_messagesx(to_uid=touser_id, state='responded')
    if len(cm) > 0:
        print(f"Messages present:{str(touser_id)}")

    await dp.bot.send_message(
        chat_id=touser_id,
        text=f"Сообщение/вопрос по заказу от продавца:{messagetxt}",
        reply_markup=reply_order_message_finl(order_id),
    )

@dp.callback_query_handler(text="enter_message_manualy", state="*")
async def enter_message_manualy(call: CallbackQuery, state: FSMContext):
    print('enter_message_manualy')
    # order_id = int(call.data.split(":")[1])
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    print(user_id)
    get_user = get_userx(user_id=user_id)

    # get_user = get_userx(user_id=call.from_user.id)
    await state.set_state("enter_message_manualy_fin")

    # await call.message.delete()
    await call.message.answer(f"<b>Пожалуйста, введите сообщение для продавца:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")

# Принятие адреса для доставки
@dp.message_handler(state="enter_message_manualy_fin")
async def enter_message_manualy_fin(message: Message, state: FSMContext):
    print('enter_message_manualy_fin')
    # user_id = int(call.data.split(":")[1])
    # order_id = int(message.data.split(":")[1])
    user_id = message.from_user.id
    get_user = get_userx(user_id=user_id)
    users_order = get_user_orderx(user_id)
    order_id = users_order['order_id']
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        messagetxt = str(message.text)
        print(str(user_id) + messagetxt)
        touser_id = get_cart_sellersx(order_id)
        print(touser_id)

        add_messagex(from_id=user_id, to_id=touser_id, order_id = order_id, txtmessage=messagetxt, photo='', state='created')

    await message.delete()
    await message.answer(f"<b>✅ Было отправлено следующее сообщение продавцу:</b>\n"
                         + messagetxt, reply_markup=cart_enter_message_finl(user_id))

    cm = get_user_messagesx(to_uid=touser_id, state='created')
    if len(cm) > 0:
        print(f"Messages present:{str(touser_id)}")

    await dp.bot.send_message(
        chat_id=touser_id,
        text=f"Сообщение/вопрос по заказу от покупателя:{messagetxt}",
        reply_markup=reply_order_message_finl(order_id),
    )

@dp.callback_query_handler(text_startswith="enter_phone_auto", state="*")
async def enter_phone_man(call: CallbackQuery, state: FSMContext):
    print('enter_phone_auto')
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("enter_phone_auto_fin")

    button_phone = KeyboardButton(text="Делись!", request_contact=True)
    keyboard = ReplyKeyboardMarkup(row_width=1, resize_keyboard=True, one_time_keyboard=True)
    keyboard.add(button_phone)
    await call.message.answer(
        "<b>✅ Вы можете поделиться своим номером телефона.</b>",
        reply_markup=menu_frep(message.from_user.id),
    )

    # get_user = get_userx(user_id=call.from_user.id)

    # await state.finish()

    # await Person.contact.set()

    '''await call.message.delete()
    await call.message.answer(f"<b>🎁 Введите Ваш номер телефона:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")'''

@dp.message_handler(content_types=['contact'], state="enter_phone_auto_fin")  # content_types=ContentType.CONTACT,
async def contacts(message: Message, state: FSMContext):
    phone = message.contact.phone_number

    print(phone)
    phone = str(message.text)
    phone = message.contact.phone_number
    update_userx(message.from_user.id, user_phone=phone)

    await message.answer(f"Ваш номер сохранен в Вашем личном кабинете: {message.contact.phone_number}",
                         reply_markup=ReplyKeyboardRemove())  # , reply_markup=types.ReplyKeyboardRemove()
    await state.finish()

    await message.answer(f"<b>✅ Номер телефон был успешно изменен на следующий:</b>\n"
                         + str(phone), reply_markup=accept_saved_phone(message.from_user.id))


'''
    await message.answer("🔸 Мы снова с Вами!.\n"
                     "🔸 Если не появились вспомогательные кнопки\n"
                     "▶ Введите /start",
                     reply_markup=menu_frep(message.from_user.id)) '''


# Принятие адреса для доставки
@dp.message_handler(state="enter_phone_auto_fin2")
async def user_get_phone(message: Message, state: FSMContext):
    print('enter_phone_auto_fin')
    # user_id = int(call.data.split(":")[1])
    phone = message.contact.phone_number
    # phone = int(message.data.split(":")[1])
    get_user = get_userx(user_id=message.from_user.id)
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    print(phone)

    # if message.text:
    #    phone = str(message.text)
    #    update_userx(message.from_user.id, user_phone=phone)

    await message.delete()
    await message.answer(f"<b>✅ Номер телефон был успешно изменен на следующий:</b>\n"
                         + phone, reply_markup=accept_saved_phone(message.from_user.id))

@dp.callback_query_handler(text_startswith="enter_phone_manualy", state="*")
async def enter_phone_man(call: CallbackQuery, state: FSMContext):
    print('enter_phone_manualy')
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)

    # get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("enter_phone_manualy_fin")

    await call.message.delete()
    await call.message.answer(f"<b>🎁 Введите Ваш номер телефона:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")

# Принятие адреса для доставки
@dp.message_handler(state="enter_phone_manualy_fin")
async def user_enter_phone(message: Message, state: FSMContext):
    print('enter_phone_manualy_fin')
    # user_id = int(call.data.split(":")[1])
    get_user = get_userx(user_id=message.from_user.id)
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        phone = str(message.text)
        update_userx(message.from_user.id, user_phone=phone)

    await message.delete()
    await message.answer(f"<b>✅ Номер телефон был успешно изменен на следующий:</b>\n"
                         + phone, reply_markup=accept_saved_phone(message.from_user.id))

@dp.callback_query_handler(text_startswith="enter_address_manualy", state="*")
async def enter_address_man(call: CallbackQuery, state: FSMContext):
    print('enter_address_manualy')
    # user_id = int(call.data.split(":")[1])
    # user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)

    # get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("enter_address_manualy_fin")

    await call.message.delete()
    await call.message.answer(f"<b>🎁 Введите Ваш адрес:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")

# Принятие адреса для доставки
@dp.message_handler(state="enter_address_manualy_fin")
async def user_enter_addr(message: Message, state: FSMContext):
    print('enter_address_manualy_fin')
    #user_id = int(message.split(":")[1])
    user_id = message.from_user.id
    get_user = get_userx(user_id=user_id)
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        address = str(message.text)
        update_userx(message.from_user.id, user_address=address)

    await message.delete()
    await message.answer(f"<b>✅ Адрес доставки был успешно изменен на следующий:</b>\n"
                         + address, reply_markup=accept_saved_adr(message.from_user.id))

# Выбор количества товаров для покупки
@dp.callback_query_handler(text_startswith="buy_item_select", state="*")
async def buy_item_select(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])

    get_position = get_positionx(position_id=position_id)
    get_items = get_itemsx(position_id=position_id)
    get_user = get_userx(user_id=call.from_user.id)

    if get_position['position_price'] != 0:
        get_count = int(get_user['user_balance'] / get_position['position_price'])
        get_count = min(get_count, len(get_items))
    else:
        get_count = len(get_items)

    if int(get_user['user_balance']) >= int(get_position['position_price']):
        if get_count == 1:
            await state.update_data(here_cache_position_id=position_id)
            await state.finish()

            await call.message.delete()
            await call.message.answer(f"<b>🎁 Вы действительно хотите купить товар(ы)?</b>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                      f"📦 Количество: <code>1шт</code>\n"
                                      f"💰 Сумма к покупке: <code>{get_position['position_price']}₽</code>",
                                      reply_markup=products_confirm_finl(position_id, 1))
        elif get_count >= 1:
            await state.update_data(here_cache_position_id=position_id)
            await state.set_state("here_item_count")

            await call.message.delete()
            await call.message.answer(f"<b>🎁 Введите количество товаров для покупки</b>\n"
                                      f"▶ От <code>1</code> до <code>{get_count}</code>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n"
                                      f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>")
        else:
            await call.answer("🎁 Товаров нет в наличии")
    else:
        #await call.answer("❗ У вас недостаточно средств. Пополните баланс", True)
        #await call.message.delete()
        await call.message.answer(
            "<b>❗ У вас недостаточно средств. Пополните баланс</b>",
            reply_markup=charge_button_add(0),
        )


@dp.callback_query_handler(text_startswith="edit_delivery_settings", state="*")
async def enter_phone_man(call: CallbackQuery, state: FSMContext):
    print('edit_delivery_settings')
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)

    # get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("edit_delivery_settings_fin")

    await call.message.delete()
    await call.message.answer(f"<b>Введите минимальный порог бесплатной доставки X и ставку доставки по городу Y через пробел:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")

# Принятие адреса для доставки
@dp.message_handler(state="edit_delivery_settings_fin")
async def user_enter_phone(message: Message, state: FSMContext):
    print('edit_delivery_settings_fin')
    # user_id = int(call.data.split(":")[1])
    get_user = get_userx(user_id=message.from_user.id)
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        free_delivery_point, delivery_rate = str(message.text).split()
        if free_delivery_point and delivery_rate:
            update_userx(message.from_user.id, free_delivery_point=free_delivery_point, delivery_rate=delivery_rate)
            await message.delete()
            await message.answer(f"<b>✅ Настройки были установлены: X={free_delivery_point}, Y={delivery_rate}.</b>\n"
                                 , reply_markup=edit_delivery_settings_finl())
        else:
            await message.delete()
            await message.answer(f"<b>⭕ Настройки не были установлены. Проверьте написание или уточните там, где Вы его получили.</b>\n"
                                 , reply_markup=edit_delivery_settings_finl())


@dp.callback_query_handler(text_startswith="enter_promocode", state="*")
async def enter_phone_man(call: CallbackQuery, state: FSMContext):
    print('enter_promocode')
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)
    # get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("enter_promocode_fin")

    await call.message.delete()
    await call.message.answer(f"<b>🎁 Введите Ваш промокод и мы его применим:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")

# Принятие адреса для доставки
@dp.message_handler(state="enter_promocode_fin")
async def user_enter_phone(message: Message, state: FSMContext):
    print('enter_promocode_fin')
    # user_id = int(call.data.split(":")[1])
    get_user = get_userx(user_id=message.from_user.id)
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        promocodeutxt = str(message.text)
        if promocode := get_promocodex(promocode=promocodeutxt):
            update_userx(message.from_user.id, promocode=promocodeutxt)
            await message.delete()
            await message.answer(f"<b>✅ Ваш промокод был успешно применен. Размер Вашей скидки теперь: {promocode['discount']} </b>\n"
                                 , reply_markup=enter_promocode_finl())
        else:
            await message.delete()
            await message.answer(f"<b>⭕ Ваш промокод не был найден. Проверьте написание или уточните там, где Вы его получили.</b>\n"
                                 , reply_markup=enter_promocode_finl())


# -------------------------------------------------------------------------------------
# Выбор количества товаров для покупки
@dp.callback_query_handler(text_startswith="buy_item_select", state="*")
async def user_purchase_select(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])

    get_position = get_positionx(position_id=position_id)
    get_items = get_itemsx(position_id=position_id)
    get_user = get_userx(user_id=call.from_user.id)

    if get_position['position_price'] != 0:
        get_count = int(get_user['user_balance'] / get_position['position_price'])
        get_count = min(get_count, len(get_items))
    else:
        get_count = len(get_items)

    if int(get_user['user_balance']) >= int(get_position['position_price']):
        if get_count == 1:
            await state.update_data(here_cache_position_id=position_id)
            await state.finish()

            await call.message.delete()
            await call.message.answer(f"<b>🎁 Вы действительно хотите купить товар(ы)?</b>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                      f"📦 Количество: <code>1шт</code>\n"
                                      f"💰 Сумма к покупке: <code>{get_position['position_price']}₽</code>",
                                      reply_markup=products_confirm_finl(position_id, 1))
        elif get_count >= 1:
            await state.update_data(here_cache_position_id=position_id)
            await state.set_state("here_item_count")

            await call.message.delete()
            await call.message.answer(f"<b>🎁 Введите количество товаров для покупки</b>\n"
                                      f"▶ От <code>1</code> до <code>{get_count}</code>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n"
                                      f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>")
        else:
            await call.answer("🎁 Товаров нет в наличии")
    else:
        #await call.answer("❗ У вас недостаточно средств. Пополните баланс", True)
        #await call.message.delete()
        await call.message.answer(
            "<b>❗ У вас недостаточно средств. Пополните баланс</b>",
            reply_markup=charge_button_add(0),
        )

# Принятие количества товаров для покупки
@dp.message_handler(state="here_item_count")
async def user_purchase_select_count(message: Message, state: FSMContext):
    position_id = (await state.get_data())['here_cache_position_id']

    get_position = get_positionx(position_id=position_id)
    get_user = get_userx(user_id=message.from_user.id)
    get_items = get_itemsx(position_id=position_id)

    if get_position['position_price'] != 0:
        get_count = int(get_user['user_balance'] / get_position['position_price'])
        get_count = min(get_count, len(get_items))
    else:
        get_count = len(get_items)

    send_message = f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                   f"🎁 Введите количество товаров для покупки\n" \
                   f"▶ От <code>1</code> до <code>{get_count}</code>\n" \
                   f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                   f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n" \
                   f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>"

    if message.text.isdigit():
        get_count = int(message.text)
        amount_pay = int(get_position['position_price']) * get_count

        if len(get_items) >= 1:
            if 1 <= get_count <= len(get_items):
                if int(get_user['user_balance']) >= amount_pay:
                    await state.finish()
                    await message.answer(f"<b>🎁 Вы действительно хотите купить товар(ы)?</b>\n"
                                         f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                         f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                         f"📦 Количество: <code>{get_count}шт</code>\n"
                                         f"💰 Сумма к покупке: <code>{amount_pay}₽</code>",
                                         reply_markup=products_confirm_finl(position_id, get_count))
                else:
                    await message.answer(
                        f"<b>❌ Недостаточно средств на счете.</b>\n{send_message}"
                    )
            else:
                await message.answer(f"<b>❌ Неверное количество товаров.</b>\n{send_message}")
        else:
            await state.finish()
            await message.answer(_("<b>🎁 Товар который вы хотели купить, закончился</b>", locale=lang))
    else:
        await message.answer(f"<b>❌ Данные были введены неверно.</b>\n{send_message}")

# Подтверждение покупки товара
@dp.callback_query_handler(text_startswith="xbuy_item", state="*")
async def user_purchase_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    get_count = int(call.data.split(":")[3])

    if get_action == "yes":
        await call.message.edit_text(_("<b>🔄 Ждите, товары подготавливаются</b>", locale=lang))

        get_position = get_positionx(position_id=position_id)
        get_items = get_itemsx(position_id=position_id)
        get_user = get_userx(user_id=call.from_user.id)

        amount_pay = int(get_position['position_price'] * get_count)

        if 1 <= get_count <= len(get_items):
            if int(get_user['user_balance']) >= amount_pay:
                save_items, send_count, split_len = buy_itemx(get_items, get_count)

                if get_count != send_count:
                    amount_pay = int(get_position['position_price'] * send_count)
                    get_count = send_count

                receipt = get_unix()
                buy_time = get_date()

                await call.message.delete()
                if split_len == 0:
                    await call.message.answer("\n\n".join(save_items), parse_mode="None")
                else:
                    for item in split_messages(save_items, split_len):
                        await call.message.answer("\n\n".join(item), parse_mode="None")
                        await asyncio.sleep(0.3)

                update_userx(get_user['user_id'], user_balance=get_user['user_balance'] - amount_pay)
                add_purchasex(get_user['user_id'], get_user['user_login'], get_user['user_name'], receipt, get_count,
                              amount_pay, get_position['position_price'], get_position['position_id'],
                              get_position['position_name'], "\n".join(save_items), buy_time, receipt,
                              get_user['user_balance'], int(get_user['user_balance'] - amount_pay))

                await notify(dp, f"Продана позиция: {get_position['position_name']}")
                await call.message.answer(f"<b>✅ Вы успешно купили товар(ы)</b>\n"
                                          f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                          f"🧾 Чек: <code>#{receipt}</code>\n"
                                          f"🎁 Товар: <code>{get_position['position_name']} | {get_count}шт | {amount_pay}₽</code>\n"
                                          f"🕰 Дата покупки: <code>{buy_time}</code>",
                                          reply_markup=menu_frep(call.from_user.id))
            else:
                await call.message.answer(_("<b>❗ На вашем счёте недостаточно средств</b>", locale=lang))
        else:
            await call.message.answer(_("<b>🎁 Товар который вы хотели купить закончился или изменился.</b>", locale=lang),
                                      reply_markup=menu_frep(call.from_user.id))
    elif len(get_all_categoriesx()) >= 1:
        await call.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                     reply_markup=category_edit_open_fp(0))
    else:
        await call.message.edit_text(_("<b>✅ Вы отменили покупку товаров.</b>", locale=lang))




tgbot >handlers>user_menu.py:
# - *- coding: utf- 8 - *-
#from pathlib import Path
import os
import asyncio
import json
import gettext
from pathlib import Path
from contextvars import ContextVar
#import i18n

from aiogram.dispatcher import FSMContext
from aiogram import Bot
from aiogram import Dispatcher
from aiogram.utils.deep_linking import get_start_link, decode_payload
from aiogram.types import CallbackQuery, Message, KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove
from aiogram.contrib.middlewares.i18n import I18nMiddleware
from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR
#from tgbot.middlewares.i18n import I18nMiddleware
#from aiogram.contrib.middlewares.i18n import I18nMiddleware
from tgbot.middlewares.i18n import I18nMiddleware

from tgbot.keyboards.inline_admin import category_edit_open_finl, position_edit_open_finl, category_edit_delete_finl, \
    position_edit_clear_finl, position_edit_delete_finl, payment_choice_finl, artist_edit_open_finl, select_place_finl
from tgbot.keyboards.inline_user import user_support_finl, products_open_finl, products_confirm_finl, \
    products_addcart_confirm_finl, payment_as_choice_finl, accept_saved_adr, accept_saved_phone, \
    cart_enter_message_finl, give_number_inl, reply_order_message_finl, refill_choice_finl, charge_button_add, \
    switch_category_shop_finl, shop_creation_request_finl, event_open_finl, enter_promocode_finl, cart_open_created_finl, \
    cart_open_delivery_finl, edit_delivery_settings_finl, position_select_type_finl, checkout_step2_accept_finl, confirm_cart_del_finl, profile_open_finl, profile_seller_open_finl, refill_open_finl
from tgbot.keyboards.inline_z_all import category_remove_confirm_inl, position_remove_confirm_inl, \
    item_remove_confirm_inl, close_inl, confirm_delete_user_cart_inl
from tgbot.keyboards.inline_z_all import refill_open_inl, profile_open_inl, checkout_step2_accept, order_user_refill, partners_list_inl, profile_seller_open_inl
from tgbot.keyboards.inline_z_page import *
from tgbot.keyboards.reply_z_all import finish_load_rep
from tgbot.keyboards.reply_z_all import menu_frep, items_sh_frep, events_frep
from tgbot.keyboards.shop_keyboards import shop_edit_open_fp
from tgbot.loader import dp
from tgbot.loader import bot
#from tgbot.services.api_qiwi import QiwiAPI
from tgbot.services.api_sqlite_shop import *
from tgbot.services.api_sqlite import *
from tgbot.utils.const_functions import get_date, split_messages, get_unix, clear_list
from tgbot.utils.misc.bot_filters import IsShopAdmin, IsAdminorShopAdmin, IsAdmin
from tgbot.utils.misc_functions import user_refill_my, calc_cart_summ, calc_order_summ, open_cart_orders, open_profile_my, upload_text, get_faq, send_admins
from tgbot.utils.misc_functions import get_position_admin, upload_text, get_artist_admin
from tgbot.keyboards.location_keyboards import geo_1_kb
from tgbot.services.location_function import update_position_city, get_city_info, is_location, update_artist_city
from tgbot.services.location_stat import geo_choice
from tgbot.keyboards.location_keyboards import geo_11_kb

i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)

print(i18n)
_ = i18n.gettext
#print(i18n.find_locales())


async def notify(dp: Dispatcher, msg):
    print(f'Уведомление!' + msg)
    await send_admins(msg, markup="default")
################################################################################################

# Заявка на продавца магазина
# Открытие товаров
@dp.message_handler(text=["Я продавец", "I'm seller"], state="*")
async def user_seller_request(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    await state.set_state("here_seller_request_direction")
    await message.answer(_("<b>📁 Введите тип товара, который Вы будете продавать:</b>", locale=lang))

# Открытие товаров
@dp.message_handler(text=["Админ Афиши", "Events Admin"],state="*")
async def user_seller_request(message: Message, state: FSMContext):
    # await state.finish()
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    await state.set_state("here_afisha_admin_request_direction")
    await message.answer(_("<b>📁 Опишите пожалуйста события или среду, которые Вы создаете:</b>", locale=lang))


# Управление событиями IsAdminorShopAdmin(),
@dp.message_handler(text=['🎫 Управление событиями 🖍', '🎫 Events Management 🖍'], state="*")
async def admin_products(message: Message, state: FSMContext):
    user_id = message.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    lang = get_userx(user_id=user_id)['user_lang']
    if user_role in ['Admin', 'ShopAdmin']:

        await state.finish()
        await message.answer(_("<b>🎫 Редактирование событий.</b>", locale=lang), reply_markup=events_frep(lang))
    else:

        await state.finish()
        await message.answer("<b>🎫 У Вас недостаточно прав для доступа в данный раздел.</b>")


# Управление товарами
@dp.message_handler(IsShopAdmin(), text="🎁 Управление товарами дмаг.🖍", state="*")
async def shopadmin_products(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    await state.finish()
    await message.answer(_("<b>🎁 Редактирование товаров дмаг.</b>", locale=lang), reply_markup=items_sh_frep())


@dp.message_handler(text=["🗃 Создать категорию ➕", "🗃 Create Category ➕"], state="*")
async def product_category_create(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang)

    await state.finish()
    await state.set_state("here_category_name")
    await message.answer(_("<b>🗃 Введите название для категории 🏷</b>", locale=lang))


# Начальные категории для изменения позиции
@dp.message_handler(text=["📁 Изменить позицию 🖍", "📁 Edit Position 🖍"], state="*")  # !!!!!!!   Изменить позицию
async def product_position_edit(message: Message, state: FSMContext):
    print('📁 Изменить позицию 🖍 user_menu.py 56')
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    city_id = get_city_user(user_id)[0]

    action = "edit"
    if user_role in ["Admin", "ShopAdmin"]:
        await state.finish()
        await message.answer(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                             reply_markup=products_item_category_swipe_fp(0, 0, city_id, action, lang))

# Открытие товаров
@dp.message_handler(text=["🎁 Купить", "🎁 Buy"], state="*")
async def user_shop(message: Message, state: FSMContext):
    print('Открытие категорий товаров user_menu.py 65')
    await state.finish()

    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang)
    action = "open"

    get_settings = get_settingsx()
    if(get_settings['type_trade'] != 'digital'):
        user_city = get_user_city(message.from_user.id)
        user_city_id = user_city[1]
        user_city_name = user_city[0]
        print(user_city_id)

        if len(get_category_in_city(user_city_id)) >= 1:
            await message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                 reply_markup=products_item_category_swipe_fp(0, 0, user_city_id, action, lang))
        else:
            await message.answer(_("<b>🎁 В Вашем городе товаров нет, но Вы можете разместить свои, отправив запрос продавца или как частное лицо, выбрав пункт Продать</b>"
                                 "\n"
                                 "🏙 Изменить город вы можете в личном кабинете", locale=lang))
    else:
        await message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                             reply_markup=products_item_category_swipe_fp(0, 0, 0, action, lang))

# Открытие товаров
@dp.callback_query_handler(text_startswith="privateMarket", state="*")
async def private_user_shop(call: CallbackQuery, state: FSMContext):
    print('Открытие барахолки user_menu.py 65')
    await state.finish()
    category_id, remover, level, parent, city_id = 0, 0, 0, 0, 0
    print("<*|||privateMarket|||*>")
    action = "open"

    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    print("IIII")

    get_settings = get_settingsx()
    print("IIIII")
    if(get_settings['type_trade'] != 'digital'):
        user_city = get_user_city(call.from_user.id)
        city_id = user_city[1]
        user_city_name = user_city[0]
        print(city_id)
        print(category_id, remover, level, parent, city_id, action, lang)

        if len(get_category_in_city(city_id)) >= 1:
            await call.message.answer(_("<b>🎁 Выберите нужную вам категорию:</b>", locale=lang),
                                 reply_markup=position_people_create_open_fp(category_id, remover, level, parent, city_id, action, lang))
        else:
            await call.message.answer("<b>🎁 В вашем городе товаров нет, выберите другой город</b>\n"
                                      "🏙 Изменить город вы можете в личном кабинете")
    else:
        await call.message.answer(_("<b>🎁 Выберите нужную вам категорию:</b>", locale=lang),
                             reply_markup=position_people_create_open_fp(category_id, remover, level, parent, city_id, action, lang))

# Открытие товаров
@dp.message_handler(text=["🏫 Кружки", "🏫 Сources"], state="*")
async def user_shop(message: Message, state: FSMContext):
    print('Открытие категорий товаров  user_menu.py 65')
    await state.finish()

    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    source = "people"
    action = "open"

    get_settings = get_settingsx()
    if (get_settings['type_trade'] != 'digital'):
        city_id = get_city_user(message.from_user.id)[0]

    await message.answer(_("<b>📁 Выберите категорию для Вашей позиции</b>", locale=lang),
                         reply_markup=cources_opcr_fp(0, 0, 0, 0, city_id, action, lang))


# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="cources_category_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    level = int(call.data.split(":")[3])
    parent = int(call.data.split(":")[4])
    city_id = int(call.data.split(":")[5])
    action = call.data.split(":")[6]
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang)

    await call.message.edit_text("<b>🌐 Выберите категорию:</b>",
                                 reply_markup=cources_opcr_fp(category_id, remover, level, parent, city_id, action, lang))


# Выбор категории для создания позиции 1TODO
@dp.callback_query_handler(text_startswith="cources_open_here:", state="*")
async def product_position_open_select_category(call: CallbackQuery, state: FSMContext):
    print('position_people_open_here - user_menu 160')
    category_id = int(call.data.split(":")[1])
    print(category_id)
    get_category = get_curcategory_in_citypx(category_id=category_id)
    #if len(get_category) == 0: category_id = 0
    city_id = get_city_user(call.from_user.id)[0]
    get_positions = get_cources_in_cityx(category_id=category_id, position_city_id=city_id, flagallc=1, position_type=1)  # get_positionsx(category_id=category_id)
    print(get_positions)
    print(category_id, city_id)
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    if len(get_positions) >= 1:
        #source = "people"
        await call.message.edit_text(f"<b>🎁 Курсы в локации: {get_category['category']}</b>",
                                     reply_markup=products_item_position_swipe_fp(0, category_id, city_id, lang))
    else:
        await call.answer(f"❕ Товары в категории {get_category['category']} отсутствуют")

# Открытие товаров
@dp.message_handler(text=["🌐 Продать", "🌐 Sell"], state="*")
async def user_shop(message: Message, state: FSMContext):
    print('Открытие категорий товаров  user_menu.py 65')
    await state.finish()

    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    source = "people"
    action = "create"

    get_settings = get_settingsx()
    if (get_settings['type_trade'] != 'digital'):
        city_id = get_city_user(message.from_user.id)[0]

    await message.answer(_("<b>📁 Выберите категорию для Вашей позиции</b>", locale=lang),
                         reply_markup=position_people_create_open_fp(0, 0, 0, 0, city_id, action, lang))

# Открытие товаров
@dp.message_handler(text=["🎁 Магазины", "🎁 Shops"], state="*")
async def user_shop(message: Message, state: FSMContext):
    print('Открытие магазинов товаров  user_menu.py 65')
    await state.finish()

    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    get_settings = get_settingsx()
    if(get_settings['type_trade'] != 'digital'):
        city_id = get_city_user(message.from_user.id)[0]
        if len(get_shops_on_city(city=city_id)) >= 1:
            await message.answer(_("<b>🎁 Выберите нужный вам магазин:</b>", locale=lang),
                                 reply_markup=products_item_shop_swipe_fp(0, city_id, lang))
        else:
            await message.answer("<b>🎁 В вашем городе товаров нет, выберите другой город</b>\n\n"
                                 "🏙 Изменить город вы можете в личном кабинете")
    else:
        await message.answer(_("<b>🎁 Выберите нужный вам магазин:</b>", locale=lang),
                             reply_markup=products_item_shop_swipe_fp(0, 0, lang))


# Открытие товаров
@dp.message_handler(text=["Афиша", "Events"], state="*")
async def user_afisha(message: Message, state: FSMContext):
    print('Открытие афишы  user_menu.py 115')
    await state.finish()

    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    if is_location(message.from_user.id) == True:
        user_city = get_user_city(message.from_user.id)
        user_city_id = user_city[1]
        user_city_name = user_city[0]
        print(user_city_id, lang)
        if len(get_events_in_cityx(user_city_id, flagallc=1, position_type=1)) >= 1:
            await message.answer(_("<b>Выберите интересное для Вас:</b>", locale=lang),
                                 reply_markup=events_in_city_swipe_fp(0, user_city_id, lang))
        else:
            await message.answer("<b>🎁 В Вашем городе событий пока на размещено, но Вы можете разместить сами, отправив запрос Администратора Афишы.</b>\n\n"
                                 "🏙 Чтобы посмотреть события в другом городе достаточно изменить город в Профиле.")

    else:
        await geo_choice.location.set()
        await message.answer(_('Отправьте локацию или выберите город из списка чтобы увидеть события в Вашем городе', locale=lang), reply_markup=geo_11_kb(lang))


# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="events_city_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    city_id = int(call.data.split(":")[2])

    user_id = call.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    if remover == 0:
        await call.message.answer(_("<b>События в городе, выберите что-нибудь интересное:</b>", locale=lang),
                                  reply_markup=events_in_city_swipe_fp(remover, city_id, lang))
    else:
        await call.message.edit_text(_("<b>События в городе, выберите что-нибудь интересное:</b>", locale=lang),
                                     reply_markup=events_in_city_swipe_fp(remover, city_id, lang))

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="events_place_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    place_id = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])

    user_id = call.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    if remover == 0:
        await call.message.answer(_("<b>События в месте, выберите что-нибудь интересное:</b>", locale=lang),
                                  reply_markup=events_in_place_swipe_fp(remover, place_id, city_id, lang))
    else:
        await call.message.edit_text(_("<b>События в месте, выберите что-нибудь интересное:</b>", locale=lang),
                                     reply_markup=events_in_place_swipe_fp(remover, place_id, city_id, lang))


# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="places_city_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    city_id = int(call.data.split(":")[2])

    user_id = call.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    await call.message.edit_text(_("<b>События в городе, выберите что-нибудь интересное:</b>", locale=lang),
                                 reply_markup=places_in_city_swipe_fp(remover, city_id, lang))

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="open_inline_support", state="*")
async def open_inline_support(call: CallbackQuery, state: FSMContext):
    user_support = get_settingsx()['misc_support']

    user_id = call.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    if str(user_support).isdigit():
        get_user = get_userx(user_id=user_support)
        await call.message.answer(_("<b>Напишите, что Вы хотите добавить, мы добавим.:</b>", locale=lang),
                                  reply_markup=user_support_finl(get_user['user_login']))
        return
    else:
        update_settingsx(misc_support="None")
        await message.answer(f"☎ Поддержка. Измените их в настройках бота.\n➖➖➖➖➖➖➖➖➖➖\n{BOT_DESCRIPTION}",
                             disable_web_page_preview=True)

# Открытие позиции для покупки
@dp.callback_query_handler(text_startswith="book_event_open:", state="*")
async def user_purchase_position_open(call: CallbackQuery, state: FSMContext):
    print('Карточка товара: user_menu.py  152')
    event_id = int(call.data.split(":")[1])
    place_id = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])

    user_id = call.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    city_id = get_city_user(call.from_user.id)[0]
    get_event = get_eventxx(event_id=event_id)

    get_settings = get_settingsx()
    print(get_event)

    if get_event['event_description'] == "0":
        text_description = ""
    else:
        text_description = f"\n📜 Описание:\n" \
                           f"{get_event['event_description']}"

    send_msg = f"<b>Мероприятие:</b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"🏷 Название: <code>{get_event['event_name']}</code>\n" \
               f"🏙 Город: <code>{get_event['event_city']}</code>\n" \
               f"{text_description}"

    print(get_settings['type_trade'])
    tt = get_settings['type_trade']

    if (
        tt != "digital"
        and len(get_event['event_photo']) >= 5
        or tt == "digital"
        and len(get_position['event_photo']) >= 5
    ):
        print("\|")
        await call.message.delete()
        await call.message.answer_photo(get_event['event_photo'],
                                        send_msg, reply_markup=event_open_finl(event_id, 0, place_id, city_id, lang))
    else:
        print("\||")
        await call.message.edit_text(send_msg,
                                     reply_markup=event_open_finl(event_id, 0, place_id, city_id, lang))

# Открытие пополнения счета
@dp.message_handler(text=["💰 Пополнить", "💰 Top Up"], state="*")
async def user_refill_b(message: Message, state: FSMContext):
    await state.finish()

    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']
    print(lang)

    await message.answer(user_refill_my(message.from_user.id, lang), reply_markup=refill_open_finl(lang))


# Открытие профиля
@dp.message_handler(text=["👤 Профиль", "👤 Profile"], state="*")
async def user_profile(message: Message, state: FSMContext):
    print("||==")
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    print("|||===")
    if user_role in ["ShopAdmin", "Admin"]:
        await state.finish()
        print("||||+===")
        await message.answer(open_profile_my(message.from_user.id), reply_markup=profile_seller_open_inl) #await (lang)message.answer(open_profile_my(message.from_user.id), reply_markup=profile_seller_open_finl(lang))
        #await message.answer(open_profile_my(message.from_user.id), reply_markup=profile_seller_open_finl(lang)) #profile_seller_open_finl(lang)(lang)
    else:
        await state.finish()
        print("||||++====")
        await message.answer(open_profile_my(message.from_user.id), reply_markup=profile_open_inl) #(lang)

# Открытие профиля
@dp.message_handler(text=["Партнеры", "Partners"], state="*")
async def open_partners_list(message: Message, state: FSMContext):
    await state.finish()
    await message.answer("Наши славные партнеры:", reply_markup=partners_list_inl)

# Открытие корзины
@dp.message_handler(text=['🧮 Корзина', '🚛 Заказы', '🧮 Cart', '🚛 Orders'], state="*")
async def user_cart(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    orderdata = []
    if message.text in ['🧮 Корзина', '🧮 Cart']: #заказы покупателя
        orderdata = get_params_orderx(user_id=user_id)
        if len(orderdata) == 0:
            await message.answer("В Вашей корзине пока нет товаров. Посмотрите категории[кнопка Купить] или товары Магазинов.")

    if message.text in ['🚛 Заказы', '🚛 Orders']: #заказы продавца | представление от заказа к строке
        if user_id in get_userx(user_role='ShopAdmin') or user_id in get_userx(user_role='Admin'):
            orderdata = get_params_orderxx(owner_uid=user_id)
        elif user_id in get_admins():
            orderdata = get_alladmin_orderx()
        else:
            await message.answer("Недостаточно доступа для просмотра заказов!")

    if message.text == '🚛 Заказы А': #заказы админа площадки
        orderdata = get_params_orderxx(owner_uid=user_id)

    #print(orderdata)

    for order in orderdata:
        #print(order['order_state'])

        if order['order_state'] == 'delivery':
            await message.answer(open_cart_orders(order['order_id'], lang), reply_markup=cart_open_delivery_finl(order['order_id'], lang)) #cart_open_delivery_finl(order['order_id'], lang)
        if order['order_state'] == 'created':
            await message.answer(open_cart_orders(order['order_id'], lang), reply_markup=cart_open_created_finl(order['order_id'], lang)) #cart_open_created_finl(order['order_id'], lang)
        if order['order_state'] == 'submited':
            await message.answer(f"<b>Активных заказов нет.</b>\n")

# Открытие FAQ
@dp.message_handler(text=["ℹ FAQ", "/faq"], state="*")
async def user_faq(message: Message, state: FSMContext):
    await state.finish()

    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    send_message = get_settingsx()['misc_faq']
    if send_message == "None":
        if lang == 'ru':
            send_message = f"ℹ Информация. Измените её в настройках бота.\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n{BOT_DESCRIPTION}"
        if lang == 'en':
            send_message = f"ℹ Information. You can change this in bot settings.\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n{BOT_DESCRIPTION}"

    await message.answer(get_faq(message.from_user.id, send_message), disable_web_page_preview=True)

###############################################################################################
##### ***** ###### *****         СОЗДАНИЕ АРТИСТА
###############################################################################################
# -----------------------------------------------------------------------------------------------------------
# Создание нового магазина
@dp.message_handler(IsAdminorShopAdmin(), text=["🏪 Создать артиста ➕", "🏪 Create Artist ➕"], state="*")
async def product_shop_create(message: Message, state: FSMContext):
    print("user_menu - создание артиста")
    print("-")
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']
    print(user_id)
    my_artist = check_user_artist_exist(user_id)
    print(my_artist)
    if my_artist == True:
        print("|")
        await state.finish()
        await message.answer(f"<b>🏪 Артист уже существует 🏷 Выбирайте его в каталоге при создании позиций: {my_artist} </b>", parse_mode='HTML')
    else:
        print("||")
        await state.finish()
        await state.set_state("here_artist_name")
        await message.answer(_("<b>🏪 Введите название артиста или коллектива 🏷</b>", locale=lang), parse_mode='HTML')


# принятие названия магазина, запрос описания
@dp.message_handler(IsAdminorShopAdmin(), state="here_artist_name")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        print("admin_products_shop - создание артиста")
        await state.update_data(data={'name': message.text})
        await state.set_state('here_artist_description')
        await message.answer("<b>🏪 Введите Bio артиста 📜</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", parse_mode='HTML')
    else:
        await message.answer("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "🏪 Введите название для артиста 🏷", parse_mode='HTML')

# принятие описания магазина, запрос адреса
@dp.message_handler(IsAdminorShopAdmin(), state="here_artist_description")
async def product_category_create_name(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    if len(message.text) <= 600:
        if message.text == '0':
            await state.update_data(data={'description': 'None'})
        else:
            await state.update_data(data={'description': message.text})
        await state.set_state('here_artist_webadress')
        await message.answer("<b>🏪 Отправьте веб-сайт артиста 📍</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", parse_mode='HTML')


    else:
        await message.answer("<b>❌ Описание не может превышать 600 символов.</b>\n"
                             "🏪 Введите новое Bio для артиста 📜\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", parse_mode='HTML')


# принятие адреса магазина, запрос номера
@dp.message_handler(IsAdminorShopAdmin(), state="here_artist_webadress")
async def product_category_create_name(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    if message.text == '0':
        await state.update_data(data={'webaddress': 'None'})
    else:
        await state.update_data(data={'webaddress': message.text})
    await state.set_state('here_artist_logo')
    await message.answer("<b>🏪 Отправьте лого артиста 📷</b>\n"
                         "❕ Отправьте <code>0</code> чтобы пропустить.", parse_mode='HTML')

# принятие лого магазина, запрос лого
@dp.message_handler(IsAdminorShopAdmin(), content_types=['photo','text'], state="here_artist_logo")
async def product_category_create_logo(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']
    logo = message.photo[0].file_id if message.content_type == 'photo' else None
    async with state.proxy() as data:
        print(data)
        name = data['name']
        description = data['description']
        webaddress = data['webaddress']

    await state.finish()

    type_trade = get_settingsx()
    if type_trade['type_trade'] != "digital":
        city = get_city_user3(message.from_user.id)
        print(city)
        city_id = city[0]
        geocode = city[1]
        city_name = city[2]
    else:
        city_id = 0
        geocode = ''
        city_name = ''
    add_artistx(name, description, webaddress, message.from_user.id, logo, city_id, geocode, city_name)
    await message.answer(_("<b>🏪 Карточка артиста была успешно создана ✅</b>", locale=lang), parse_mode='HTML')


# -----------------------------------------------------------------------------------------------------------
# Открытие страниц выбора магазина для редактирования
@dp.message_handler(IsAdminorShopAdmin(), text=["🏪 Изменить артиста 🖍", "🏪 Edit Artist 🖍"], state="*")
async def artist_list_edit(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id)['user_lang']
    artists = get_artistsxx(admin=user_id)
    print(artists)

    if len(artists) >= 1:
        await message.answer("<b>🏪 Выберите артиста для изменения 🖍</b>",
                             reply_markup=artist_edit_open_fp(0, user_id))
    else:
        await message.answer("<b>🏪 Ваши артисты отсутствуют 🖍</b>")


# Смена страницы выбора магазина
@dp.message_handler(IsAdminorShopAdmin(), text_startswith="change_artist_edit_pg:", state="*")
async def artist_list_edit_pg(call: CallbackQuery, state: FSMContext):
    await state.finish()
    remover = int(str(call.data).split(':')[1])
    #user_id = message.from_user.id
    user_id = int(str(call.data).split(':')[2])
    lang = get_user_lang(user_id)['user_lang']
    artists = get_artistsxx(admin=user_id)

    if len(artists) >= 1:
        await call.message.answer("<b>🏪 Выберите артиста для изменения 🖍</b>",
                                  reply_markup=artist_edit_open_fp(remover, user_id))
    else:
        await call.message.answer("<b>🏪 Артисты отсутствуют 🖍</b>")


# Выбор позиции для редактирования
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit:", state="*")
async def artist_edit_open(call: CallbackQuery, state: FSMContext):
    print('Выбор артиста для редактирования api_sqlite.py 496')
    artist_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    lang = get_user_lang(user_id)['user_lang']
    remover = int(call.data.split(":")[3])
    print(artist_id, user_id, remover)

    get_message, get_photo = get_artist_admin(artist_id)

    if get_photo is not None and get_photo != '':
        await call.message.delete()
        await call.message.answer_photo(get_photo, get_message,
                                        reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
    else:
        await call.message.edit_text(get_message,
                                     reply_markup=artist_edit_open_finl(artist_id, user_id, remover))


# Возвращение к выбору позиции для изменения
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit_return", state="*")
async def artist_edit_return(call: CallbackQuery, state: FSMContext):
    user_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_user_lang(user_id)['user_lang']
    artists = get_artistsxx(admin=user_id)
    print(artists)

    if len(artists) >= 1:
        await call.message.delete()
        await call.message.answer("<b>📁 Выберите нужного Вам артиста 🖍</b>",
                                  reply_markup=artist_edit_open_fp(0, user_id))
    else:
        await call.answer("<b>❗ У Вас отсутствуют Артисты</b>")


# Создание новой позиции
@dp.message_handler(IsAdminorShopAdmin(), text=["📁 Создать позицию ➕", "📁 Create Position ➕"], state="*")
async def product_position_create(message: Message, state: FSMContext):
    await state.finish()
    print("APS 182")
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang)

    await message.answer(_("<b>📁 Выберите категорию для позиции</b>", locale=lang),
                         reply_markup=position_create_open_fp(0, lang))
    #else:
    #await message.answer("<b>❌ Отсутствуют магазины для создания позиции.</b>")

###############################################################################################
##### ***** ###### *****         СОЗДАНИЕ АРТИСТА
###############################################################################################
# -----------------------------------------------------------------------------------------------------------
# Создание нового магазина
@dp.message_handler(IsAdminorShopAdmin(), text=["📁 Создать событие ➕", "📁 Create Event ➕"], state="*")
async def product_shop_create(message: Message, state: FSMContext):
    await state.finish()
    print("user_menu - создание события")
    print("-")
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']
    print(user_id)
    my_event = check_user_events_exist(user_id)
    print(my_event)
    city_id = get_city_user3(user_id)[2]
    print(city_id)

    if my_event == True:
        print("|")
        await message.answer(f"<b>🏪 Событие уже существует 🏷 Выбирайте его в каталоге при создании отзывов: {my_event} </b>", parse_mode='HTML')
    else:
        #if len(get_all_shopx()) >= 1:
        await state.set_state("here_event_name")
        await message.answer("<b>🏪 Введите название события 🏷</b>", parse_mode='HTML')

        '''await message.answer("<b>📁 Выберите место события или укажите <code>0</code></b>",
                             reply_markup=select_place_in_city_swipe_fp(city_id))'''

# Создание новой позиции
@dp.message_handler(IsAdminorShopAdmin(), text_startswith="here_event_place:", state="*")
async def product_position_create(message: Message, state: FSMContext):
    place = int(str(message.data).split(':')[1])
    await state.update_data(data={'place_id': place})

    print("||")
    await state.set_state("here_event_name")
    await message.answer("<b>🏪 Введите название события 🏷</b>", parse_mode='HTML')


# Создание новой позиции
@dp.message_handler(IsAdminorShopAdmin(), text_startswith="here_event_place2:", state="*")
async def product_position_create(call: CallbackQuery, state: FSMContext):
    place = int(str(call.data).split(':')[1])
    await state.update_data(data={'place_id': place})

    print("||")
    await state.set_state("here_event_name")
    await message.answer("<b>🏪 Введите название события 🏷</b>", parse_mode='HTML')


# принятие названия магазина, запрос описания
@dp.message_handler(IsAdminorShopAdmin(), state="here_event_name")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        print("admin_products_shop - создание события")
        await state.update_data(data={'name': message.text})
        await state.set_state('here_event_description')
        await message.answer("<b>🏪 Введите Bio ведущих 📜</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", parse_mode='HTML')
    else:
        await message.answer("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "🏪 Введите название для ведущих 🏷", parse_mode='HTML')


# принятие описания магазина, запрос адреса
@dp.message_handler(IsAdminorShopAdmin(), state="here_event_description")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 600:
        if message.text == '0':
            await state.update_data(data={'description': 'None'})
        else:
            await state.update_data(data={'description': message.text})
        await state.set_state('here_event_webadress')
        await message.answer("<b>🏪 Отправьте описание события 📍</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", parse_mode='HTML')
    else:
        await message.answer("<b>❌ Описание не может превышать 600 символов.</b>\n"
                             "🏪 Введите веб-сайт события 📜\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", parse_mode='HTML')


# принятие адреса магазина, запрос номера
@dp.message_handler(IsAdminorShopAdmin(), state="here_event_webadress")
async def product_category_create_name(message: Message, state: FSMContext):
    if message.text == '0':
        await state.update_data(data={'webaddress': 'None'})
    else:
        await state.update_data(data={'webaddress': message.text})
    await state.set_state('here_event_logo')
    await message.answer("<b>🏪 Отправьте лого события 📷</b>\n"
                         "❕ Отправьте <code>0</code> чтобы пропустить.", parse_mode='HTML')


# принятие лого магазина, запрос лого
@dp.message_handler(IsAdminorShopAdmin(), content_types=['photo','text'], state="here_event_logo")
async def product_category_create_logo(message: Message, state: FSMContext):
    logo = message.photo[0].file_id if message.content_type == 'photo' else None
    async with state.proxy() as data:
        print(data)
        name = data['name']
        description = data['description']
        webaddress = data['webaddress']

    await state.finish()
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    type_trade = get_settingsx()
    if type_trade['type_trade'] != "digital":
        city = get_city_user3(message.from_user.id)
        print(city)
        city_id = city[0]
        geocode = city[1]
        city_name = city[2]
    else:
        city_id = 0
        geocode = ''
        city_name = ''
    add_eventx(name, description, webaddress, message.from_user.id, logo, city_id, geocode, city_name)
    await message.answer(_("<b>🏪 Карточка события была успешно создана ✅</b>", locale=lang), parse_mode='HTML')


# -----------------------------------------------------------------------------------------------------------
# Создание нового магазина
@dp.message_handler(text=["🏪 Создать магазин ➕", "🏪 Create Shop ➕"], state="*")
async def product_shop_create(message: Message, state: FSMContext):
    await state.finish()
    print("user_menu - создание магазина")
    print("-")
    user_id = message.from_user.id
    print(user_id)
    my_shop = check_user_shop_exist(user_id)
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    if user_role in ["Admin", "ShopAdmin"]:
        print(my_shop)
        if my_shop:
            print("|")
            await message.answer(f"<b>🏪 Магазин уже существует 🏷 Выбирайте его в каталоге при создании позиций: {my_shop} </b>", parse_mode='HTML')
        else:
            print("||")
            await state.set_state("here_shop_name")
            await message.answer(_("<b>🏪 Введите название для магазина 🏷</b>", locale=lang), parse_mode='HTML')


# принятие названия магазина, запрос описания
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_name")
async def product_category_create_name(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        user_id = message.from_user.id
        lang = get_user_lang(user_id)['user_lang']

        print("admin_products_shop - создание магазина")
        await state.update_data(data={'name': message.text})
        await state.set_state('here_shop_description')
        await message.answer(_("<b>🏪 Введите описание для магазина 📜</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')
    else:
        await message.answer(_("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "🏪 Введите название для магазина 🏷", locale=lang), parse_mode='HTML')


# принятие описания магазина, запрос адреса
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_description")
async def product_category_create_name(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    if len(message.text) <= 600:
        if message.text == '0':
            await state.update_data(data={'description': 'None'})
        else:
            await state.update_data(data={'description': message.text})
        await state.set_state('here_shop_adress')
        await message.answer(_("<b>🏪 Отправьте адрес магазина 📍</b>\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')

    else:
        await message.answer(_("<b>❌ Описание не может превышать 600 символов.</b>\n"
                             "🏪 Введите новое описание для магазина 📜\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


# принятие адреса магазина, запрос номера
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_adress")
async def product_category_create_name(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']
    if message.text == '0':
        await state.update_data(data={'address': 'None'})
    else:
        await state.update_data(data={'address': message.text})
    await state.set_state('here_shop_phone')
    await message.answer(_("<b>🏪 Отправьте телефон магазина ☎️</b>\n"
                         "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


# принятие номера магазина, запрос лого
@dp.message_handler(IsAdminorShopAdmin(), state="here_shop_phone")
async def product_category_create_name(message: Message, state: FSMContext):
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']
    if message.text == '0':
        await state.update_data(data={'phone': 'None'})
    else:
        await state.update_data(data={'phone': message.text})
    await state.set_state('here_shop_logo')
    await message.answer(_("<b>🏪 Отправьте лого магазина 📷</b>\n"
                         "❕ Отправьте <code>0</code> чтобы пропустить.", locale=lang), parse_mode='HTML')


# принятие лого магазина, запрос лого
@dp.message_handler(IsAdminorShopAdmin(), content_types=['photo','text'], state="here_shop_logo")
async def product_category_create_logo(message: Message, state: FSMContext):
    logo = message.photo[0].file_id if message.content_type == 'photo' else None
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    async with state.proxy() as data:
        print(data)
        name = data['name']
        description = data['description']
        address = data['address']
        phone = data['phone']

    await state.finish()

    type_trade = get_settingsx()
    if type_trade['type_trade'] != "digital":
        city = get_city_user3(message.from_user.id)
        print(city)
        city_id = city[0]
        geocode = city[1]
        city_name = city[2]
    else:
        city_id = 0
        geocode = ''
        city_name = ''
    add_shopx(name, description, address, phone, message.from_user.id, logo, city_id, geocode, city_name)
    await message.answer(_("<b>🏪 Магазин был успешно создан ✅</b>", locale=lang), parse_mode='HTML')


# -----------------------------------------------------------------------------------------------------------
# Открытие страниц выбора магазина для редактирования
@dp.message_handler(text=["🏪 Изменить магазин 🖍", "🏪 Edit Shop 🖍"], state="*")
async def shop_list_edit(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']

    if user_role == "Admin":
        shops = get_shopsxy()
    elif user_role == "ShopAdmin":
        shops = get_shopsxx(admin=user_id)
    print(shops)

    if len(shops) >= 1:
        await message.answer(_("<b>🏪 Выберите магазин для изменения 🖍</b>", locale=lang),
                             reply_markup=shop_edit_open_fp(0, user_id, lang))
    else:
        await message.answer(_("<b>🏪 Ваши магазины отсутствуют 🖍</b>", locale=lang))


# Смена страницы выбора магазина
@dp.message_handler(text_startswith="change_shop_edit_pg:", state="*")
async def shop_list_edit(call: CallbackQuery, state: FSMContext):
    await state.finish()
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']

    if user_role in ["Admin", "ShopAdmin"]:
        if len(shops) >= 1:
            page = int(str(call.data).split(':')[1])

            await call.message.answer(_("<b>🏪 Выберите магазин для изменения 🖍</b>", locale=lang),
                                      reply_markup=shop_edit_open_fp(0, user_id, lang))
        else:
            await call.message.answer(_("<b>🏪 Магазины отсутствуют 🖍</b>", locale=lang))


# Открытие сообщения с ссылкой на поддержку
@dp.message_handler(text=["☎ Поддержка", "/support"], state="*")
async def user_support(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    user_support = get_settingsx()['misc_support']
    if str(user_support).isdigit():
        get_user = get_userx(user_id=user_support)

        if len(get_user['user_login']) >= 1:
            await message.answer(_("<b>☎ Нажмите кнопку ниже для связи с Администратором.</b>", locale=lang),
                                 reply_markup=user_support_finl(get_user['user_login']))
            return
        else:
            update_settingsx(misc_support="None")

    await message.answer(f"☎ Поддержка. Измените их в настройках бота.\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n{BOT_DESCRIPTION}",
                         disable_web_page_preview=True)

# Создание запроса на продавца
@dp.message_handler(state="here_seller_request_direction")
async def user_seller(message: Message, state: FSMContext):
    await state.finish()
    # message.answer(message.text)
    seller_request = create_seller_request(message.from_user.id, message.text)
    await message.answer("👌 Ваш запрос успешно отправлен.")

# Просмотр истории покупок
@dp.callback_query_handler(text="create_seller_request5", state="*")
async def user_seller(call: CallbackQuery, state: FSMContext):
    seller_request = create_seller_request(call.from_user.id)
    await call.answer("🎁 Запрос успешно создан")
    await notify(dp, "Поступил новый запрос продавца!")
    # await bot.send_message(get_admins(), "ntcnnnnnn")

# Подтверждение удаления всех позиций
@dp.message_handler(IsShopAdmin(), text=["📁 Удалить все позиции ❌", "📁 Delete all Positions ❌"], state="*")
async def product_position_remove(message: Message, state: FSMContext):
    await state.finish()

    await message.answer("<b>📁 Вы действительно хотите удалить все позиции? ❌</b>\n"
                         "❗ Так же будут удалены все товары",
                         reply_markup=position_remove_confirm_inl)

# Удаление позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_delete", state="*")
async def product_position_edit_delete(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await call.message.delete()
    await call.message.answer(_("<b>📁 Вы действительно хотите удалить позицию? ❌</b>", locale=lang),
                              reply_markup=position_edit_delete_finl(position_id, category_id, remover))


# Подтверждение удаления позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_delete", state="*")
async def product_position_edit_delete_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])
    remover = int(call.data.split(":")[4])

    if get_action == "yes":
        remove_itemx(position_id=position_id)
        remove_positionx(position_id=position_id)

        await call.answer("📁 Вы успешно удалили позицию и её товары ✅")

        if len(get_positionsx(category_id=category_id)) >= 1:
            await call.message.edit_text(_("<b>📁 Выберите нужную вам позицию 🖍</b>", locale=lang),
                                         reply_markup=position_edit_open_fp(remover, category_id))
        else:
            await call.message.delete()
    else:
        get_message, get_photo = get_position_admin(position_id)

        if get_photo is not None:
            await call.message.delete()
            await call.message.answer_photo(get_photo, get_message,
                                            reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await call.message.edit_text(get_message,
                                         reply_markup=position_edit_open_finl(position_id, category_id, remover))


# Согласие очистики позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_clear", state="*")
async def product_position_edit_clear_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    category_id = int(call.data.split(":")[3])
    remover = int(call.data.split(":")[4])

    if get_action == "yes":
        remove_itemx(position_id=position_id)
        await call.answer("📁 Вы успешно удалили все товары позиции ✅")

    get_message, get_photo = get_position_admin(position_id)

    if get_photo is not None:
        await call.message.delete()
        await call.message.answer_photo(get_photo, get_message,
                                        reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await call.message.edit_text(get_message,
                                     reply_markup=position_edit_open_finl(position_id, category_id, remover))


# Открытие способов пополнения
@dp.message_handler(IsShopAdmin(), text=["🖲 Способы пополнения", "🖲 Payment Methods"], state="*")
async def payment_systems(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    print(user_role)
    if user_role == "Admin" or user_role == "ShopAdmin": #user_id in get_admins(): #
        await message.answer(_("<b>🖲 Выберите способ пополнения</b>", locale=lang), reply_markup=payment_as_choice_finl(user_id, lang))


# Включение/выключение самих способов пополнения
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="change_payment7:")
async def payment_systems_edit7(call: CallbackQuery):
    way_pay = call.data.split(":")[1]
    way_status = call.data.split(":")[2]
    user_id = json.dumos(call.data.split(":")[3])
    print("Админ магазина")
    # print(call.data.split(":")[0])
    print(call.from_user.id)
    user_id = call.from_user.id

    count = get_upaycount(user_id)
    print(count['paycount'])
    if count['paycount'] == 0:
        cur = create_upayments_row(user_id)
    else:
        get_payment = get_upaymentx(user_id)

    if get_payment['qiwi_login'] != "None" and get_payment['qiwi_token'] != "None" or way_status == "False":
        if way_pay == "Form":
            if get_payment['qiwi_secret'] != "None" or way_status == "False":
                update_upaymentx(user_id, way_form=way_status)
            else:
                await call.answer(
                    "❗ Приватный ключ отсутствует. Измените киви и добавьте приватный ключ для включения оплаты по Форме",
                    True)
        elif way_pay == "ForYm":
            if get_payment['yoo_token'] != "None" or way_status == "False":
                update_upaymentx(user_id, way_formy=way_status)
            else:
                await call.answer(
                    "❗ Номер счета отсутствует. Измените YooMoney и добавьте токен для включения оплаты по Форме YooMoney",
                    True)
        elif way_pay == "Number":
            update_update_upaymentx(user_id, way_number=way_status)
        elif way_pay == "Nickname":
            status, response = await (await QiwiAPI(call)).get_nickname()
            if status:
                update_upaymentx(user_id, way_nickname=way_status, qiwi_nickname=response)
            else:
                await call.answer(response, True)
    else:
        await call.answer("❗ Добавьте киви кошелёк перед включением Способов пополнений.", True)

    try:
        await call.message.edit_text(_("<b>🖲 Выберите способ пополнения</b>", locale=lang), reply_markup=payment_as_choice_finl())
    except Exception:
        pass


####################################### QIWI ######################################
# Изменение QIWI кошелька
@dp.message_handler(IsShopAdmin(), text=["🥝 Изменить QIWI 🖍", "🥝 Change QIWI 🖍"], state="*")
async def payment_qiwi_edit(message: Message, state: FSMContext):
    await state.finish()

    await state.set_state("here_qiwi_login")
    await message.answer(_("<b>🥝 Введите <code>номер (через +7, +380)</code> QIWI кошелька 🖍</b>", locale=lang))


# Проверка работоспособности QIWI
@dp.message_handler(IsAdminorShopAdmin(), text=["🥝 Проверить QIWI ♻", "🥝 Check QIWI ♻"], state="*")
async def payment_qiwi_check(message: Message, state: FSMContext):
    print("||| Проверка КИВИ админом площадки. |||")
    await state.finish()
    user_id = message.from_user.id
    print(user_id)

    await (await QiwiAPI(message, suser_id=user_id, check_pass=True)).pre_checker()


# Баланс QIWI
@dp.message_handler(IsAdminorShopAdmin(), text=["🥝 Баланс QIWI 👁", "🥝 Balance QIWI 👁"], state="*")
async def payment_qiwi_balance(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id

    await (await QiwiAPI(message, suser_id=user_id)).get_balance()


######################################## ПРИНЯТИЕ QIWI ########################################
# Принятие логина для QIWI
@dp.message_handler(IsShopAdmin(), state="here_qiwi_login")
async def payment_qiwi_edit_login(message: Message, state: FSMContext):
    if message.text.startswith("+"):
        await state.update_data(here_qiwi_login=message.text)

        await state.set_state("here_qiwi_token")
        await message.answer(
            "<b>🥝 Введите <code>токен API</code> QIWI кошелька 🖍</b>\n"
            "❕ Получить можно тут 👉 <a href='https://qiwi.com/api'><b>Нажми на меня</b></a>\n"
            "❕ При получении токена, ставьте только первые 3 галочки.",
            disable_web_page_preview=True
        )
    else:
        await message.answer("<b>❌ Номер должен начинаться с + <code>(+7..., +380...)</code></b>\n"
                             "🥝 Введите <code>номер (через +7, +380)</code> QIWI кошелька 🖍")


# Принятие токена для QIWI
@dp.message_handler(IsShopAdmin(), state="here_qiwi_token")
async def payment_qiwi_edit_token(message: Message, state: FSMContext):
    await state.update_data(here_qiwi_token=message.text)

    await state.set_state("here_qiwi_secret")
    await message.answer(
        "<b>🥝 Введите <code>Секретный ключ 🖍</code></b>\n"
        "❕ Получить можно тут 👉 <a href='https://qiwi.com/p2p-admin/transfers/api'><b>Нажми на меня</b></a>\n"
        "❕ Вы можете пропустить добавление оплаты по Форме, отправив: <code>0</code>",
        disable_web_page_preview=True
    )


# Принятие приватного ключа для QIWI
@dp.message_handler(IsAdminorShopAdmin(), state="here_qiwi_secret")
async def payment_qiwi_edit_secret(message: Message, state: FSMContext):
    async with state.proxy() as data:
        qiwi_login = data['here_qiwi_login']
        qiwi_token = data['here_qiwi_token']
        if message.text == "0": qiwi_secret = "None"
        if message.text != "0": qiwi_secret = message.text
        user_id = message.from_user.id

    await state.finish()

    cache_message = await message.answer(_("<b>🥝 Проверка введённых QIWI данных... 🔄</b>", locale=lang))
    await asyncio.sleep(0.5)

    await (await QiwiAPI(cache_message, qiwi_login, qiwi_token, qiwi_secret, add_pass=True, suser_id=user_id)).pre_checker()


################################################################################################
###################################### УДАЛЕНИЕ ВСЕХ ПОЗИЦИЙ ###################################
# Согласие на удаление всех позиций и товаров
@dp.callback_query_handler(IsShopAdmin(), text_startswith="confirm_remove_position:", state="*")
async def product_position_remove(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    print("SA DEL POSITIONS")
    user_id = call.from_user.id
    print(user_id)

    if get_action == "yes":

        get_positions = len(get_all_my_positionsnx(position_user_id=user_id))
        print(get_positions)
        get_items = len(get_all_my_itemsnx(creator_id=user_id))
        print(get_items)

        remove_positionx(position_user_id=user_id)
        remove_itemx(creator_id=user_id)

        await call.message.edit_text(
            f"<b>📁 Вы удалили все позиции<code>({get_positions}шт)</code> и товары<code>({get_items}шт)</code> ☑</b>")
    else:
        await call.message.edit_text(_("<b>📁 Вы отменили удаление всех позиций ✅</b>", locale=lang))

#################### УДАЛЕНИЕ ТОВАРОВ ###################
# Кнопки с подтверждением удаления всех категорий
@dp.message_handler(IsShopAdmin(), text=["🎁 Удалить все товары ❌", "🎁 Delete all goods ❌"], state="*")
async def product_item_remove(message: Message, state: FSMContext):
    await state.finish()

    await message.answer(_("<b>🎁 Вы действительно хотите удалить все товары? ❌</b>\n", locale=lang),
                         reply_markup=item_remove_confirm_inl)

##################################### УДАЛЕНИЕ ВСЕХ ТОВАРОВ ####################################
# Согласие на удаление всех товаров
@dp.callback_query_handler(IsShopAdmin(), text_startswith="confirm_remove_item:", state="*")
async def product_item_remove(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    if get_action == "yes":
        user_id = call.from_user.id

        get_items = len(get_all_my_itemsnx(creator_id=user_id))
        remove_itemx(creator_id=user_id)

        await call.message.edit_text(f"<b>🎁 Вы удалили все товары<code>({get_items}шт)</code> ☑</b>")
    else:
        await call.message.edit_text(_("<b>🎁 Вы отменили удаление всех товаров ✅</b>", locale=lang))


# Удаление определённых товаров
@dp.message_handler(IsShopAdmin(), text=["🎁 Удалить товары 🖍", "🎁 Delete Goods 🖍"], state="*")
async def product_item_delete(message: Message, state: FSMContext):
    await state.finish()

    await state.set_state("here_items_delete")
    await message.answer("<b>🖍 Вводите айди товаров, которые нужно удалить</b>\n"
                         "❕ Получить айди товаров можно при изменении позиции\n"
                         "❕ Если хотите удалить несколько товаров, отправьте ID товаров через запятую или пробел. Пример:\n"
                         "<code>▶ 123456,123456,123456</code>\n"
                         "<code>▶ 123456 123456 123456</code>")

################################################################################################
####################################### УДАЛЕНИЕ ТОВАРОВ ######################################
# Принятие айди товаров для их удаления
@dp.message_handler(IsAdminorShopAdmin(), state="here_items_delete")
async def product_item_delete_get(message: Message, state: FSMContext):
    await state.finish()
    user_id = message.from_user.id

    remove_ids, cancel_ids = [], []  # Айди удалённых и ненайденных товаров
    get_item_ids_one, get_item_ids_two = [], [[]]
    save_ids = []

    if "," in message.text:
        get_item_ids_one = clear_list(message.text.split(","))
    else:
        get_item_ids_one = clear_list([message.text])

    get_item_ids_two.extend(
        item.split(" ") for item in get_item_ids_one if " " in item
    )
    if len(get_item_ids_two) == 1:
        get_item_ids_two.append(get_item_ids_one)

    for check_item in get_item_ids_two:
        save_ids.extend(iter(clear_list(check_item)))
    save_ids = clear_list(save_ids)

    for item_id in save_ids:
        check_item = get_itemx(item_id=item_id, creator_id=user_id)
        if check_item is not None:
            remove_itemx(item_id=item_id)
            remove_ids.append(item_id)
        else:
            cancel_ids.append(item_id)

    remove_ids = ", ".join(remove_ids)
    cancel_ids = ", ".join(cancel_ids)

    await message.answer(f"<b>✅ Успешно удалённые товары:\n"
                         f"▶ <code>{remove_ids}</code>\n"
                         f"➖➖➖➖➖➖➖➖➖➖\n"
                         f"❌ Ненайденные товары:\n"
                         f"▶ <code>{cancel_ids}</code></b>")
###############################################################################################
################################################################################################
####################################### ДОБАВЛЕНИЕ ПОЗИЦИЙ #####################################
# Следующая страница выбора категорий для создания позиций
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="position_create_nextp:", state="*")
async def product_position_create_next(call: CallbackQuery, state: FSMContext):
    print('выбора категорий для создания позиций  user_menu.py 126')
    remover = int(call.data.split(":")[1])
    lang = call.data.split(":")[2]
    print(remover)

    await call.message.edit_text(_("<b>📁 Выберите категорию для позиции ➕</b>", locale=lang),
                                 reply_markup=position_create_next_page_fp(remover, lang))

# Предыдущая страница выбора категорий для создания позиций
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="position_create_backp:", state="*")
async def product_position_create_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    lang = call.data.split(":")[2]

    await call.message.edit_text(_("<b>📁 Выберите категорию для позиции ➕</b>", locale=lang),
                                 reply_markup=position_create_back_page_fp(remover, lang))


# Выбор категории для создания позиции
@dp.callback_query_handler(text_startswith="position_people_create_here:", state="*")
async def product_position_create_select_category(call: CallbackQuery, state: FSMContext):
    print('position_people_create_here - user_menu 160')
    category_id = int(call.data.split(":")[1])
    await state.update_data(here_cache_change_category_id=category_id)
    await state.update_data(here_position_source="people")
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    if user_role == "Admin" or user_role == "ShopAdmin":
        await state.set_state("here_position_name")
        await call.message.edit_text("<b>📁 Введите название для позиции 🏷</b>")

# Выбор категории для создания позиции
@dp.callback_query_handler(text_startswith="position_people_open_here:", state="*")
async def product_position_open_select_category(call: CallbackQuery, state: FSMContext):
    print('position_people_open_here - user_menu 1397')
    category_id = int(call.data.split(":")[1])
    city_id = int(call.data.split(":")[3])
    print(category_id, city_id)
    get_category = get_category_people(category_id=category_id)
    #if city_id == 0:
    #    city_id = get_city_user(call.from_user.id)[0]
    #else: city_id = int(call.data.split(":")[3])
    print(category_id, city_id, get_category)

    source = "people"
    get_positions = get_people_positions_in_cityx(category_id=category_id, position_city_id=city_id, flagallc=1, position_type=1)  # flagallc=1,  get_positionsx(category_id=category_id)
    print(category_id, city_id)
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    #user_role = get_userx(user_id=user_id)['user_role']
    #if user_role == "Admin" or user_role == "ShopAdmin":
    if len(get_positions) >= 1:
        #source = "people"
        await call.message.edit_text(f"<b>🎁 Товары частных лиц в категории: {get_category['category']}</b>",
                                     reply_markup=products_item_position_swipe_fp(0, "open", category_id, city_id, source, lang))
    else:
        await call.answer(f"❕ Товары в категории {get_category['category']} отсутствуют")



# Выбор категории для создания позиции
@dp.callback_query_handler(text_startswith="position_edit_category_open", state="*")
async def product_position_create_select_category(call: CallbackQuery, state: FSMContext):
    print('position_edit_here - user_menu 160')
    category_id = int(call.data.split(":")[1])
    city_id = int(call.data.split(":")[2])

    await state.update_data(here_cache_change_category_id=category_id)
    await state.update_data(here_position_source="commercial")

    action = "edit"
    source = "commercial"
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    get_cat_pos = get_positionsx(category_id=category_id)
    print(get_cat_pos)
    if user_role in ['Admin', 'ShopAdmin']:
        if len(get_cat_pos) >= 1:
            await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                                         reply_markup=products_item_position_swipe_fp(0, action, category_id, city_id, source, lang))
            await state.set_state("here_position_addtoshop")


# Выбор категории для создания позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="position_create_here:", state="*")
async def product_position_create_select_category(call: CallbackQuery, state: FSMContext):
    print('position_create_here - user_menu 160')
    category_id = int(call.data.split(":")[1])
    await state.update_data(here_cache_change_category_id=category_id)
    await state.update_data(here_position_source="commercial")

    print('position_addtoshop - user_menu 555')
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    get_user_shops = get_shopsxx(admin=user_id)
    if len(get_user_shops) >= 1:
        await call.message.edit_text(_("<b>Выберите магазин для добавления позиции.</b>", locale=lang),
                                     reply_markup=position_select_shop_fp(0, lang))
    else:
        await call.message.edit_text(_("<b>У Вас еще нет магазина на площадке, но Вы можете его создать.</b>", locale=lang),
                                     reply_markup=shop_creation_request_finl(lang))
        await state.set_state("here_position_addtoshop")


# Выбор категории для создания позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="here_position_addtoshop:", state="*")
async def product_position_create_select_category(call: CallbackQuery, state: FSMContext):
    print('here_position_addtoshop: - user_menu 566')
    key = call.data.split(":")[1]
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    if key != "NoCreate":
        shop_id = int(call.data.split(":")[1])
        await state.update_data(here_cache_change_shop_id=shop_id)

        await state.set_state("here_position_name")
        await call.message.edit_text(_("<b>📁 Введите название для позиции 🏷</b>", locale=lang))


# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Заготовка под принятие города магазином
# Принятие города для создания позиции
# @dp.message_handler(IsShopAdmin(), state="here_position_city")
# async def product_position_create_name(message: Message, state: FSMContext):
#     print(f'Принятие города для создания позиции  admin_products_shop.py 344')
#     city_user = get_city_user(message.from_user.id)
# Принятие имени для создания позиции


@dp.message_handler(IsAdminorShopAdmin(), state="here_position_name")
async def product_position_create_name(message: Message, state: FSMContext):
    print('Принятие имени для создания позиции  user_menu.py 1084')
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    if len(message.text) <= 100:
        await state.update_data(here_position_name=clear_html(message.text),
                                here_position_city=get_citytext_user(message.from_user.id)[0]
                                , position_city_id=get_city_user(message.from_user.id)[0])

        await state.set_state("here_position_type")
        await message.answer(_("<b>📁 Введите тип позиции 1 - реальная, 2 - цифровая</b>", locale=lang), reply_markup=position_select_type_finl(lang))
    else:
        await message.answer("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "📁 Введите название для позиции 🏷")


@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="here_position_type:", state="*")
async def product_position_create_type(call: CallbackQuery, state: FSMContext):
    print('Принятие имени для создания позиции  user_menu.py 1084')
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    position_type_txt = call.data.split(":")[1]
    position_type = 1 if position_type_txt == "real" else 2
    #print(message.text)
    if len(position_type_txt) <= 7:
        await state.update_data(here_position_type=position_type, #clear_html(message.text),
                                here_position_city=get_citytext_user(call.from_user.id)[0]
                                , position_city_id=get_city_user(call.from_user.id)[0])

        await state.set_state("here_position_price")
        await call.message.answer(_("<b>📁 Введите цену для позиции 💰</b>", locale=lang))
    else:
        await call.message.answer("<b>❌ Тип позиции не может отличаться от перечисленных значений. 1 или 2.</b>\n"
                             "📁 Введите тип позиции 🏷")


# Принятие цены позиции для её создания
@dp.message_handler(IsAdminorShopAdmin(), state="here_position_price")
async def product_position_create_price(message: Message, state: FSMContext):
    print('Принятие цены позиции  admin_products.py 366')
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    if message.text.isdigit():
        if 0 <= int(message.text) <= 10000000:
            await state.update_data(here_position_price=message.text)
        else:
            await message.answer("<b>❌ Цена не может быть меньше 0 или больше 10 000 000.</b>\n"
                                 "📁 Введите цену для позиции 💰")
    else:
        await message.answer("<b>❌ Данные были введены неверно.</b>\n"
                             "📁 Введите цену для позиции 💰")

    position_data = await state.get_data()
    print(position_data['here_position_type'])
    position_type = position_data['here_position_type']

    if position_type == 1:
        await state.set_state("here_position_rest")
        await message.answer(_("<b>📁 Введите остаток для позиции 📜</b>", locale=lang))

    elif position_type == 2:
        await state.set_state("here_position_rest")
        await product_position_create_in_rest(message, state)


# Принятие цены позиции для её создания
@dp.message_handler(IsAdminorShopAdmin(), state="here_position_rest")
async def product_position_create_in_rest(message: Message, state: FSMContext):
    print('Принятие остатка позиции  admin_products.py 366')
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    #position_data = await state.get_data()
    async with state.proxy() as data:
        #print(position_data['here_position_type'])
        print(data['here_position_type'])
        #position_type = position_data['here_position_type']
        position_type = data['here_position_type']
    if position_type == 1:
        if message.text.isdigit():
            if 0 <= int(message.text) <= 10000:
                await state.update_data(here_position_rest=message.text)
            else:
                await message.answer("<b>❌ Остаток не может быть меньше 0 или больше 10 000.</b>\n"
                                     "📁 Введите остаток позиции 💰")
        else:
            await message.answer("<b>❌ Данные были введены неверно.</b>\n"
                                 "📁 Введите остаток позиции 💰")
    elif position_type == 2:
        await state.update_data(here_position_rest=0)

    await state.set_state("here_position_description")
    await message.answer("<b>📁 Введите описание для позиции 📜</b>\n"
                         "❕ Вы можете использовать HTML разметку\n"
                         "❕ Отправьте <code>0</code> чтобы пропустить.")


# Принятие описания позиции для её создания
@dp.message_handler(IsAdminorShopAdmin(), state="here_position_description")
async def product_position_create_description(message: Message, state: FSMContext):
    print('Принятие описания позиции  admin_products.py 386')

    try:
        if len(message.text) <= 900:
            if message.text != "0":
                cache_msg = await message.answer(message.text)
                await cache_msg.delete()

            await state.update_data(here_position_description=message.text)

            await state.set_state("here_position_photo")
            await message.answer("<b>📁 Отправьте изображение для позиции 📸</b>\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.")
        else:
            await message.answer("<b>❌ Описание не может превышать 600 символов.</b>\n"
                                 "📁 Введите новое описание для позиции 📜\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.")
    except CantParseEntities:
        await message.answer("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📁 Введите описание для позиции 📜\n"
                             "❕ Вы можете использовать HTML разметку\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.")


# Принятие изображения позиции для её создания
@dp.message_handler(IsAdminorShopAdmin(), content_types="photo", state="here_position_photo")
@dp.message_handler(IsAdminorShopAdmin(), text="0", state="here_position_photo")
async def product_position_create_photo(message: Message, state: FSMContext):
    print('Принятие изображения позиции  admin_products.py 418')
    user_id = message.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    async with state.proxy() as data:
        position_user_id = message.from_user.id
        position_city = data['here_position_city']
        position_city_id = data['position_city_id']
        position_name = clear_html(data['here_position_name'])
        position_price = data['here_position_price']
        position_type = data['here_position_type']
        if position_type == 1:
            position_rest = data['here_position_rest']
        elif position_type == 2:
            position_rest = 0
        catategory_id = data['here_cache_change_category_id']
        position_source = data['here_position_source']
        if position_source == "commercial":
            position_shop_id = data['here_cache_change_shop_id']
        elif position_source == "people":
            position_shop_id = 0
        position_description = data['here_position_description']
        position_source = data['here_position_source']
    await state.finish()

    position_photo = "" if "text" in message else message.photo[-1].file_id
    add_positionx(position_city, position_city_id, position_name, position_price, position_type, position_rest, position_description, position_photo,
                  catategory_id, position_shop_id, position_user_id, position_source)

    #async def on_notify(dp: Dispatcher, msg, markup):
    #    await send_admins(msg, markup="default")
    await notify(dp, f"Создана позиция: {position_name}, пользователем ID: {position_user_id}")

    await message.answer(_("<b>📁 Позиция была успешно создана ✅</b>", locale=lang))


################################################################################################
####################################### ИЗМЕНЕНИЕ ПОЗИЦИЙ #####################################
# Возвращение к начальным категориям для редактирования позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_category_return", state="*")
async def product_position_edit_return(call: CallbackQuery, state: FSMContext):
    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                                 reply_markup=position_edit_category_open_fp(0))


# Следующая страница категорий для редактирования позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_category_nextp:", state="*")
async def product_position_edit_category_next(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                                 reply_markup=position_edit_category_next_page_fp(remover))


# Предыдущая страница категорий для редактирования позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_category_backp:", state="*")
async def product_position_edit_category_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                                 reply_markup=position_edit_category_back_page_fp(remover))


# Выбор категории с нужной позицией
@dp.callback_query_handler(text_startswith="position_edit_category_swipe:", state="*")
async def product_position_edit_category_open(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    city_id = int(call.data.split(":")[2])
    lang = call.data.split(":")[3]
    user_id = call.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    #print(i18n.get_user_locale('position_edit', user_id=message.from_user.id))
    action = "edit"
    if user_role in ["Admin", "ShopAdmin"]:
        #if len(get_category_in_cityx(parent_id=category_id)) >= 1:
        await call.message.edit_text(_("<b>📁 Выберите нужную вам позицию 🖍</b>", locale=lang),
                                     reply_markup=products_item_category_swipe_fp(0, category_id, city_id, action, lang))
        #else:
        #    await call.answer("📁 Позиции в данной категории отсутствуют")



# Следующая страница позиций для их изменения
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_nextp:", state="*")
async def product_position_edit_next(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                                 reply_markup=position_edit_next_page_fp(remover, category_id))


# Предыдущая страница позиций для их изменения
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_backp:", state="*")
async def product_position_edit_back(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.edit_text(_("<b>📁 Выберите категорию с нужной позицией 🖍</b>", locale=lang),
                                 reply_markup=position_edit_back_page_fp(remover, category_id))


# Выбор позиции для редактирования
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="position_edit:", state="*")
async def product_position_edit_open(call: CallbackQuery, state: FSMContext):
    print('Выбор позиции для редактирования api_sqlite.py 1707')
    position_id = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    city_id = int(call.data.split(":")[4])
    lang = call.data.split(":")[5]
    user_id = call.from_user.id
    user_role = get_userx(user_id=user_id)['user_role']
    print(position_id, category_id, remover, city_id, lang)

    # IsProductShopAdmin()
    adminspos = check_position_owner(user_id, position_id)
    if adminspos is True:

        get_message, get_photo = get_position_admin(position_id)

        if get_photo is not None:
            await call.message.delete()
            await call.message.answer_photo(get_photo, get_message,
                                            reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
        else:
            await call.message.edit_text(get_message,
                                         reply_markup=position_edit_open_finl(position_id, category_id, remover, lang))
    else:
        await call.answer("<b>❗ У Вас нет прав редактировать данную позицию.</b>")


# Возвращение к выбору позиции для изменения
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_return", state="*")
async def product_position_edit_return(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    city_id = get_userx(user_id=user_id)['user_city_id']
    action = "edit"
    source = "commercial"

    if len(get_positionsx(category_id=category_id)) >= 1:
        await call.message.delete()
        await call.message.answer(_("<b>📁 Выберите нужную вам позицию 🖍</b>", locale=lang),
                                  reply_markup=products_item_position_swipe_fp(remover, action, category_id, city_id, source, lang))
    else:
        await call.answer("<b>❗ Позиции в данной категории отсутствуют</b>")


######################################## САМО ИЗМЕНЕНИЕ ПОЗИЦИИ ########################################
# Изменение имени позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_name", state="*")
async def product_position_edit_name(call: CallbackQuery, state: FSMContext):
    print('Изменение имени позиции api_sqlite.py 529')
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_name")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Введите новое название для позиции 🏷</b>", locale=lang))


# Принятие имени позиции для её изменения
@dp.message_handler(IsShopAdmin(), state="here_change_position_name")
async def product_position_edit_name_get(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        async with state.proxy() as data:
            position_id = data['here_cache_position_id']
            category_id = data['here_cache_category_id']
            remover = data['here_cache_position_remover']
        await state.finish()

        update_positionx(position_id, position_name=clear_html(message.text))
        get_message, get_photo = get_position_admin(position_id)

        if get_photo is not None:
            await message.answer_photo(get_photo, get_message,
                                       reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await message.answer(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await message.answer("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "📁 Введите новое название для позиции 🏷")

# Изменение цены позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_price", state="*")
async def product_position_edit_price(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_price")
    await call.message.delete()
    await call.message.answer(_("<b>📁 Введите новую цену для позиции 💰</b>", locale=lang))


# Принятие цены позиции для её изменения
@dp.message_handler(IsShopAdmin(), state="here_change_position_price")
async def product_position_edit_price_get(message: Message, state: FSMContext):
    if message.text.isdigit():
        if 0 <= int(message.text) <= 10000000:
            async with state.proxy() as data:
                position_id = data['here_cache_category_id']
                category_id = data['here_cache_position_id']
                remover = data['here_cache_position_remover']
            await state.finish()

            update_positionx(position_id, position_price=message.text)
            get_message, get_photo = get_position_admin(position_id)

            if get_photo is not None:
                await message.answer_photo(get_photo, get_message,
                                           reply_markup=position_edit_open_finl(position_id, category_id, remover))
            else:
                await message.answer(get_message,
                                     reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await message.answer("<b>❌ Цена не может быть меньше 0 или больше 10 000 000.</b>\n"
                                 "📁 Введите цену для позиции 💰")
    else:
        await message.answer("<b>❌ Данные были введены неверно.</b>\n"
                             "📁 Введите цену для позиции 💰")


# Изменение описания позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_description", state="*")
async def product_position_edit_description(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_description")
    await call.message.delete()
    await call.message.answer("<b>📁 Введите новое описание для позиции 📜</b>\n"
                              "❕ Вы можете использовать HTML разметку\n"
                              "❕ Отправьте <code>0</code> чтобы пропустить.")


# Принятие описания позиции для её изменения
@dp.message_handler(IsShopAdmin(), state="here_change_position_description")
async def product_position_edit_description_get(message: Message, state: FSMContext):
    async with state.proxy() as data:
        position_id = data['here_cache_category_id']
        category_id = data['here_cache_position_id']
        remover = data['here_cache_position_remover']

    try:
        if len(message.text) <= 600:
            await state.finish()

            if message.text != "0":
                cache_msg = await message.answer(message.text)
                await cache_msg.delete()

            update_positionx(position_id, position_description=message.text)
            get_message, get_photo = get_position_admin(position_id)

            if get_photo is not None:
                await message.answer_photo(get_photo, get_message,
                                           reply_markup=position_edit_open_finl(position_id, category_id, remover))
            else:
                await message.answer(get_message,
                                     reply_markup=position_edit_open_finl(position_id, category_id, remover))
        else:
            await message.answer("<b>❌ Описание не может превышать 600 символов.</b>\n"
                                 "📁 Введите новое описание для позиции 📜\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.")
    except CantParseEntities:
        await message.answer("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📁 Введите новое описание для позиции 📜\n"
                             "❕ Вы можете использовать HTML разметку\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.")


# Изменение изображения позиции
@dp.callback_query_handler(IsShopAdmin(), text_startswith="position_edit_photo", state="*")
async def product_position_edit_photo(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    position_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    #get_position = get_positionx(position_id=position_id)


    await state.update_data(here_cache_category_id=category_id)
    await state.update_data(here_cache_position_id=position_id)
    await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_position_photo")
    await call.message.delete()
    await call.message.answer(f"<b>📁 Отправьте новое изображение для позиции 📸</b>\n"
                              f":{position_id}\n"
                              f"❕ Отправьте <code>0</code> чтобы пропустить.")


# Принятие нового фото для позиции
@dp.message_handler(IsShopAdmin(), content_types="photo", state="here_change_position_photo")
@dp.message_handler(IsShopAdmin(), text="0", state="here_change_position_photo")
async def product_position_edit_photo_get(message: Message, state: FSMContext):
    async with state.proxy() as data:
        position_id = data['here_cache_category_id']
        category_id = data['here_cache_position_id']
        remover = data['here_cache_position_remover']
    await state.finish()

    position = get_positionx(position_id=position_id)
    print(position['position_name'])

    position_photo = "" if "text" in message else message.photo[-1].file_id
    update_positionx(position_id, position_photo=position_photo)
    get_message, get_photo = get_position_admin(position_id)
    await notify(dp, f"Была отредактирована позиция: {position['position_name']}")

    if get_photo is not None:
        await message.answer_photo(get_photo, get_message,
                                   reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await message.answer(get_message, reply_markup=position_edit_open_finl(position_id, category_id, remover))

# Изменение города продукта
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="shop_edit_city", state="*")
async def product_position_edit_description2(call: CallbackQuery, state: FSMContext):
    print('Изменение города продукта  admin_products.py 715')
    print(call.data)
    category_id = int(call.data.split(":")[2])
    position_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[3])

    current_city = get_city_user(call.from_user.id)[0]
    get_user_shops = get_shopsxx(admin=user_id)
    if len(get_user_shops) >= 1:
        await call.message.edit_text(_("<b>Выберите магазин для добавления позиции.</b>", locale=lang),
                                     reply_markup=position_select_shop_fp(0))

    await state.set_state("here_change_shop")

    # await state.update_data(here_cache_category_id=category_id)
    # await state.update_data(here_cache_position_id=position_id)
    # await state.update_data(here_cache_position_remover=remover)


    #await state.update_data({'position_id': position_id, 'category_id': category_id, 'remover': remover})
    #await call.message.delete()
    #await call.message.answer("<b>📁 Выберите другой город 🏙</b>\n"
    #                          "❕ Вы можете использовать геолокацию или выбрать город из списка\n"
    #                          f"❕  Город товара: <code>{current_city}</code>", reply_markup=geo_1_kb())


# ---------------------------  Добавлено 12.08.22 ------------------------------------------

# Изменение города продукта
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="position_edit_city", state="*")
async def product_position_edit_city(call: CallbackQuery, state: FSMContext):
    print('Изменение города продукта  admin_products.py 715')
    print(call.data)
    category_id = int(call.data.split(":")[2])
    position_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[3])

    current_city = get_city_user(call.from_user.id)[0]

    # await state.update_data(here_cache_category_id=category_id)
    # await state.update_data(here_cache_position_id=position_id)
    # await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_city")
    await state.update_data({'position_id': position_id, 'category_id': category_id, 'remover': remover})
    await call.message.delete()
    await call.message.answer("<b>📁 Выберите другой город 🏙</b>\n"
                              "❕ Вы можете использовать геолокацию или выбрать город из списка\n"
                             f"❕ Город товара: <code>{current_city}</code>", reply_markup=geo_1_kb(lang))


# принятие новой геопозиции для позиции
@dp.callback_query_handler(text_startswith='geo_chosen_cities', state='here_change_city')
async def geo_5(cb: CallbackQuery, state: FSMContext):
    info = int(str(cb.data).split('#')[1])
    if info == 0:
        async with state.proxy() as data:
            city = data['city']
            position_id = int(data['position_id'])
            category_id = data['category_id']
            remover = data['remover']
            city_id = data['city_id']

    else:
        async with state.proxy() as data:
            position_id = int(data['position_id'])
            category_id = data['category_id']
            remover = data['remover']

        city_id = info
        city = get_city_info(info)

    await state.finish()
    update_position_city(city, city_id, position_id)

    get_message, get_photo = get_position_admin(position_id)

    if get_photo is not None:
        await cb.message.answer_photo(get_photo, get_message,
                                      reply_markup=position_edit_open_finl(position_id, category_id, remover))
    else:
        await cb.message.answer(get_message,
                                reply_markup=position_edit_open_finl(position_id, category_id, remover))

######################################## САМО ИЗМЕНЕНИЕ ПОЗИЦИИ ########################################
# Изменение имени позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit_name", state="*")
async def tgartist_edit_name(call: CallbackQuery, state: FSMContext):
    print('Изменение имени артиста api_sqlite.py 529')
    artist_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_artist_id=artist_id)
    await state.update_data(here_cache_user_id=user_id)
    await state.update_data(here_cache_artist_remover=remover)

    await state.set_state("here_change_artist_name")
    await call.message.delete()
    await call.message.answer("<b>📁 Введите новое название для артиста 🏷</b>")


# Принятие имени артиста для его изменения
@dp.message_handler(IsAdminorShopAdmin(), state="here_change_artist_name")
async def artist_edit_name_get(message: Message, state: FSMContext):
    if len(message.text) <= 100:
        async with state.proxy() as data:
            artist_id = data['here_cache_artist_id']
            user_id = data['here_cache_user_id']
            remover = data['here_cache_artist_remover']
        await state.finish()

        update_artistx(artist_id, name=clear_html(message.text))
        get_message, get_photo = get_artist_admin(artist_id)

        if get_photo is not None:
            await message.answer_photo(get_photo, get_message,
                                       reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
        else:
            await message.answer(get_message, reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
    else:
        await message.answer("<b>❌ Название не может превышать 100 символов.</b>\n"
                             "📁 Введите новое название для артиста 🏷")
################################################################################################
# РЕДАКТИРОВАНИЕ ОПИСАНИЯ АРТИСТА
###################################
# Изменение описания артиста
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit_description", state="*")
async def artist_edit_description(call: CallbackQuery, state: FSMContext):
    artist_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_artist_id=artist_id)
    await state.update_data(here_cache_user_id=user_id)
    await state.update_data(here_cache_artist_remover=remover)

    await state.set_state("here_change_artist_description")
    await call.message.delete()
    await call.message.answer("<b>📁 Введите новое описание для артиста 📜</b>\n"
                              "❕ Вы можете использовать HTML разметку\n"
                              "❕ Отправьте <code>0</code> чтобы пропустить.")


# Принятие описания позиции для её изменения
@dp.message_handler(IsAdminorShopAdmin(), state="here_change_artist_description")
async def product_artist_edit_description_get(message: Message, state: FSMContext):
    async with state.proxy() as data:
        artist_id = data['here_cache_artist_id']
        user_id = data['here_cache_user_id']
        remover = data['here_cache_artist_remover']

    try:
        if len(message.text) <= 600:
            await state.finish()

            if message.text != "0":
                cache_msg = await message.answer(message.text)
                await cache_msg.delete()

            update_artistx(artist_id, description=clear_html(message.text))
            get_message, get_photo = get_artist_admin(artist_id)

            if get_photo is not None:
                await message.answer_photo(get_photo, get_message,
                                           reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
            else:
                await message.answer(get_message,
                                     reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
        else:
            await message.answer("<b>❌ Описание не может превышать 600 символов.</b>\n"
                                 "📁 Введите новое описание для артиста 📜\n"
                                 "❕ Вы можете использовать HTML разметку\n"
                                 "❕ Отправьте <code>0</code> чтобы пропустить.")
    except CantParseEntities:
        await message.answer("<b>❌ Ошибка синтаксиса HTML.</b>\n"
                             "📁 Введите новое описание для артиста 📜\n"
                             "❕ Вы можете использовать HTML разметку\n"
                             "❕ Отправьте <code>0</code> чтобы пропустить.")
##############################################################################################
########################## ARTIST _____ EDIT ________ PHOTO
##############################################################################################
# Изменение изображения позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit_photo", state="*")
async def artist_edit_photo(call: CallbackQuery, state: FSMContext):
    artist_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_artist_id=artist_id)
    await state.update_data(here_cache_user_id=user_id)
    await state.update_data(here_cache_artist_remover=remover)

    await state.set_state("here_change_artist_photo")
    await call.message.delete()
    await call.message.answer("<b>📁 Отправьте новое изображение для артиста 📸</b>\n"
                              "❕ Отправьте <code>0</code> чтобы пропустить.")


# Принятие нового фото для позиции
@dp.message_handler(IsAdminorShopAdmin(), content_types="photo", state="here_change_artist_photo")
@dp.message_handler(IsAdminorShopAdmin(), text="0", state="here_change_artist_photo")
async def product_artist_edit_photo_get(message: Message, state: FSMContext):
    async with state.proxy() as data:
        artist_id = data['here_cache_artist_id']
        user_id = data['here_cache_user_id']
        remover = data['here_cache_artist_remover']
    await state.finish()

    artist = get_artistx(artist_id = artist_id)
    print(artist['name'])

    artist_photo = "" if "text" in message else message.photo[-1].file_id
    update_artistx(artist_id, logo=artist_photo)
    get_message, get_photo = get_artist_admin(artist_id)
    await notify(dp, f"Был отредактирован артист: {artist['name']}")

    if get_photo is not None:
        await message.answer_photo(get_photo, get_message,
                                   reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
    else:
        await message.answer(get_message, reply_markup=artist_edit_open_finl(artist_id, user_id, remover))


# Изменение города продукта
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit_city", state="*")
async def product_position_edit_description(call: CallbackQuery, state: FSMContext):
    print('Изменение города артиста  admin_products.py 715')
    print(call.data)
    artist_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    current_city = get_city_artist(artist_id=artist_id)[0]

    # await state.update_data(here_cache_category_id=category_id)
    # await state.update_data(here_cache_position_id=position_id)
    # await state.update_data(here_cache_position_remover=remover)

    await state.set_state("here_change_city_artist")
    await state.update_data({'artist_id': artist_id, 'user_id': user_id, 'remover': remover})
    await call.message.delete()
    await call.message.answer("<b>📁 Выберите другой город 🏙</b>\n"
                              "❕ Вы можете использовать геолокацию или выбрать город из списка\n"
                              f"❕ Город артиста: <code>{current_city}</code>", reply_markup=geo_1_kb(lang))


# принятие новой геопозиции для позиции
@dp.callback_query_handler(text_startswith='geo_chosen_cities', state='here_change_city_artist')
async def geo_5(cb: CallbackQuery, state: FSMContext):
    info = int(str(cb.data).split('#')[1])
    if info == 0:
        async with state.proxy() as data:
            city = data['city']
            artist_id = int(data['artist_id'])
            user_id = data['user_id']
            remover = data['remover']
            city_id = data['city_id']

    else:
        async with state.proxy() as data:
            artist_id = int(data['artist_id'])
            user_id = data['user_id']
            remover = data['remover']

        city_id = info
        city = get_city_info(info)

    await state.finish()
    update_artist_city(city, city_id, artist_id)

    # update_positionx(position_id)
    get_message, get_photo = get_artist_admin(artist_id)

    if get_photo is not None:
        await cb.message.answer_photo(get_photo, get_message,
                                      reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
    else:
        await cb.message.answer(get_message,
                                reply_markup=artist_edit_open_finl(artist_id, user_id, remover))

# Удаление позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_edit_delete", state="*")
async def artist_edit_delete(call: CallbackQuery, state: FSMContext):
    artist_id = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])

    await state.update_data(here_cache_artist_id=artist_id)
    await state.update_data(here_cache_user_id=user_id)
    await state.update_data(here_cache_artist_remover=remover)

    await call.message.delete()
    await call.message.answer(_("<b>📁 Вы действительно хотите удалить позицию? ❌</b>", locale=lang),
                              reply_markup=artist_edit_delete_finl())


# Подтверждение удаления позиции
@dp.callback_query_handler(IsAdminorShopAdmin(), text_startswith="artist_delete", state="*")
async def artist_edit_delete_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    async with state.proxy() as data:
        artist_id = data['here_cache_artist_id']
        user_id = data['here_cache_user_id']
        remover = data['here_cache_artist_remover']
    await state.finish()

    if get_action == "yes":
        #remove_itemx(position_id=position_id)
        remove_artistx(artist_id=artist_id)

        await call.answer("📁 Вы успешно удалили артиста ✅")

        if len(get_artistx(admin=user_id)) >= 1:
            await call.message.edit_text("<b>📁 Выберите нужного Вам артиста 🖍</b>",
                                         reply_markup=artist_edit_open_fp(remover, user_id))
        else:
            await call.message.delete()
    else:
        get_message, get_photo = get_artist_admin(artist_id)

        if get_photo is not None:
            await call.message.delete()
            await call.message.answer_photo(get_photo, get_message,
                                            reply_markup=artist_edit_open_finl(artist_id, user_id, remover))
        else:
            await call.message.edit_text(get_message,
                                         reply_markup=artist_edit_open_finl(artist_id, user_id, remover))

# Просмотр истории покупок
@dp.callback_query_handler(text="user_history", state="*")
async def user_history(call: CallbackQuery, state: FSMContext):
    last_purchases = last_purchasesx(call.from_user.id, 5)

    if len(last_purchases) >= 1:
        await call.answer("🎁 Последние 5 покупок")
        await call.message.delete()

        for purchases in last_purchases:
            link_items = await upload_text(call, purchases['purchase_item'])

            await call.message.answer(f"<b>🧾 Чек: <code>#{purchases['purchase_receipt']}</code></b>\n"
                                      f"🎁 Товар: <code>{purchases['purchase_position_name']} | {purchases['purchase_count']}шт | {purchases['purchase_price']}₽</code>\n"
                                      f"🕰 Дата покупки: <code>{purchases['purchase_date']}</code>\n"
                                      f"🔗 Товары: <a href='{link_items}'>кликабельно</a>")

        await call.message.answer(open_profile_my(call.from_user.id), reply_markup=profile_open_inl)
    else:
        await call.answer("❗ У вас отсутствуют покупки", True)


# Возвращение к профилю
@dp.callback_query_handler(text="user_profile", state="*")
async def user_profile_return(call: CallbackQuery, state: FSMContext):
    await call.message.edit_text(open_profile_my(call.from_user.id), reply_markup=profile_open_inl)


# Возвращение к корзине
@dp.callback_query_handler(text="user_cart", state="*")
async def user_cart_return(call: CallbackQuery, state: FSMContext):
    user_id = call.from_user.id
    get_user = get_userx(user_id=user_id)
    orderdata = get_params_orderx(user_id=user_id)

    for order in orderdata:
        order_id = orderdata['order_id']
        if order['order_state'] == 'created':
            await call.message.answer(open_cart_orders(order_id, user_id), reply_markup=cart_open_created_inl) #(orderdata['order_id'], lang)
        if order['order_state'] == 'delivery':
            await call.message.answer(open_cart_orders(order_id , user_id), reply_markup=cart_open_delivery_inl)
        if order['order_state'] == 'submited':
            await call.message.answer(f"<b>🎁 Активных заказов нет.</b>\n")

################################################################################################
######################################### ПОКУПКА ТОВАРА #######################################
########################################### КАТЕГОРИИ ##########################################
# Открытие категорий для покупки
@dp.callback_query_handler(text_startswith="buy_category_open:", state="*")
async def user_purchase_category_open(call: CallbackQuery, state: FSMContext):
    print('Открытие категорий для покупки user_menu.py 133')
    category_id = int(call.data.split(":")[1])
    city_id = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    source = "commercial"
    action = "open"
    get_category = get_categoryx(category_id=category_id)
    city_id = get_city_user(call.from_user.id)[0]
    get_positions = get_positions_in_cityx(category_id=category_id, position_city_id=city_id, flagallc=1, position_type=1)  # get_positionsx(category_id=category_id)
    #print(get_positions)
    print(category_id, city_id)
    if len(get_positions) >= 1:
        await call.message.edit_text(_("<b>🎁 Товары категории:</b>", locale=lang) + get_category['category_name'],
                                     reply_markup=products_item_position_swipe_fp(0, action, category_id, city_id, "commercial", lang))
    else:
        await call.answer(f"❕ Товары в категории {get_category['category_name']} отсутствуют")

######################################### ПОКУПКА ТОВАРА #######################################
########################################### КАТЕГОРИИ ##########################################
# Открытие категорий для покупки
@dp.callback_query_handler(text_startswith="buy_people_category_open:", state="*")
async def user_purchase_category_open(call: CallbackQuery, state: FSMContext):
    print('Открытие категорий для покупки user_menu.py 133')
    category_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    get_category = get_categoryx(category_id=category_id)
    city_id = get_city_user(call.from_user.id)[0]
    get_positions = get_positions_in_cityx(category_id=category_id, position_city_id=city_id, flagallc=1, position_type=1)  # get_positionsx(category_id=category_id)
    print(category_id, city_id)
    if len(get_positions) >= 1:
        source = "people"
        action = "open"
        await call.message.edit_text(_("<b>🎁 Товары категории:</b>", locale=lang) + get_category['category_name'],
                                     reply_markup=products_item_position_swipe_fp(0, action, category_id, city_id, source))
    else:
        await call.answer(f"❕ Товары в категории {get_category['category_name']} отсутствуют")

# Вернуться к категориям для покупки
@dp.callback_query_handler(text_startswith="buy_category_return", state="*")
async def user_purchase_category_return(call: CallbackQuery, state: FSMContext):
    get_categories = get_all_categoriesx()
    get_settings = get_settingsx()
    user_id = call.from_user.id
    lang = get_user_lang(user_id)['user_lang']

    city_id = 0
    if get_settings['type_trade'] != 'digital':
        city_id = get_city_user(call.from_user.id)[0]

    if len(get_categories) >= 1:
        await call.message.edit_text(_("<b>🎁 Товары категории:</b>", locale=lang) + get_category['category_name'],
                                     reply_markup=products_item_category_swipe_fp(0, city_id, lang))
    else:
        await call.message.edit_text(_("<b>🎁 Товары в данное время отсутствуют.</b>", locale=lang))
        await call.answer("❗ Категории были изменены или удалены")


############################################ МАГАЗИН => КАТЕГОРИИ #############################
########################################### МАГАЗИНЫ ##########################################
# Открытие магазина для покупки
@dp.callback_query_handler(text_startswith="buy_shop_open", state="*")
async def user_purchase_category_open(call: CallbackQuery, state: FSMContext):
    print('Открытие магазина для покупки user_menu.py 1902')
    shop_id = int(call.data.split(":")[1])
    city_id = int(call.data.split(":")[2])
    lang = call.data.split(":")[3]
    print(shop_id, city_id, lang)
    get_shop = get_shopsxx(shop_id=shop_id)
    print(get_shop)
    user_id = call.from_user.id
    #lang = get_userx(user_id=user_id)['user_lang']
    print(lang)
    #city_id = get_city_user(user_id)[0]
    get_positions = get_shopposition_on_city(shop_id, city_id)

    if len(get_positions) >= 1:
        if len(get_shop[0]['logo']) >= 5:
            logo = get_shop[0]['logo']
            print(logo)
            if lang == "ru":
                await call.message.answer_photo(logo, f"<b>Магазин : {get_shop[0]['name']}</b>\n" \
                                                      f"Адрес : {get_shop[0]['address']}\n" \
                                                      f"Телефон : {get_shop[0]['phone']}\n" \
                                                      f"О магазине : {get_shop[0]['description']}")
            if lang == "en":
                await call.message.answer_photo(logo, f"<b>Shop : {get_shop[0]['name']}</b>\n" \
                                                      f"Address : {get_shop[0]['address']}\n" \
                                                      f"Phone : {get_shop[0]['phone']}\n" \
                                                      f"About Shop : {get_shop[0]['description']}")
        elif get_shop[0]['logo'] is Null:
            print("+++")
            if lang == "ru":
                await call.message.answer(f"<b>Магазин : {get_shop[0]['name']}</b>\n" \
                                                      f"Адрес : {get_shop[0]['address']}\n" \
                                                      f"Телефон : {get_shop[0]['phone']}\n" \
                                                      f"О магазине : {get_shop[0]['description']}")
            if lang == "en":
                await call.message.answer(f"<b>Shop : {get_shop[0]['name']}</b>\n" \
                                                      f"Address : {get_shop[0]['address']}\n" \
                                                      f"Phone : {get_shop[0]['phone']}\n" \
                                                      f"About Shop : {get_shop[0]['description']}")

        #await call.message.answer_photo(logo, "<b>🎁 Выберите нужный вам товар:</b>",
        #                                    reply_markup=products_shopitem_position_swipe_fp(0, shop_id, city_id))
        #else:
        #media = types.MediaGroup()
        #media.attach_photo(types.InputFile('media/Starbucks_Logo.jpg'), 'Превосходная фотография')
        #media.attach_photo(types.InputFile('media/Starbucks_Logo_2.jpg'), 'Превосходная фотография 2')
        #await bot.send_media_group(call.message.chat.id, media=media)

        await call.message.answer(_("<b>🎁 Товары магазина:</b>", locale=lang) + get_shop[0]['name'],
                                  reply_markup=products_shopitem_position_swipe_fp(0, shop_id, city_id, lang))
    else:
        if lang == "ru":
            await call.answer(f"❕ Товары в магазине {get_shop[2]} отсутствуют")
        if lang == "en":
            await call.answer(f"❕ Products in shop <code>{get_shop[2]}</code> is not exist.")


# Открытие магазина для покупки
@dp.callback_query_handler(text_startswith="book_place_open", state="*")
async def user_purchase_category_open(call: CallbackQuery, state: FSMContext):
    print('Открытие магазина для покупки user_menu.py 133')
    place_id = int(call.data.split(":")[1])
    #get_shop = get_shopx(shop_id=shop_id)
    get_place = get_placesx(place_id=place_id)
    print(get_place)
    #if get_shop[8] != None: logo = get_shop[8]
    user_id = call.from_user.id
    city_id = get_city_user(user_id)[0]
    print("|||")
    print(city_id, get_place['place_id'])
    #print(remover, place_id, city_id)
    #get_events = get_events_in_place(place_id)  # get_positionsx(category_id=category_id)

    if get_place['place_id'] != "":
        print("|||->")
        logo = get_place['logo']
        await call.message.answer_photo(logo, f"<b>Место : {get_place['name']}</b>\n" \
                                              f"Адрес : {get_place['address']}\n" \
                                              f"Телефон : {get_place['phone']}")

        await call.message.answer("<b>Выберите что-нибудь интересное:</b>",
                                  reply_markup=events_in_place_swipe_fp(0, place_id, city_id))
    else:
        await call.answer(f"❕Cобытия места не загружены: {get_place['name']}, уточнить можно по телефону: {get_place['phone']}")


# Открытие магазина для покупки
@dp.callback_query_handler(text_startswith="book_event_open", state="*")
async def user_evebt_in_city_open(call: CallbackQuery, state: FSMContext):
    print('Открытие городских событий user_menu.py 1368')
    event_id = int(call.data.split(":")[1])
    get_event = get_eventxx(event_id=event_id)
    #city_id = int(call.data.split(":")[1])
    #get_shop = get_shopx(shop_id=shop_id)
    #get_events_in_city
    #get_shop = get_shopsxx(place_id=place_id)
    print(get_event)
    #if get_shop[8] != None: logo = get_shop[8]
    user_id = call.from_user.id
    #city_id = get_city_user(user_id)[0]
    get_positions = get_shopposition_on_city(shop_id, city_id)  # get_positionsx(category_id=category_id)

    if len(get_positions) >= 1:
        #if get_shop['logo'] != None:
        logo = get_shop[0]['logo']
        await call.message.answer_photo(logo, f"<b>Магазин : {get_shop[0]['name']}</b>\n" \
                                              f"Адрес : {get_shop[0]['address']}\n" \
                                              f"Телефон : {get_shop[0]['phone']}\n" \
                                              f"О магазине : {get_shop[0]['description']}")
        #await call.message.answer_photo(logo, "<b>🎁 Выберите нужный вам товар:</b>",
        #                                    reply_markup=products_shopitem_position_swipe_fp(0, shop_id, city_id))
        #else:
        #media = types.MediaGroup()
        #media.attach_photo(types.InputFile('media/Starbucks_Logo.jpg'), 'Превосходная фотография')
        #media.attach_photo(types.InputFile('media/Starbucks_Logo_2.jpg'), 'Превосходная фотография 2')
        #await bot.send_media_group(call.message.chat.id, media=media)

        await call.message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                  reply_markup=products_shopitem_position_swipe_fp(0, shop_id, city_id, lang))
    else:
        await call.answer(f"❕ Товары в магазине {get_shop[2]} отсутствуют")

########################################### ПОЗИЦИИ ##########################################
# Открытие позиции для покупки
@dp.callback_query_handler(text_startswith="book_event_open2:", state="*")
async def user_purchase_position_open(call: CallbackQuery, state: FSMContext):
    print('Карточка товара: user_menu.py  1194')
    event_id = int(call.data.split(":")[1])
    #link = await get_start_link(str(f"deep_link&event_id&{event_id}"), encode=True)

    print(event_id)
    get_event = get_eventx(event_id=event_id)
    #if category_id != 0: get_category = get_categoryx(category_id=category_id)
    #else: get_category['category_name'] = 0
    #get_items = get_itemsx(position_id=position_id)
    get_settings = get_settingsx()
    #get_shop = get_shopx(shop_id=shop_id)
    print("|")

    if get_event['event_description'] == "0":
        text_description = ""
    else:
        text_description = f"\n📜 Описание:\n" \
                           f"{get_event['event_description']}"
    #get_shop['name']
    send_msg = f"<b>Карточка:</b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"🏷 Название: <code>{get_position['position_name']}</code>\n" \
               f"🏙 Магазин: <code>{get_shop['name']}</code>\n" \
               f"🏙 Город: <code>{get_position['position_city']}</code>\n" \
               f"🗃 Категория: <code></code>\n" \
               f"💰 Стоимость: <code>{get_position['position_price']}₽</code>\n" \
               f"{text_description}"

    print(get_settings['type_trade'])
    tt = get_settings['type_trade']
    print("||")

    if tt != "digital":
        print("|||-")
        if len(get_position['position_photo']) >= 5:
            await call.message.delete()
            await call.message.answer_photo(get_position['position_photo'],
                                            send_msg, reply_markup=products_open_finl(1, position_id, remover, 0, shop_id))
        else:
            await call.message.edit_text(send_msg,
                                         reply_markup=products_open_finl(1, position_id, remover, 0, shop_id))
    else:
        print("|||--")
        if len(get_position['position_photo']) >= 5:
            await call.message.delete()
            await call.message.answer_photo(get_position['position_photo'],
                                            send_msg, reply_markup=products_open_finl(0, position_id, remover, 0, shop_id))
        else:
            await call.message.edit_text(send_msg,
                                         reply_markup=products_open_finl(0, position_id, remover, 0, shop_id))

# Вернуться к категориям для покупки
@dp.callback_query_handler(text_startswith="buy_parcategory_return", state="*")
async def user_purchase_category_return(call: CallbackQuery, state: FSMContext):
    get_categories = get_all_categoriesx()
    get_settings = get_settingsx()
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang)
    city_id = 0
    if get_settings['type_trade'] != 'digital':
        city_id = get_city_user(call.from_user.id)[0]

    if len(get_categories) >= 1:
        await call.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                     reply_markup=products_item_shop_open_fp(0, shop_id, city_id, lang))
    else:
        await call.message.edit_text(_("<b>🎁 Товары в данное время отсутствуют.</b>", locale=lang))
        await call.answer("❗ Категории были изменены или удалены")

########################################### ПОЗИЦИИ ##########################################
# Открытие позиции для покупки
@dp.callback_query_handler(text_startswith="buy_parposition_open:", state="*")
async def user_purchase_position_open(call: CallbackQuery, state: FSMContext):
    print('Карточка товара: user_menu.py  um2082')
    if call.data.split(":")[4]: city_id = 0
    position_id = int(call.data.split(":")[1])
    #category_id = int(call.data.split(":")[2])
    shop_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    city_id = int(call.data.split(":")[4])
    lang = call.data.split(":")[5]
    print(lang)
    print(position_id, shop_id, remover, city_id, lang)
    link = await get_start_link(str(f"deep_link&position_id&{position_id}"), encode=True)
    get_position = get_positionx(position_id=position_id)
    #get_items = get_itemsx(position_id=position_id)
    get_settings = get_settingsx()
    #get_shop = get_shopx(shop_id=shop_id)
    print("|")

    if lang == "ru":
        description = "📜 Описание:"
        cardtitle = "<b>Карточка:</b>"
        cardname = "🏷 Название:"
        cardlink = "🏷 Ссылка:"
        cardshop = "🏙 Магазин:"
        cardcity = "🏙 Город:"
        cardcategory = "🗃 Категория:"
        cardcost = "💰 Стоимость:"

    if lang == "en":
        description = "📜 Description:"
        cardtitle = "<b>Product Card:</b>"
        cardname = "🏷 Name:"
        cardlink = "🏷 Link:"
        cardshop = "🏙 Shop:"
        cardcity = "🏙 City:"
        cardcategory = "🗃 Category:"
        cardcost = "💰 Price:"

    '''if get_position['position_description'] == "0":
        text_description = ""
    else:
        text_description = f"\n{description}\n" \
                           f"{get_position['position_description']}"'''

    send_msg = f"{cardtitle}\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"{cardname} <code>{get_position['position_name']}</code>\n" \
               f"{cardlink} <code>{link}</code>\n" \
               f"{cardcity} <code>{get_position['position_city']}</code>\n" \
               f"{cardcost} <code>{get_position['position_price']}₽</code>\n"

    #f"{cardshop} <code>{get_shop['name']}</code>\n"
    #f"{cardcategory} <code>{category}</code>\n" \
    print(get_settings['type_trade'])
    tt = get_settings['type_trade']
    print("||")

    if tt != "digital":
        print("|||-")
        #    product_markup = products_open_finl(position_id, remover, category_id)
        # product_markup = products_open_cart_finl(position_id, remover, category_id)
        if len(get_position['position_photo']) >= 5:
            await call.message.delete()
            await call.message.answer_photo(get_position['position_photo'],
                                            send_msg, reply_markup=products_open_finl(1, position_id, remover, 0, shop_id, lang))
        else:
            await call.message.edit_text(send_msg,
                                         reply_markup=products_open_finl(1, position_id, remover, 0, shop_id, lang))
    else:
        print("|||--")
        if len(get_position['position_photo']) >= 5:
            await call.message.delete()
            await call.message.answer_photo(get_position['position_photo'],
                                            send_msg, reply_markup=products_open_finl(0, position_id, remover, 0, shop_id, lang))
        else:
            await call.message.edit_text(send_msg,
                                         reply_markup=products_open_finl(0, position_id, remover, 0, shop_id, lang))

# Вернуться к позициям для покупки
@dp.callback_query_handler(text_startswith="buy_parposition_return", state="*")
async def user_purchase_position_return(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    shop_id = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])

    print("buy_parposition_return")
    user_id = message.from_user.id
    lang = get_user_lang(user_id)['user_lang']
    print(lang)

    get_positions = get_all_positionsx()
    city_id = get_city_user(call.from_user.id)[0]

    if len(get_positions) >= 1:
        await call.message.delete()
        await call.message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                  reply_markup=products_shopitem_position_open_fp(remover, shop_id, city_id, lang))
    else:
        await call.message.edit_text(_("<b>🎁 Товары в данное время отсутствуют.</b>", locale=lang))
        await call.answer("❗ Позиции были изменены или удалены")

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="buy_parcategory_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])

    await call.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                 reply_markup=products_item_category_swipe_fp(remover))

# Переключение страницы позиций для покупки
@dp.callback_query_handler(text_startswith="buy_parposition_swipe:", state="*")
async def user_purchase_position_next_page(call: CallbackQuery, state: FSMContext):
    shop_id = call.data.split(":")[1]
    remover = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    get_shop = get_shopx(shop_id=shop_id)

    await call.message.edit_text(f"<b>🎁 Текущий магазин: <code>{get_shop['name']}</code></b>",
                                 reply_markup=products_shopitem_position_swipe_fp(remover, shop_id, city_id, lang))

# Переключение страницы позиций для покупки
@dp.callback_query_handler(text_startswith="buy_position_swipe:", state="*")
async def user_purchase_position_next_page(call: CallbackQuery, state: FSMContext):
    category_id = call.data.split(":")[1]
    remover = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    source = "commercial"
    action = "open"

    get_category = get_categoryx(category_id=category_id)

    await call.message.edit_text(_("<b>🎁 Текущая категория:</b>", locale=lang) + get_category['category_name'],
                                 reply_markup=products_item_position_swipe_fp(remover, action, category_id, city_id, source, lang))

# Открытие позиции для покупки
@dp.callback_query_handler(text_startswith="buy_position_open:", state="*")
async def user_purchase_position_open(call: CallbackQuery, state: FSMContext):
    print('Карточка товара: user_menu.py  152')
    position_id = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    remover = int(call.data.split(":")[3])
    city_id = int(call.data.split(":")[4])
    lang = call.data.split(":")[5]

    get_items = get_itemsx(position_id=position_id)

    if lang == "ru":
        description = "📜 Описание:"
        cardtitle = "<b>Карточка:</b>"
        cardname = "🏷 Название:"
        cardlink = "🏷 Ссылка:"
        cardrest = "🏷 Остаток:"
        cardcity = "🏙 Город:"
        cardcategory = "🗃 Категория:"
        cardcost = "💰 Стоимость:"
    if lang == "en":
        description = "📜 Description:"
        cardtitle = "<b>Product Card:</b>"
        cardname = "🏷 Name:"
        cardlink = "🏷 Link:"
        cardrest = "🏷 Rest:"
        cardcity = "🏙 City:"
        cardcategory = "🗃 Category:"
        cardcost = "💰 Price:"

    print(position_id, category_id, remover, city_id, lang)
    get_category = ""
    category = ""
    link = await get_start_link(str(f"deep_link&position_id&{position_id}"), encode=True)

    get_position = get_positionx(position_id=position_id)
    position_source = get_position['source']
    if position_source == "commercial":
        get_category = get_categoryx(category_id=category_id)
        category = get_category['category_name']
    elif position_source == "people":
        get_category = get_category_people(category_id=category_id)
        category = get_category['category']

    if get_position['position_type'] == 1:
        position_rest = get_position['position_rest']
    elif get_position['position_type'] == 1:
        position_rest = len(get_items)

    get_settings = get_settingsx()

    if get_position['position_description'] == "0":
        text_description = ""
    else:
        text_description = f"\n{description}\n" \
                           f"{get_position['position_description']}"

    send_msg = f"{cardtitle}\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"{cardname} <code>{get_position['position_name']}</code>\n" \
               f"{cardlink} <code>{link}</code>\n" \
               f"{cardcity} <code>{get_position['position_city']}</code>\n" \
               f"{cardcategory} <code>{category}</code>\n" \
               f"{cardrest} <code>{get_position['position_rest']}шт</code>\n" \
               f"{cardcost} <code>{get_position['position_price']}₽</code>\n" \
               f"{text_description}"

    print(get_settings['type_trade'])
    tt = get_settings['type_trade']

    if tt == "digital":
        if len(get_position['position_photo']) >= 5:
            await call.message.delete()
            await call.message.answer_photo(get_position['position_photo'],
                                            send_msg, reply_markup=products_open_finl(0, position_id, remover, category_id, 0, lang))
        else:
            await call.message.edit_text(send_msg,
                                         reply_markup=products_open_finl(0, position_id, remover, category_id, 0, lang))

    elif len(get_position['position_photo']) > 5:
        #print(get_position['position_photo'])
        await call.message.delete()
        await call.message.answer_photo(get_position['position_photo'],
                                        send_msg, reply_markup=products_open_finl(1, position_id, remover, category_id, 0, lang))

    elif len(get_position['position_photo']) < 6:
        print("0O0O0")
        #if path is None:
            #rd = Path(__file__).parents
            #base_dir = rd[1]
            #path = str(f"{base_dir}{os.sep}images")
        #photop = f"./../images/{get_position['position_photo']}.jpg"
        #print(photop)
        #photo = open(photop, 'rb')

        #await call.message.answer_photo(photo,
        #                            send_msg, reply_markup=products_open_finl(1, position_id, remover, category_id, 0, lang))
        await call.message.edit_text(send_msg,
                                     reply_markup=products_open_finl(1, position_id, remover, category_id, 0, lang))
    else:
        await call.message.edit_text(send_msg,
                                     reply_markup=products_open_finl(1, position_id, remover, category_id, 0, lang))

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="artist_edit_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    user_id = int(call.data.split(":")[2])

    await call.message.edit_text(_("<b>🎁 Выберите нужного артиста:</b>", locale=lang),
                                 reply_markup=artist_edit_open_fp(remover, user_id))

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="buy_people_category_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    category_id = int(call.data.split(":")[1])
    remover = int(call.data.split(":")[2])
    level = int(call.data.split(":")[3])
    parent = int(call.data.split(":")[4])
    city_id = int(call.data.split(":")[5])
    action = call.data.split(":")[6]
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    print(lang, city_id)

    await call.message.edit_text(_("<b>🌐 Выберите категорию:</b>", locale=lang),
                                 reply_markup=position_people_create_open_fp(category_id, remover, level, parent, city_id, action, lang))

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="buy_category_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    #level = int(call.data.split(":")[2])
    parent_id = int(call.data.split(":")[2])
    city_id = int(call.data.split(":")[3])
    action = call.data.split(":")[4]
    #level = int(call.data.split(":")[5])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']
    #await call.message.edit_text
    #await call.message.delete()

    await call.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                 reply_markup=products_item_category_swipe_fp(remover, parent_id, city_id, action, lang))

# Переключение страниц категорий для покупки
@dp.callback_query_handler(text_startswith="buy_shop_swipe:", state="*")
async def user_purchase_category_next_page(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    city_id = int(call.data.split(":")[2])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    await call.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                 reply_markup=products_item_shop_swipe_fp(remover, city_id, lang))

# Вернуться к позициям для покупки
@dp.callback_query_handler(text_startswith="buy_position_return", state="*")
async def user_purchase_position_return(call: CallbackQuery, state: FSMContext):
    remover = int(call.data.split(":")[1])
    category_id = int(call.data.split(":")[2])
    shop_id = int(call.data.split(":")[3])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']

    #get_positions = get_all_positionsx()
    city_id = get_city_user(call.from_user.id)[0]
    print(remover, category_id, shop_id, city_id)
    print("buy_position_return")
    source = "commercial"
    #user_id = call.from_user.id
    #lang = get_user_lang(user_id)['user_lang']
    action = "open"

    #if len(get_positions) >= 1:
    await call.message.delete()
    if shop_id == 0:
        print("||||--=")
        await call.message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                  reply_markup=products_item_position_swipe_fp(remover, action, category_id, city_id, source, lang))
    elif category_id == 0:
        print("||||--==---")
        await call.message.answer(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                  reply_markup=products_shopitem_position_swipe_fp(remover, shop_id, city_id, source, lang))
    #else:
    #    await call.message.edit_text("<b>🎁 Товары в данное время отсутствуют.</b>")
    #    await call.answer("❗ Позиции были изменены или удалены")


########################################### ПОКУПКА ##########################################
# Выбор количества товаров в корзине
@dp.callback_query_handler(text_startswith="add_item_cart", state="*")
async def user_purchase_addcart(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])
    print("Добавление в корзину")
    get_position = get_positionx(position_id=position_id)
    print(get_position)
    get_user = get_userx(user_id=get_position['position_user_id'])
    get_payments = get_upaymentx(get_position['position_user_id'])
    user_id = call.from_user.id
    lang = get_userx(user_id=user_id)['user_lang']


    if get_position['position_type'] == 1:
        get_count = get_position['position_rest']
    elif get_position['position_type'] == 2:
        get_items = get_itemsx(position_id=position_id)
        get_count = len(get_items)

    await state.update_data(here_cache_position_type = get_position['position_type'])
    await state.update_data(here_cache_get_count = get_count)



    if get_payments['way_freecredi'] == 'True':
        await state.update_data(here_cache_skipchkbalance = 1)

    source = get_position['source']

    if get_count == 1:
        await state.update_data(here_cache_position_id=position_id)
        await state.finish()

        await call.message.delete()
        if lang == "ru":
            await call.message.answer(f"<b>1 шт. в наличии. Добавить товар(ы) в корзину?</b>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                      f"📦 Остаток: <code>1шт</code>\n"
                                      f"💰 Сумма к покупке: <code>{get_position['position_price']}₽</code>",
                                      reply_markup=products_addcart_confirm_finl(position_id, 1, lang))
        if lang == "en":
            await call.message.answer(f"<b>1 pcs. in stock. Add goods to cart?</b>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Goods: <code>{get_position['position_name']}</code>\n"
                                      f"📦 Rest: <code>1шт</code>\n"
                                      f"💰 Amount to order: <code>{get_position['position_price']}R</code>",
                                      reply_markup=products_addcart_confirm_finl(position_id, 1, lang))
    elif get_count >= 1:
        await state.update_data(here_cache_position_id=position_id)
        await state.set_state("here_itemsadd_cart")

        await call.message.delete()
        if lang == "ru":
            await call.message.answer(f"<b>🎁 Введите количество товаров для покупки</b>\n"
                                      f"▶ От <code>1</code> до <code>{get_count}</code>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n"
                                      f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>")
        if lang == "en":
            await call.message.answer(f"<b>🎁 Enter quantity of goods to order</b>\n"
                                      f"▶ From <code>1</code> till <code>{get_count}</code>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Good: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n"
                                      f"💰 Your balance: <code>{get_user['user_balance']}R</code>")
    else:
        if lang == "ru":
            await call.answer("🎁 Товара нет в наличии")
        if lang == "en":
            await call.answer("🎁 Sorry. Product not in stock.")


# Принятие количества товаров в корзине
@dp.message_handler(state="here_itemsadd_cart")
async def user_purchase_select_count(message: Message, state: FSMContext):
    position_id = (await state.get_data())['here_cache_position_id']
    get_position = get_positionx(position_id=position_id)
    #user_id=message.from_user.id
    #данные пользователя
    get_user = get_userx(user_id=get_position['position_user_id'])
    #данные платежных систем
    get_payments = get_upaymentx(get_position['position_user_id'])
    print(get_payments)
    #данные пользователя
    get_user = get_userx(user_id=message.from_user.id)
    lang = get_userx(user_id=message.from_user.id)['user_lang']

    skipchkbalance = 1 if get_payments['way_freecredi'] == 'True' else 0
    get_count = (await state.get_data())['here_cache_get_count']
    position_type = (await state.get_data())['here_cache_position_type']

    if position_type == 1:
        get_items = get_position['position_rest']
        get_count = get_position['position_rest']
        if get_position['position_price'] != 0 and skipchkbalance != 1:
            get_count_balance = int(get_user['user_balance'] / get_position['position_price'])

    elif position_type == 2:
        get_items = get_itemsx(position_id=position_id)
        get_count = len(get_items)
        get_count = min(get_count, len(get_items))

    if lang == "ru":
        send_message = f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                       f"🎁 Введите количество товаров для покупки\n" \
                       f"▶ От <code>1</code> до <code>{get_count}</code>\n" \
                       f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                       f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n" \
                       f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>"
    if lang == "en":
        send_message = f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                       f"🎁 Enter quantity of good to order\n" \
                       f"▶ From <code>1</code> till <code>{get_count}</code>\n" \
                       f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                       f"🎁 Goods: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n" \
                       f"💰 Your balance: <code>{get_user['user_balance']}R</code>"

    if message.text:
        get_buy = int(message.text)
        amount_pay = int(get_position['position_price']) * get_buy
        print(get_count)

        if position_type == 1 and get_count >= 1:
            await state.finish()
            if lang == "ru":
                await message.answer(f"<b>🎁 Вы действительно хотите добавить в корзину товар(ы)?</b>\n"
                                     f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                     f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                     f"📦 Остаток: <code>{get_count}шт</code>\n"
                                     f"💰 Сумма добавляемых товаров: <code>{amount_pay}₽</code>",
                                     reply_markup=products_addcart_confirm_finl(position_id, get_buy, lang))
            if lang == "en":
                await message.answer(f"<b>🎁 Do you wannna add goods to order?</b>\n"
                                     f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                     f"🎁 Good: <code>{get_position['position_name']}</code>\n"
                                     f"📦 Rest: <code>{get_count}pcs</code>\n"
                                     f"💰 Amount to add: <code>{amount_pay}R</code>",
                                     reply_markup=products_addcart_confirm_finl(position_id, get_buy, lang))
        else:
            await state.finish()
            await message.answer(_("<b>🎁 Товар который вы хотели купить, закончился</b>", locale=lang))
    else:
        await message.answer(_("<b>❌ Данные были введены неверно.</b>", locale=lang))


# Подтверждение добавления товара в корзину
@dp.callback_query_handler(text_startswith="xaddcart_item", state="*")
async def user_addcart_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    get_buy = int(call.data.split(":")[3])
    lang = call.data.split(":")[4]
    get_position = get_positionx(position_id=position_id)
    if get_action == "yes":
        await call.message.edit_text(_("<b>🔄 Ждите, товары подготавливаются</b>", locale=lang))

        get_position = get_positionx(position_id=position_id)

        position_type = get_position['position_type']

        if position_type == 1:
            get_count = get_position['position_rest']
            get_items = get_count
        elif position_type == 2:
            get_items = get_itemsx(position_id=position_id)
            get_count = len(get_items)

        get_user = get_userx(user_id=call.from_user.id)

        amount_pay = int(get_position['position_price'] * get_buy)

        if position_type == 1:
            await notify(dp, f"Позиция: {get_position['position_name']} добавлена в корзину пользователем: {call.from_user.id}.")

            send_count = get_buy
            # уточнение цены за количество в наличии
            if get_buy != send_count:
                amount_pay = int(get_position['position_price'] * send_buy)

            receipt = get_unix()
            add_time = get_date()
            print(add_time)

            await call.message.delete()

            await asyncio.sleep(0.3)

            users_order = get_params_orderx(user_id=get_user['user_id'], order_state='created')
            print(users_order)
            alength = len(users_order)
            i = 0
            for i in range(alength):
                print(users_order[i]['order_id'])

            print('test2')

            if not users_order:
                create_orderx(call.from_user.id, get_user['user_login'], get_user['user_name'], 'created', str(add_time), receipt)
                users_order = get_params_orderx(user_id=get_user['user_id'], order_state='created')

            print('test3')
            for i in range(alength):
                print(users_order[i]['order_id'])
            order_id = users_order[i]['order_id']

            add_order_itemx(call.from_user.id, order_id, position_id, get_buy, get_position['position_price'], receipt, get_position['position_user_id'])
            new_position_rest = int(get_position['position_rest']) - get_buy
            update_positionx(get_position['position_id'], position_rest=new_position_rest)

            auser = (
                get_user['user_login']
                if len(get_user['user_login']) >= 1
                else get_user['user_id']
            )
            await notify(dp, f"Позиция: {get_position['position_name']} добавлена в корзину. Пользователь: @{auser}.")

            if lang == "ru":
                await call.message.answer(f"<b>✅ Вы успешно добавили товар(ы) в корзину</b>\n"
                                          f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                          f"🧾 Чек: <code>#{receipt}</code>\n"
                                          f"🎁 Товар: <code>{get_position['position_name']} | {get_count}шт | {amount_pay}₽</code>\n"
                                          f"🕰 Дата покупки: <code>{add_time}</code>",
                                          reply_markup=menu_frep(call.from_user.id, lang))
            if lang == "en":
                await call.message.answer(f"<b>✅ Goods has been added to cart successfully</b>\n"
                                          f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                          f"🧾 Receipt: <code>#{receipt}</code>\n"
                                          f"🎁 Good: <code>{get_position['position_name']} | {get_count}pcs | {amount_pay}R</code>\n"
                                          f"🕰 Date: <code>{add_time}</code>",
                                          reply_markup=menu_frep(call.from_user.id, lang))
        elif position_type == 2:
            if 1 <= get_buy <= len(get_items):
                save_items, send_count, split_len = buy_itemx(get_items, get_buy)
                await notify(dp, f"Позиция: {get_position['position_name']} добавлена в корзину пользователем: {call.from_user.id}.")
            await call.message.answer(_("<b>🎁 Товар который вы хотели купить закончился или изменился.</b>", locale=lang),
                                      reply_markup=menu_frep(call.from_user.id, lang))
        else:
            await call.message.answer(_("<b>🎁 Товар который вы хотели купить закончился или изменился.</b>", locale=lang),
                                      reply_markup=menu_frep(call.from_user.id, lang))
    elif len(get_all_categoriesx()) >= 1:
        await call.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                     reply_markup=category_edit_open_fp(0, lang))
    else:
        await call.message.edit_text(_("<b>✅ Вы отменили покупку товаров.</b>", locale=lang))


# Удаление корзины
@dp.callback_query_handler(text_startswith="del_user_cart", state="*")
async def del_user_cart(call: CallbackQuery, state: FSMContext):
    order_id = int(call.data.split(":")[1])
    print("||||")
    await state.finish()
    await call.message.edit_text(_("<b> Удалить корзину и ее позиции?</b>", locale=lang),
                                 reply_markup=confirm_delete_user_cart_inl(order_id))

# Подтверждение удаления корзины
@dp.callback_query_handler(text_startswith="confirm_del_user_cart", state="*")
async def confirm_del_user_cart(call: CallbackQuery, state: FSMContext):
    order_id = int(call.data.split(":")[1])
    print(order_id)
    user_id=call.from_user.id
    print(user_id)
    order_id=order['order_id']
    #возврат количества в товаров в позиции
    orderdata = get_orderxo(order_id=order_id)
    print(orderdata)
    ouser_id = orderdata['user_id']
    oget_user = get_userx(user_id=ouser_id)
    user_role = oget_user['user_role']
    print(user_role)
    #получаем баланс пользователя
    ub = oget_user['user_balance']
    #username
    if oget_user['user_login']:
        userid = f"Логин пользователя: <code>@{oget_user['user_login']}</code>"
    else: userid = f"Телеграм ID: <code>{oget_user['user_id']}</code>"
    #позиции заказа
    get_positions = []
    get_positions = get_cart_positionsx(order_id=order_id)

    this_items = []
    this_itemst = this_itemst2 = this_itemst3 = ''
    for position in get_positions:
        current_position = get_positionx(position_id=position['position_id'])
        new_position_rest = current_position['position_rest'] + position['count']
        update_positionx(position['position_id'], position_rest=new_position_rest)

    remove_ordersx(order_id=order_id)
    remove_orders_itemx(order_id=order_id)

    print("|||| -   - ||||")
    await call.message.edit_text(f"<b>✅ Вы удалили корзину #{order_id}.</b>")


#######################################################################################
# **************************  CHECK OUT CART ******************************************
#######################################################################################

# Оформление заказа по корзине - Адрес
@dp.callback_query_handler(text_startswith="checkout_start", state="*")
async def checkout_start(call: CallbackQuery, state: FSMContext):
    order_id = int(call.data.split(":")[1])
    print(order_id)
    user_id = call.from_user.id
    get_user = get_userx(user_id=user_id)
    ub = get_user['user_balance']
    order_sum = calc_order_summ(order_id=order_id)
    dso = get_delivery_seller_options(order_id)['free_delivery_point']
    print(dso)
    delivery_rate = get_delivery_seller_options(order_id)['delivery_rate']
    print(delivery_rate)
    delivery = 0 if order_sum > dso else delivery_rate
    print(f"Доставка:{str(delivery)}")
    print("|||->")
    order_total = order_sum + delivery
    adr = geo = phone = 0
    touser_id = get_cart_sellersx(order_id)
    get_payment = get_upaymentx(user_id=touser_id) #True / False - постоплата
    freecredi_method = 1 if get_payment['way_freecredi'] else 0
    print(user_id)

    if get_user['user_address'] != "":
        print("Адрес есть")
        adr = 1
    if get_user['user_geocode'] != "":
        print("Геокод есть")
        geo = 1
    if get_user['user_phone'] != "":
        print("Телефон есть")
        phone = 1

    await call.message.answer(f"<b> Начинаем оформление заказа.</b>\n")

    if phone == 0:
        await state.set_state("enter_phone_auto")

    if adr == 0:
        await state.set_state("enter_address_manualy")

    if ub < order_total and freecredi_method == 0:
        await state.set_state("user_balance_lower_than_cart")
        await call.message.delete()
        await call.message.answer(f"<b>Суммы на Вашем балансе не достаточно для оформления заказа.</b>\n"
                                  f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                  f" Баланс: <code>{ub}</code>\n"
                                  f" Сумма заказа: <code>{order_total}</code>\n",
                                  reply_markup=order_user_refill)
    else:
        await state.set_state("checkout_finish")
        await call.message.answer(f"<b>Продолхить оформление заказа:.</b>\n",
                                  reply_markup=checkout_step2_accept_finl(order_id))


# Принятие адреса для доставки
@dp.callback_query_handler(text_startswith="checkout_finish:", state="*")
async def checkout_finish(call: CallbackQuery, state: FSMContext):
    order_id = int(call.data.split(":")[1])
    print('checkout_finish')
    print(order_id)
    #проверка - есть вопросы без ответов
    touser_id = call.from_user.id
    if cm := get_user_messagesx(to_uid=touser_id, state='created'):
        print(f"Messages present:{str(touser_id)}")
    #статус заказа - delivery
    print("|||->")
    print("||||->>>>")
    print(order_id)
    os = update_orderx(order_id=order_id, order_state='delivery')
    await call.message.answer("<b>Начинаем доставку товара Вашей корзины.</b>")

    print('Сумма заказа на холде')
    order_sum = calc_order_summ(order_id=order_id)
    dso = get_delivery_seller_options(order_id)['free_delivery_point']
    print(dso)
    delivery_rate = get_delivery_seller_options(order_id)['delivery_rate']
    print(delivery_rate)

    delivery = 0 if order_sum > dso else delivery_rate
    print(f"Доставка:{str(delivery)}")
    print("||||-")
    amount = order_sum + delivery
    await notify(dp, f"Оформлен заказ: {order_id},\n"
                     f"пользователя: {touser_id}\n"
                     f"на сумму: {order_sum}\n"
                     f"с доставкой: {delivery}")

    buyer = touser_id
    print("||||--")
    order_sellers = get_order_sellers(order_id)
    print(order_sellers)
    if(len(order_sellers)>1): print("продавцов более 1")

    print(type(order_sellers))
    order_sellers = order_sellers.strip('[[')
    order_sellers = order_sellers.strip(']]')

    get_payment = get_upaymentx(user_id=order_sellers) #True / False - постоплата
    freecredi_method = 1 if get_payment['way_freecredi'] else 0
    if freecredi_method == 0:
        state = 'created'
        validity = 5
        h = create_holdx(
            order_id,
            int(buyer),
            int(str(order_sellers)),
            int(amount),
            validity,
            state,
        )
        i = update_userx(user_id = buyer, user_hold = amount)
        await call.message.answer(f"<b>Денежные средства в размере {amount}р. успешно заблокированы до \n"
                                  f"подтверждения получения покупателем товара.</b>")
    elif freecredi_method == 1:
        await call.message.answer(
            "<b>Заказ начал выполняться. Подтвердите получение товара по факту.</b>"
        )

# Оформление заказа по корзине - Адрес
@dp.callback_query_handler(text_startswith="pay_after_delivery", state="*")
async def pay_after_delivery(call: CallbackQuery, state: FSMContext):
    order_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    print(order_id)
    order_sellers = get_order_sellers(order_id)
    print(order_sellers)
    if(len(order_sellers)>1): print("продавцов более 1")
    print(type(order_sellers))
    order_sellers = order_sellers.strip('[[')
    order_sellers = order_sellers.strip(']]')
    print(order_sellers)
    get_payment = get_upaymentx(user_id=order_sellers) #True / False - постоплата
    if get_payment['way_freecredi']:
        freecredi_method = 1
        os = update_orderx(order_id=order_id, payafterdelivery=1)
        await call.message.answer(f"<b>Постоплата применена к заказу успешно!</b>\n")
    else:
        freecredi_method = 0
        await call.message.answer(f"<b>Постоплата не поддерживается продавцом по Вашему заказу!</b>\n")


# Оформление заказа по корзине - Адрес
@dp.callback_query_handler(text_startswith="submit_order", state="*")
async def submit_order(call: CallbackQuery, state: FSMContext):
    order_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    buyer_data = get_userx(user_id=user_id)
    print(buyer_data)
    #order_data = get_orderx(user_id=user_id)
    #order_id = order_data['order_id']

    order_sum = calc_order_summ(order_id=order_id)
    dso = get_delivery_seller_options(order_id)['free_delivery_point']
    print(dso)
    #free_delivery_point = dso['free_delivery_point']
    #print(free_delivery_point)
    delivery_rate = get_delivery_seller_options(order_id)['delivery_rate']
    print(delivery_rate)
    #delivery = 200
    delivery = 0 if order_sum > dso else delivery_rate
    print(f"Доставка:{str(delivery)}")
    print("||||-")
    amount = order_sum + delivery

    print(order_id)
    order_sellers = get_order_sellers(order_id)

    print(order_sellers)
    if(len(order_sellers)>1): print("продавцов более 1")
    #for seller in order_sellers:
    print(type(order_sellers))
    order_sellers = order_sellers.strip('[[')
    order_sellers = order_sellers.strip(']]')
    print(int(order_sellers))
    get_payment = get_upaymentx(user_id=int(order_sellers)) #True / False - постоплата
    print(get_payment)
    seller_data = ""
    if get_payment['way_freecredi']:
        freecredi_method = 1
        #транзакция с холдом
        seller_rest = int(seller_data['user_balance'])+int(amount)
    else:
        freecredi_method = 0
        hold_data = get_orders_holdsx(order_id)
        #hold_data = hold_data.strip('[')
        #hold_data = hold_data.strip(']')
        print(hold_data)
        #print(hold_data[0]['seller'])
        #seller
        seller_data = get_userx(user_id=hold_data[0]['seller'])
        print(seller_data)
        #hold_data['seller']
        #изменение статуса заказа   submitted
        #снятие холда с суммы заказа
        a = update_holdx(order_id = order_id, state = 'released')
        #транзакция с холдом
        seller_rest = int(seller_data['user_balance'])+int(hold_data[0]['amount'])
        buyer_rest = int(buyer_data['user_balance'])-int(hold_data[0]['amount'])
        #списание у покупателя
        b = update_userx(user_id, user_balance=buyer_rest)
    #buyer_rest = int(buyer_data['user_balance'])-int(hold_data[0]['amount'])
    #списание у покупателя
    #b = update_userx(user_id, user_balance=buyer_rest)
    #пополнение у продавца
    c = update_userx(order_sellers, user_balance=seller_rest)
    os = update_orderx(order_id=order_id, order_state='submitted', active=0)
    await call.message.answer(f"<b>Покупка завершена, возвращайтесь!</b>\n")

@dp.callback_query_handler(text="reply_toorder_message", state="*")
async def reply_toorder_message(call: CallbackQuery, state: FSMContext):
    print('reply_toorder_message')
    # order_id = int(call.data.split(":")[1])
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    print(user_id)
    get_user = get_userx(user_id=user_id)

    # get_user = get_userx(user_id=call.from_user.id)
    await state.set_state("reply_toorder_message_fin")

    # await call.message.delete()
    await call.message.answer(f"<b>Пожалуйста, введите сообщение для покупателя:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")

# Принятие адреса для доставки
@dp.message_handler(state="reply_toorder_message_fin")
async def reply_toorder_message_fin(message: Message, state: FSMContext):
    print('reply_toorder_message_fin')
    user_id = message.from_user.id
    get_user = get_userx(user_id=user_id)
    users_order = get_user_orderx(user_id)
    order_id = users_order['order_id']
    await state.finish()

    if message.text:
        messagetxt = str(message.text)
        print(str(user_id) + messagetxt)
        touser_id = get_cart_sellersx(order_id)
        print(touser_id)

        add_messagex(from_id=user_id, to_id=touser_id, order_id = order_id, txtmessage=messagetxt, photo='', state='responded')

    await message.delete()
    await message.answer(f"<b>✅ Было отправлено следующее сообщение покупателю:</b>\n"
                         + messagetxt, reply_markup=cart_enter_message_finl(user_id))

    cm = get_user_messagesx(to_uid=touser_id, state='responded')
    if len(cm) > 0:
        print(f"Messages present:{str(touser_id)}")

    await dp.bot.send_message(
        chat_id=touser_id,
        text=f"Сообщение/вопрос по заказу от продавца:{messagetxt}",
        reply_markup=reply_order_message_finl(order_id),
    )

@dp.callback_query_handler(text="enter_message_manualy", state="*")
async def enter_message_manualy(call: CallbackQuery, state: FSMContext):
    print('enter_message_manualy')
    user_id = call.from_user.id
    print(user_id)
    get_user = get_userx(user_id=user_id)

    await state.set_state("enter_message_manualy_fin")

    await call.message.answer(f"<b>Пожалуйста, введите сообщение для продавца:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")

# Принятие адреса для доставки
@dp.message_handler(state="enter_message_manualy_fin")
async def enter_message_manualy_fin(message: Message, state: FSMContext):
    print('enter_message_manualy_fin')
    user_id = message.from_user.id
    get_user = get_userx(user_id=user_id)
    users_order = get_user_orderx(user_id)
    order_id = users_order['order_id']
    await state.finish()

    if message.text:
        messagetxt = str(message.text)
        print(str(user_id) + messagetxt)
        touser_id = get_cart_sellersx(order_id)
        print(touser_id)

        add_messagex(from_id=user_id, to_id=touser_id, order_id = order_id, txtmessage=messagetxt, photo='', state='created')

    await message.delete()
    await message.answer(f"<b>✅ Было отправлено следующее сообщение продавцу:</b>\n"
                         + messagetxt, reply_markup=cart_enter_message_finl(user_id))

    cm = get_user_messagesx(to_uid=touser_id, state='created')
    if len(cm) > 0:
        print(f"Messages present:{str(touser_id)}")

    await dp.bot.send_message(
        chat_id=touser_id,
        text=f"Сообщение/вопрос по заказу от покупателя:{messagetxt}",
        reply_markup=reply_order_message_finl(order_id),
    )

@dp.callback_query_handler(text_startswith="enter_phone_auto", state="*")
async def enter_phone_man(call: CallbackQuery, state: FSMContext):
    print('enter_phone_auto')
    user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("enter_phone_auto_fin")

    button_phone = KeyboardButton(text="Делись!", request_contact=True)
    keyboard = ReplyKeyboardMarkup(row_width=1, resize_keyboard=True, one_time_keyboard=True)
    keyboard.add(button_phone)
    await call.message.answer(
        "<b>✅ Вы можете поделиться своим номером телефона.</b>",
        reply_markup=menu_frep(message.from_user.id),
    )

    '''await call.message.delete()
    await call.message.answer(f"<b>🎁 Введите Ваш номер телефона:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")'''

@dp.message_handler(content_types=['contact'], state="enter_phone_auto_fin")  # content_types=ContentType.CONTACT,
async def contacts(message: Message, state: FSMContext):
    phone = message.contact.phone_number

    print(phone)
    phone = str(message.text)
    phone = message.contact.phone_number
    update_userx(message.from_user.id, user_phone=phone)

    await message.answer(f"Ваш номер сохранен в Вашем личном кабинете: {message.contact.phone_number}",
                         reply_markup=ReplyKeyboardRemove())  # , reply_markup=types.ReplyKeyboardRemove()
    await state.finish()

    await message.answer(f"<b>✅ Номер телефон был успешно изменен на следующий:</b>\n"
                         + str(phone), reply_markup=accept_saved_phone(message.from_user.id))


'''
    await message.answer("🔸 Мы снова с Вами!.\n"
                     "🔸 Если не появились вспомогательные кнопки\n"
                     "▶ Введите /start",
                     reply_markup=menu_frep(message.from_user.id)) '''


# Принятие адреса для доставки
@dp.message_handler(state="enter_phone_auto_fin2")
async def user_get_phone(message: Message, state: FSMContext):
    print('enter_phone_auto_fin')
    phone = message.contact.phone_number
    get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    print(phone)

    await message.delete()
    await message.answer(f"<b>✅ Номер телефон был успешно изменен на следующий:</b>\n"
                         + phone, reply_markup=accept_saved_phone(message.from_user.id))

@dp.callback_query_handler(text_startswith="enter_phone_manualy", state="*")
async def enter_phone_man(call: CallbackQuery, state: FSMContext):
    print('enter_phone_manualy')
    user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("enter_phone_manualy_fin")

    await call.message.delete()
    await call.message.answer(f"<b>🎁 Введите Ваш номер телефона:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")

# Принятие адреса для доставки
@dp.message_handler(state="enter_phone_manualy_fin")
async def user_enter_phone(message: Message, state: FSMContext):
    print('enter_phone_manualy_fin')
    # user_id = int(call.data.split(":")[1])
    get_user = get_userx(user_id=message.from_user.id)
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        phone = str(message.text)
        update_userx(message.from_user.id, user_phone=phone)

    await message.delete()
    await message.answer(f"<b>✅ Номер телефон был успешно изменен на следующий:</b>\n"
                         + phone, reply_markup=accept_saved_phone(message.from_user.id))

@dp.callback_query_handler(text_startswith="enter_address_manualy", state="*")
async def enter_address_man(call: CallbackQuery, state: FSMContext):
    print('enter_address_manualy')
    # user_id = int(call.data.split(":")[1])
    # user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)

    # get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("enter_address_manualy_fin")

    await call.message.delete()
    await call.message.answer(f"<b>🎁 Введите Ваш адрес:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")

# Принятие адреса для доставки
@dp.message_handler(state="enter_address_manualy_fin")
async def user_enter_addr(message: Message, state: FSMContext):
    print('enter_address_manualy_fin')
    #user_id = int(message.split(":")[1])
    user_id = message.from_user.id
    get_user = get_userx(user_id=user_id)
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        address = str(message.text)
        update_userx(message.from_user.id, user_address=address)

    await message.delete()
    await message.answer(f"<b>✅ Адрес доставки был успешно изменен на следующий:</b>\n"
                         + address, reply_markup=accept_saved_adr(message.from_user.id))

# Выбор количества товаров для покупки
@dp.callback_query_handler(text_startswith="buy_item_select", state="*")
async def buy_item_select(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])

    get_position = get_positionx(position_id=position_id)
    get_items = get_itemsx(position_id=position_id)
    get_user = get_userx(user_id=call.from_user.id)

    if get_position['position_price'] != 0:
        get_count = int(get_user['user_balance'] / get_position['position_price'])
        get_count = min(get_count, len(get_items))
    else:
        get_count = len(get_items)

    if int(get_user['user_balance']) >= int(get_position['position_price']):
        if get_count == 1:
            await state.update_data(here_cache_position_id=position_id)
            await state.finish()

            await call.message.delete()
            await call.message.answer(f"<b>🎁 Вы действительно хотите купить товар(ы)?</b>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                      f"📦 Количество: <code>1шт</code>\n"
                                      f"💰 Сумма к покупке: <code>{get_position['position_price']}₽</code>",
                                      reply_markup=products_confirm_finl(position_id, 1))
        elif get_count >= 1:
            await state.update_data(here_cache_position_id=position_id)
            await state.set_state("here_item_count")

            await call.message.delete()
            await call.message.answer(f"<b>🎁 Введите количество товаров для покупки</b>\n"
                                      f"▶ От <code>1</code> до <code>{get_count}</code>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n"
                                      f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>")
        else:
            await call.answer("🎁 Товаров нет в наличии")
    else:
        #await call.answer("❗ У вас недостаточно средств. Пополните баланс", True)
        #await call.message.delete()
        await call.message.answer(
            "<b>❗ У вас недостаточно средств. Пополните баланс</b>",
            reply_markup=charge_button_add(0),
        )


@dp.callback_query_handler(text_startswith="edit_delivery_settings", state="*")
async def enter_phone_man(call: CallbackQuery, state: FSMContext):
    print('edit_delivery_settings')
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)

    # get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("edit_delivery_settings_fin")

    await call.message.delete()
    await call.message.answer(f"<b>Введите минимальный порог бесплатной доставки X и ставку доставки по городу Y через пробел:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")

# Принятие адреса для доставки
@dp.message_handler(state="edit_delivery_settings_fin")
async def user_enter_phone(message: Message, state: FSMContext):
    print('edit_delivery_settings_fin')
    # user_id = int(call.data.split(":")[1])
    get_user = get_userx(user_id=message.from_user.id)
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        free_delivery_point, delivery_rate = str(message.text).split()
        if free_delivery_point and delivery_rate:
            update_userx(message.from_user.id, free_delivery_point=free_delivery_point, delivery_rate=delivery_rate)
            await message.delete()
            await message.answer(f"<b>✅ Настройки были установлены: X={free_delivery_point}, Y={delivery_rate}.</b>\n"
                                 , reply_markup=edit_delivery_settings_finl())
        else:
            await message.delete()
            await message.answer(f"<b>⭕ Настройки не были установлены. Проверьте написание или уточните там, где Вы его получили.</b>\n"
                                 , reply_markup=edit_delivery_settings_finl())


@dp.callback_query_handler(text_startswith="enter_promocode", state="*")
async def enter_phone_man(call: CallbackQuery, state: FSMContext):
    print('enter_promocode')
    # user_id = int(call.data.split(":")[1])
    user_id = call.from_user.id
    get_user = get_userx(user_id=call.from_user.id)
    # get_user = get_userx(user_id=call.from_user.id)

    await state.set_state("enter_promocode_fin")

    await call.message.delete()
    await call.message.answer(f"<b>🎁 Введите Ваш промокод и мы его применим:</b>\n"
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n")

# Принятие адреса для доставки
@dp.message_handler(state="enter_promocode_fin")
async def user_enter_phone(message: Message, state: FSMContext):
    print('enter_promocode_fin')
    # user_id = int(call.data.split(":")[1])
    get_user = get_userx(user_id=message.from_user.id)
    # get_user = get_userx(user_id=message.from_user.id)
    await state.finish()

    if message.text:
        promocodeutxt = str(message.text)
        if promocode := get_promocodex(promocode=promocodeutxt):
            update_userx(message.from_user.id, promocode=promocodeutxt)
            await message.delete()
            await message.answer(f"<b>✅ Ваш промокод был успешно применен. Размер Вашей скидки теперь: {promocode['discount']} </b>\n"
                                 , reply_markup=enter_promocode_finl())
        else:
            await message.delete()
            await message.answer(f"<b>⭕ Ваш промокод не был найден. Проверьте написание или уточните там, где Вы его получили.</b>\n"
                                 , reply_markup=enter_promocode_finl())


# -------------------------------------------------------------------------------------
# Выбор количества товаров для покупки
@dp.callback_query_handler(text_startswith="buy_item_select", state="*")
async def user_purchase_select(call: CallbackQuery, state: FSMContext):
    position_id = int(call.data.split(":")[1])

    get_position = get_positionx(position_id=position_id)
    get_items = get_itemsx(position_id=position_id)
    get_user = get_userx(user_id=call.from_user.id)

    if get_position['position_price'] != 0:
        get_count = int(get_user['user_balance'] / get_position['position_price'])
        get_count = min(get_count, len(get_items))
    else:
        get_count = len(get_items)

    if int(get_user['user_balance']) >= int(get_position['position_price']):
        if get_count == 1:
            await state.update_data(here_cache_position_id=position_id)
            await state.finish()

            await call.message.delete()
            await call.message.answer(f"<b>🎁 Вы действительно хотите купить товар(ы)?</b>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                      f"📦 Количество: <code>1шт</code>\n"
                                      f"💰 Сумма к покупке: <code>{get_position['position_price']}₽</code>",
                                      reply_markup=products_confirm_finl(position_id, 1))
        elif get_count >= 1:
            await state.update_data(here_cache_position_id=position_id)
            await state.set_state("here_item_count")

            await call.message.delete()
            await call.message.answer(f"<b>🎁 Введите количество товаров для покупки</b>\n"
                                      f"▶ От <code>1</code> до <code>{get_count}</code>\n"
                                      f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                      f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n"
                                      f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>")
        else:
            await call.answer("🎁 Товаров нет в наличии")
    else:
        #await call.answer("❗ У вас недостаточно средств. Пополните баланс", True)
        #await call.message.delete()
        await call.message.answer(
            "<b>❗ У вас недостаточно средств. Пополните баланс</b>",
            reply_markup=charge_button_add(0),
        )

# Принятие количества товаров для покупки
@dp.message_handler(state="here_item_count")
async def user_purchase_select_count(message: Message, state: FSMContext):
    position_id = (await state.get_data())['here_cache_position_id']

    get_position = get_positionx(position_id=position_id)
    get_user = get_userx(user_id=message.from_user.id)
    get_items = get_itemsx(position_id=position_id)

    if get_position['position_price'] != 0:
        get_count = int(get_user['user_balance'] / get_position['position_price'])
        get_count = min(get_count, len(get_items))
    else:
        get_count = len(get_items)

    send_message = f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                   f"🎁 Введите количество товаров для покупки\n" \
                   f"▶ От <code>1</code> до <code>{get_count}</code>\n" \
                   f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                   f"🎁 Товар: <code>{get_position['position_name']}</code> - <code>{get_position['position_price']}₽</code>\n" \
                   f"💰 Ваш баланс: <code>{get_user['user_balance']}₽</code>"

    if message.text.isdigit():
        get_count = int(message.text)
        amount_pay = int(get_position['position_price']) * get_count

        if len(get_items) >= 1:
            if 1 <= get_count <= len(get_items):
                if int(get_user['user_balance']) >= amount_pay:
                    await state.finish()
                    await message.answer(f"<b>🎁 Вы действительно хотите купить товар(ы)?</b>\n"
                                         f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                         f"🎁 Товар: <code>{get_position['position_name']}</code>\n"
                                         f"📦 Количество: <code>{get_count}шт</code>\n"
                                         f"💰 Сумма к покупке: <code>{amount_pay}₽</code>",
                                         reply_markup=products_confirm_finl(position_id, get_count))
                else:
                    await message.answer(
                        f"<b>❌ Недостаточно средств на счете.</b>\n{send_message}"
                    )
            else:
                await message.answer(f"<b>❌ Неверное количество товаров.</b>\n{send_message}")
        else:
            await state.finish()
            await message.answer(_("<b>🎁 Товар который вы хотели купить, закончился</b>", locale=lang))
    else:
        await message.answer(f"<b>❌ Данные были введены неверно.</b>\n{send_message}")

# Подтверждение покупки товара
@dp.callback_query_handler(text_startswith="xbuy_item", state="*")
async def user_purchase_confirm(call: CallbackQuery, state: FSMContext):
    get_action = call.data.split(":")[1]
    position_id = int(call.data.split(":")[2])
    get_count = int(call.data.split(":")[3])

    if get_action == "yes":
        await call.message.edit_text(_("<b>🔄 Ждите, товары подготавливаются</b>", locale=lang))

        get_position = get_positionx(position_id=position_id)
        get_items = get_itemsx(position_id=position_id)
        get_user = get_userx(user_id=call.from_user.id)

        amount_pay = int(get_position['position_price'] * get_count)

        if 1 <= get_count <= len(get_items):
            if int(get_user['user_balance']) >= amount_pay:
                save_items, send_count, split_len = buy_itemx(get_items, get_count)

                if get_count != send_count:
                    amount_pay = int(get_position['position_price'] * send_count)
                    get_count = send_count

                receipt = get_unix()
                buy_time = get_date()

                await call.message.delete()
                if split_len == 0:
                    await call.message.answer("\n\n".join(save_items), parse_mode="None")
                else:
                    for item in split_messages(save_items, split_len):
                        await call.message.answer("\n\n".join(item), parse_mode="None")
                        await asyncio.sleep(0.3)

                update_userx(get_user['user_id'], user_balance=get_user['user_balance'] - amount_pay)
                add_purchasex(get_user['user_id'], get_user['user_login'], get_user['user_name'], receipt, get_count,
                              amount_pay, get_position['position_price'], get_position['position_id'],
                              get_position['position_name'], "\n".join(save_items), buy_time, receipt,
                              get_user['user_balance'], int(get_user['user_balance'] - amount_pay))

                await notify(dp, f"Продана позиция: {get_position['position_name']}")
                await call.message.answer(f"<b>✅ Вы успешно купили товар(ы)</b>\n"
                                          f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n"
                                          f"🧾 Чек: <code>#{receipt}</code>\n"
                                          f"🎁 Товар: <code>{get_position['position_name']} | {get_count}шт | {amount_pay}₽</code>\n"
                                          f"🕰 Дата покупки: <code>{buy_time}</code>",
                                          reply_markup=menu_frep(call.from_user.id))
            else:
                await call.message.answer(_("<b>❗ На вашем счёте недостаточно средств</b>", locale=lang))
        else:
            await call.message.answer(_("<b>🎁 Товар который вы хотели купить закончился или изменился.</b>", locale=lang),
                                      reply_markup=menu_frep(call.from_user.id))
    elif len(get_all_categoriesx()) >= 1:
        await call.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                     reply_markup=category_edit_open_fp(0))
    else:
        await call.message.edit_text(_("<b>✅ Вы отменили покупку товаров.</b>", locale=lang))




tgbot >handlers>user_transactions.py:
# - *- coding: utf- 8 - *-
from aiogram.dispatcher import FSMContext
from aiogram.types import CallbackQuery, Message
import asyncio
#from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
import time
import datetime
import requests
import json
import gettext
import decimal
from pathlib import Path
from contextvars import ContextVar

from tgbot.keyboards.inline_user import refill_bill_finl, refill_choice_finl, refill_bill_crypto_finl
from tgbot.loader import dp
from tgbot.services.api_qiwi import QiwiAPI
from tgbot.services.api_yoo import YooAPI
#from tgbot.services.api_cb import CoinbaseAPI
#from tgbot.services.api_crypto import BinanceAPI
from tgbot.services.api_tron import TronAPI
#import tronpy
#from yoomoney import Client as ClientYoo
from tgbot.services.api_sqlite import update_userx, get_refillx, add_refillx, get_userx, get_user_lang, add_prepay, create_crypto_payment_row, get_tron_address, get_crypto_address, get_system_crypto_address, get_system_tron_address
from tgbot.utils.const_functions import get_date, get_unix
from tgbot.utils.misc_functions import send_admins, catch_transactions20m, address_to_hex, check_trx_now, check_btc_now
from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR
#from tgbot.middlewares.i18n import I18nMiddleware
#from aiogram.contrib.middlewares.i18n import I18nMiddleware
from tgbot.middlewares.i18n import I18nMiddleware

i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)

print(i18n)
_ = i18n.gettext

min_input_qiwi = 5  # Минимальная сумма пополнения в рублях
min_input_yoo = 5

def get_tron_prices():
    url = 'https://apilist.tronscanapi.com/api/search/hot'
    payload = {}
    response = requests.get(url, payload)
    data = json.loads(response.text)

    return data

def GetTronPrice():
    try:
        url = 'https://api.binance.com/api/v3/ticker/price?symbol=TRXUSDT'
        payload = {}
        #req = requests.get("https://api-pub.bitfinex.com/v2/ticker/tTRXUSD")
        cresponse = requests.get(url, payload)
        print(cresponse)
        response = json.loads(cresponse.text)
        trxusdt_price = response['price']
        return trxusdt_price
    except Exception:
        raise Exception("Damn...Something was wrong...")

def GetUSDTPrice():
    try:
        url = 'https://api.binance.com/api/v3/ticker/price?symbol=USDTRUB'
        payload = {}
        #req = requests.get("https://api-pub.bitfinex.com/v2/ticker/tTRXUSD")
        cresponse = requests.get(url, payload)
        print(cresponse)
        response = json.loads(cresponse.text)
        priceusdt = response['price']
        return priceusdt
    except Exception:
        raise Exception("Damn...Something was wrong...")


def GetBtcPrice():
    try:
        url = 'https://api.binance.com/api/v3/ticker/price?symbol=BTCRUB'
        payload = {}
        #req = requests.get("https://api-pub.bitfinex.com/v2/ticker/tTRXUSD")
        cresponse = requests.get(url, payload)
        print(cresponse)
        response = json.loads(cresponse.text)
        btc_price = response['price']
        return btc_price
    except Exception:
        raise Exception("Damn...Something was wrong...")

def getTokens():
    url = "https://apilist.tronscan.org/api/token"
    response = requests.get(url)
    tokens = response.json()

    return tokens

    # Выбор способа пополнения
@dp.callback_query_handler(text="user_refill", state="*")
async def refill_way(call: CallbackQuery, state: FSMContext):
    user_id = call.from_user.id
    print(user_id)
    lang = get_user_lang(user_id)['user_lang']
    print(lang)
    get_kb = refill_choice_finl(lang)

    if get_kb is not None:
        await call.message.edit_text(_("<b>💰 Выберите способ пополнения</b>", locale=lang), reply_markup=get_kb)
    else:
        await call.answer(_("⛔ Пополнение временно недоступно", locale=lang), True)

# Изменение адреса в сети Tron TRC20
@dp.callback_query_handler(text_startswith="change_trc20", state="*")
async def change_trc20(call: CallbackQuery, state: FSMContext):
    tron_address = get_tron_address(call.from_user.id)
    trx_addr_txt = ""
    if tron_address: trx_addr_txt = f"<b>Ваш текущий Tron TRC20 адрес</b>: {tron_address['tron_address']}\n"
    await state.set_state("here_tron_address")
    await call.message.edit_text(f"{trx_addr_txt}\n "
                                 f"Введите адрес TRC20 с которого планируете пополнять баланс")

# Изменение адреса в сети Tron TRC20
@dp.callback_query_handler(text_startswith="change_bep20", state="*")
async def change_trc20(call: CallbackQuery, state: FSMContext):
    btcb_address = get_crypto_address(call.from_user.id, "BTCB")
    btcb_addr_txt = ""
    if btcb_address: btcb_addr_txt = f"<b>Ваш текущий BTC BEP20 адрес</b>: {btcb_address['tron_address']}\n"
    await state.set_state("here_crypto_address")
    await call.message.edit_text(f"{btcb_addr_txt}\n "
                                 f"Введите адрес BTC BEP20 с которого планируете пополнять баланс")


# Выбор способа пополнения
@dp.callback_query_handler(text_startswith="refill_choice", state="*")
async def refill_way_choice(call: CallbackQuery, state: FSMContext):
    get_way = call.data.split(":")[1]
    #user_id = call.from_user.id
    print("OKKKK1")
    print(get_way)

    if get_way == "Tron":
        type_net = call.data.split(":")[2]
        print(type_net)
        await state.update_data(here_type_net=type_net)

    await state.update_data(here_pay_way=get_way)

    if get_way == 'Tron':
        tron_address = get_tron_address(call.from_user.id)
        if tron_address:
            print(tron_address)
            await state.update_data(here_tron_address=tron_address['tron_address'])
            await state.set_state("here_pay_amount")
            await call.message.edit_text("<b>💰 Введите сумму пополнения в рублях</b>")

        else:
            print("TRON ADDRESS NOT EXIST")
            await state.set_state("here_tron_address")
            await call.message.edit_text("Введите адрес с которого планируете пополнить баланс")

    if get_way == 'BTCB':
        crypto_address = get_crypto_address(call.from_user.id, get_way)
        await state.update_data(here_type_net=get_way)
        if crypto_address:
            print(crypto_address)
            await state.update_data(here_crypto_address=crypto_address['tron_address'])
            await state.set_state("here_pay_amount")
            await call.message.edit_text("<b>💰 Введите сумму пополнения в рублях</b>")

        else:
            print("BTCB ADDRESS NOT EXIST")
            await state.set_state("here_crypto_address")
            await call.message.edit_text("Введите адрес с которого планируете пополнить баланс")


###################################################################################
#################################### ВВОД СУММЫ ###################################
# Принятие суммы для пополнения средств через QIWI
@dp.message_handler(state="here_pay_amount")
async def refill_get(message: Message, state: FSMContext):
    if message.text.isdigit():
        cache_message = await message.answer("<b>♻ Подождите, платёж генерируется...</b>")
        pay_amount = int(message.text)

        if min_input_qiwi <= pay_amount <= 300000:
            get_way = (await state.get_data())['here_pay_way']
            #await state.finish()

            if get_way == "Form" or get_way == "Nickname" or get_way == "Number":
                get_message, get_link, receipt = await (
                    await QiwiAPI(cache_message, user_bill_pass=True)
                ).bill_pay(pay_amount, get_way)

            if get_way == "Tron" or get_way == "BTCB":
                receipt = str(int(time.time() * 100))
                await state.update_data(here_receipt=receipt)
                if get_way == "Tron":
                    type_net = (await state.get_data())['here_type_net']
                    address_from = (await state.get_data())['here_tron_address']
                if get_way == "BTCB":
                    type_net = (await state.get_data())['here_type_net']
                    address_from = (await state.get_data())['here_crypto_address']

                if type_net == "USDT":
                    coinprice = GetUSDTPrice()
                    #coinprice = 78.18000000
                    net_name = "TRC20"
                    priceincoin = round(pay_amount / float(coinprice), 9)
                    print(priceincoin)
                    priceincoinq = round(priceincoin, 9)
                    print(priceincoinq)

                elif type_net == "BTCB":
                    coinprice = GetBtcPrice()
                    net_name = "BEP20"
                    coinpriceUSDT = GetUSDTPrice()
                    priceincoin = round(pay_amount / float(coinpriceUSDT) / float(coinprice), 9)
                    print(priceincoin)
                    priceincoinq = round(priceincoin, 9)
                    print(priceincoinq)

                elif type_net == "TRX":
                    coinprice = GetTronPrice()
                    coinpriceUSDT = GetUSDTPrice()
                    net_name = "TRC20"
                    priceincoin = round(pay_amount / float(coinpriceUSDT) / float(coinprice), 9)
                    print(priceincoin)
                    priceincoinq = round(priceincoin, 9)
                    print(priceincoinq)

                print(pay_amount, type_net, coinprice)


                #address_to = "TQanL97TYygHiycDZ1up8XNqt1mHcGJ4Nv"
                #adddress_to = (await state.get_data())['here_crypto_address'] #(await state.get_data())['here_tron_address']
                address_to = get_system_crypto_address(type_net)
                get_message = f"<b>🆙 Пополнение баланса крипто валютой {type_net}</b>\n" \
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                              f" Для пополнения баланса, нажмите на кнопку ниже \n" \
                              f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                              f"❗ У вас имеется 30 минут на оплату счета.\n" \
                              f"❗ Адрес в сети {net_name}: {address_to['tron_address']}\n" \
                              f"❗ Текущая цена {type_net}: {coinprice} \n" \
                              f"💰 Сумма пополнения в {type_net}: <code>{priceincoin:.6f} </code>\n" \
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                              f"❗ Ожидается транзакция с адреса: {address_from}\n" \
                              f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"

            if get_way == "Form" or get_way == "Nickname" or get_way == "Number":
                get_message = f"<b>🆙 Пополнение баланса</b>\n" \
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                              f" Для пополнения баланса, нажмите на кнопку ниже \n" \
                              f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                              f"❗ У вас имеется 30 минут на оплату счета.\n" \
                              f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                              f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"


                #wallet = 'TQanL97TYygHiycDZ1up8XNqt1mHcGJ4Nv'
                #address_to = (await state.get_data())['here_tron_address']
                #trxs = await get_trx(address_to)
                #print(trxs)

            await state.set_state("here_pay_check")
            lang = "ru"

            if get_way in ["Tron", "BTCB"] and get_message:
                #tron_address = (await state.get_data())['here_tron_address']
                await cache_message.edit_text(get_message, reply_markup=refill_bill_crypto_finl(get_way, type_net, receipt, lang))

            if get_way != "Tron" and get_way != "BTCB":
                await cache_message.edit_text(get_message, reply_markup=refill_bill_finl(get_link, receipt, get_way))
        else:
            await cache_message.edit_text(f"<b>❌ Неверная сумма пополнения</b>\n"
                                          f"▶ Cумма не должна быть меньше <code>{min_input_qiwi}₽</code> и больше <code>300 000₽</code>\n"
                                          f"💰 Введите сумму для пополнения средств")
    else:
        await message.answer("<b>❌ Данные были введены неверно.</b>\n"
                             "💰 Введите сумму для пополнения средств")

async def get_trx(address_to):
    url = f"https://api.trongrid.io/v1/accounts/{address_to}/transactions?only_confirmed=true&only_to=true"

    response = await requests.get(url, headers={"TRON-PRO-API-KEY": "5c4c149e-83d1-4926-8d73-78dac1ab2d38"})

    if response.status_code == 200:
        total = 0
        transactions = json.loads(response.text)["data"]
        for tx in transactions:
            if tx["raw_data"]["contract"][0]["parameter"]["value"]["to_address"] == address_to and tx["raw_data"]["contract"][0]["parameter"]["value"]["amount"] > 0:
                #if tx["raw_data"]["contract"][0]["parameter"]["value"]["owner_address"] == address_from:
                total += tx["raw_data"]["contract"][0]["parameter"]["value"]["amount"]
                #print(tx["raw_data"]["contract"], total)
                return tx["raw_data"]["contract"]

###################################################################################
################################ ПРОВЕРКА ПЛАТЕЖЕЙ ################################
# Проверка оплаты через форму QIWI
@dp.callback_query_handler(text_contains="Pay:Form")
async def refill_check_form(call: CallbackQuery):
    receipt = call.data.split(":")[2]
    user_id = call.message.from_user.id
    pay_scheme = 2

    if pay_scheme == 1:
        pay_status, pay_amount = await (
            await QiwiAPI(call, user_check_pass=True)
        ).check_form(receipt)

    elif pay_scheme == 2:
        pay_status, pay_amount = await (
            await QiwiAPI(call, suser_id=user_id, user_check_pass=True)
        ).check_form(receipt)

    if pay_status == "PAID":
        get_refill = get_refillx(refill_receipt=receipt)
        if get_refill is None:
            await refill_success(call, receipt, pay_amount, "Form")
        else:
            await call.answer(_("❗ Ваше пополнение уже было зачислено.", locale=lang), True)
    elif pay_status == "EXPIRED":
        await call.message.edit_text(_("<b>❌ Время оплаты вышло. Платёж был удалён.</b>", locale=lang))
    elif pay_status == "WAITING":
        await call.answer(_("❗ Платёж не был найден.\n"
                          "⌛ Попробуйте чуть позже.", locale=lang), True, cache_time=5)
    elif pay_status == "REJECTED":
        await call.message.edit_text(_("<b>❌ Счёт был отклонён.</b>", locale=lang))


# Проверка оплаты через форму Yoo
@dp.callback_query_handler(text_contains="Pay:ForYm")
async def refill_check_formy(call: CallbackQuery):
    print("UT 115")
    receipt = call.data.split(":")[2]
    print(call.data)
    print(receipt)
    suid=call.from_user.id

    pay_status, pay_amount = await (
        await YooAPI(suid=suid)
    ).check_formy(receipt)

    print(pay_status, pay_amount)

    if pay_status == "success":
        get_refill = get_refillx(refill_receipt=receipt)
        if get_refill is None:
            await refill_success(call, receipt, pay_amount, "ForYm")
        else:
            await call.answer(_("❗ Ваше пополнение уже было зачислено.", locale=lang), True)
    elif pay_status == "EXPIRED":
        await call.message.edit_text(_("<b>❌ Время оплаты вышло. Платёж был удалён.</b>", locale=lang))
    elif pay_status == "WAITING":
        await call.answer(_("❗ Платёж не был найден.\n"
                          "⌛ Попробуйте чуть позже.", locale=lang), True, cache_time=5)
    elif pay_status == "REJECTED":
        await call.message.edit_text(_("<b>❌ Счёт был отклонён.</b>", locale=lang))


# Проверка оплаты через сеть TronNet
@dp.callback_query_handler(text_contains="Pay:Tron", state="*")  #text_contains text_startswith
async def refill_check_tron(call: CallbackQuery, state: FSMContext):
    print("UT 336")
    get_way = call.data.split(":")[1]
    type_net = call.data.split(":")[2]
    receipt = call.data.split(":")[3]
    user_id = call.from_user.id
    print(type_net, receipt)

    await state.update_data(here_type_net=type_net)
    await call.answer(f"♻ Подождите, платёж проверяется...")


    #address_to = 'TQanL97TYygHiycDZ1up8XNqt1mHcGJ4Nv'
    address_to = get_system_crypto_address(type_net)['tron_address']


    address_from = (await state.get_data())['here_tron_address']

    print(address_to, address_from)
    st = get_unix()
    #print(wallet, tron_address)
    #catch_transactions20m(tron_address, wallet)
    #await catch_transactionsy(wallet, tron_address)
    #asyncio.create_task(catch_transactionsy(wallet, address_to))

    '''url = f"https://api.trongrid.io/v1/accounts/{address_to}/transactions?only_confirmed=true&only_to=true"

    response = requests.get(url, headers={"TRON-PRO-API-KEY": "5c4c149e-83d1-4926-8d73-78dac1ab2d38"})

    if response.status_code == 200:
        total = 0
        transactions = json.loads(response.text)["data"]
        for tx in transactions:
            if tx["raw_data"]["contract"][0]["parameter"]["value"]["to_address"] == address_to and tx["raw_data"]["contract"][0]["parameter"]["value"]["amount"] > 0:
                #if tx["raw_data"]["contract"][0]["parameter"]["value"]["owner_address"] == address_from:
                total += tx["raw_data"]["contract"][0]["parameter"]["value"]["amount"]
                print(tx["raw_data"]["contract"], total)'''

    #asyncio.create_task(catch_transactions20m(address_from, address_to))
    #total_amount = await catch_transactions20m(address_from, address_to)
    if type_net == "USDT":
        coinprice = GetUSDTPrice()
    elif type_net == "BTCB":
        coinprice = GetBtcPrice()
    elif type_net == "TRX":
        coinprice = GetTronPrice()

    qpay_amount, receipt = await check_trx_now(address_from, st, address_to) #, pay_status, receipt
    print(qpay_amount, coinprice)
    if qpay_amount > 0:
        pay_amount = qpay_amount*int(float(coinprice))/1000000
    elif qpay_amount == 0:
        pay_amount = int(float(coinprice))/1000000
    print(pay_amount)
    get_user = get_userx(user_id=call.from_user.id)

    #if pay_status == "SUCCESS":
    if qpay_amount > 0:
        get_refill = get_refillx(refill_receipt=receipt)
        if get_refill is None:
            await refill_success(call, receipt, pay_amount, get_way)
        else:
            await call.answer("❗ Ваше пополнение уже было зачислено.", True)
        '''elif pay_status == "EXPIRED":
            await call.message.edit_text(_("<b>❌ Время оплаты вышло. Платёж был удалён.</b>", locale=lang))
        elif pay_status == "WAITING":
            await call.answer(_("❗ Платёж не был найден.\n"
                                "⌛ Попробуйте чуть позже.", locale=lang), True, cache_time=5)
        elif pay_status == "REJECTED":
            await call.message.edit_text(_("<b>❌ Счёт был отклонён.</b>", locale=lang))'''
    else:
        await call.message.edit_text(f"<b>❌ Транзакция не найдена, если вы выполнили перевод, попробуйте проверить позже.</b>")

# Проверка оплаты через сеть TronNet
@dp.callback_query_handler(text_contains="Pay:BTCB", state="*")  #text_contains text_startswith
async def refill_check_tron(call: CallbackQuery, state: FSMContext):
    print("UT 320")
    get_way = call.data.split(":")[1]
    type_net = call.data.split(":")[2]
    receipt = call.data.split(":")[3]
    user_id = call.from_user.id
    print(type_net, receipt)

    await state.update_data(here_type_net=type_net)
    await call.answer(f"♻ Подождите, платёж проверяется...")

    #address_to = 'TQanL97TYygHiycDZ1up8XNqt1mHcGJ4Nv'
    #address_to = '0x9798e988664856c20c37b5bf311a4ee85227a0df'
    address_to = get_system_crypto_address(get_way)['tron_address']

    address_from = (await state.get_data())['here_crypto_address']
    print(address_to, address_from)
    st = get_unix()

    if type_net == "USDT":
        coinprice = GetUSDTPrice()
    elif type_net == "BTCB":
        coinprice = GetBtcPrice()
    elif type_net == "TRX":
        coinprice = GetTronPrice()

    qpay_amount, receipt = await check_btc_now(address_from, st, address_to)
    print(qpay_amount, coinprice)
    if qpay_amount > 0:
        pay_amount = round((qpay_amount / 1000000000000000000 * float(coinprice)), 2)
        #pay_amount = qpay_amount*int(float(coinprice))/1000000/1000000/10000000
    elif qpay_amount == 0:
        pay_amount = int(float(coinprice))/1000000
    print(pay_amount)
    get_user = get_userx(user_id=call.from_user.id)

    #if pay_status == "SUCCESS":
    if qpay_amount > 0:
        get_refill = get_refillx(refill_receipt=receipt)
        if get_refill is None:
            await refill_success(call, receipt, pay_amount, get_way)
        else:
            await call.message.edit_text("❗ Ваше пополнение уже было зачислено.")
        '''elif pay_status == "EXPIRED":
            await call.message.edit_text(_("<b>❌ Время оплаты вышло. Платёж был удалён.</b>", locale=lang))
        elif pay_status == "WAITING":
            await call.answer(_("❗ Платёж не был найден.\n"
                                "⌛ Попробуйте чуть позже.", locale=lang), True, cache_time=5)
        elif pay_status == "REJECTED":
            await call.message.edit_text(_("<b>❌ Счёт был отклонён.</b>", locale=lang))'''
    else:
        await call.message.edit_text(f"<b>❌ Транзакция не найдена, если вы выполнили перевод, попробуйте проверить позже.</b>")


# Принятие Трон адреса и сохранение если нет
@dp.message_handler(state="here_tron_address")
async def enter_tron_address(message: Message, state: FSMContext):
    user_id = message.from_user.id
    type_net = "USDT"
    trx_address = ""
    print("PPPP")

    if message.text:
        tron_address = message.text
        if tron_address == "" or tron_address is None:
            await message.answer(f"<b>♻ Был введен пустой адрес</b>", reply_markup=back_to_profile_finl())

        trx_address = get_crypto_address(user_id, tron_address)

        if trx_address:
            create_crypto_payment_row(user_id, tron_address, type_net)
        else:
            update_crypto_address(user_id, tron_address=tron_address, type_net=type_net)

        await state.update_data(here_tron_address=tron_address)
        await state.set_state("here_pay_amount")

        await message.answer(f"<b>♻ Успешно сохранили Ваш Crypto адрес в профиле.</b>", reply_markup=back_to_profile_finl())


# Принятие Трон адреса и сохранение если нет
@dp.message_handler(state="here_crypto_address")
async def enter_tron_address(message: Message, state: FSMContext):
    user_id = message.from_user.id
    type_net = (await state.get_data())['here_type_net']

    if message.text:
        crypto_address = message.text

        trx_address = get_crypto_address(user_id, crypto_address)
        #print(trx_address)
        if trx_address:
            create_crypto_payment_row(user_id, crypto_address, type_net)
        else:
            update_crypto_address(user_id, tron_address=crypto_address, type_net=type_net)

        create_crypto_payment_row(user_id, crypto_address, type_net)

        await state.update_data(here_crypto_address=crypto_address)
        await state.set_state("here_pay_amount")

        await message.answer(f"<b>♻ Успешно сохранили Ваш Crypto адрес в профиле.</b>", reply_markup=back_to_profile_finl())


##########################################################################################
######################################### ПРОЧЕЕ #########################################
# Зачисление средств
async def refill_success(call: CallbackQuery, receipt, amount, get_way):
    get_user = get_userx(user_id=call.from_user.id)

    add_refillx(get_user['user_id'], get_user['user_login'], get_user['user_name'], receipt,
                amount, receipt, get_way, get_date(), get_unix())

    update_userx(call.from_user.id,
                 user_balance=get_user['user_balance'] + amount,
                 user_refill=get_user['user_refill'] + amount)

    await call.message.edit_text(f"<b>💰 Вы пополнили баланс на сумму <code>{amount}₽</code>. Удачи ❤\n"
                                 f"🧾 Чек: <code>#{receipt}</code></b>")

    await send_admins(
        f"👤 Пользователь: <b>@{get_user['user_login']}</b> | <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a> | <code>{get_user['user_id']}</code>\n"
        f"💰 Сумма пополнения: <code>{amount}₽</code>\n"
        f"🧾 Чек: <code>#{receipt}</code>"
    )


tgbot >handlers>user_transactions2.py:
# - *- coding: utf- 8 - *-
from aiogram.dispatcher import FSMContext
from aiogram.types import CallbackQuery, Message

from tgbot.keyboards.inline_user import refill_bill_finl, refill_choice_finl
from tgbot.loader import dp
from tgbot.services.api_qiwi import QiwiAPI
from tgbot.services.api_sqlite import update_userx, get_refillx, add_refillx, get_userx
from tgbot.utils.const_functions import get_date, get_unix
from tgbot.utils.misc_functions import send_admins

min_input_qiwi = 5  # Минимальная сумма пополнения в рублях


# Выбор способа пополнения
@dp.callback_query_handler(text="user_refill", state="*")
async def refill_way(call: CallbackQuery, state: FSMContext):
    get_kb = refill_choice_finl(user_id=call.from_user.id)

    if get_kb is not None:
        await call.message.edit_text("<b>💰 Выберите способ пополнения</b>", reply_markup=get_kb)
    else:
        await call.answer("⛔ Пополнение временно недоступно", True)


# Выбор способа пополнения
@dp.callback_query_handler(text_startswith="refill_choice", state="*")
async def refill_way_choice(call: CallbackQuery, state: FSMContext):
    get_way = call.data.split(":")[1]

    await state.update_data(here_pay_way=get_way)

    await state.set_state("here_pay_amount")
    await call.message.edit_text("<b>💰 Введите сумму пополнения</b>")


###################################################################################
#################################### ВВОД СУММЫ ###################################
# Принятие суммы для пополнения средств через QIWI
@dp.message_handler(state="here_pay_amount")
async def refill_get(message: Message, state: FSMContext):
    if message.text.isdigit():
        cache_message = await message.answer("<b>♻ Подождите, платёж генерируется...</b>")
        pay_amount = int(message.text)

        if min_input_qiwi <= pay_amount <= 300000:
            get_way = (await state.get_data())['here_pay_way']
            await state.finish()

            get_message, get_link, receipt = await (
                await QiwiAPI(cache_message, user_bill_pass=True)
            ).bill_pay(pay_amount, get_way)

            if get_message:
                await cache_message.edit_text(get_message, reply_markup=refill_bill_finl(get_link, receipt, get_way))
        else:
            await cache_message.edit_text(f"<b>❌ Неверная сумма пополнения</b>\n"
                                          f"▶ Cумма не должна быть меньше <code>{min_input_qiwi}₽</code> и больше <code>300 000₽</code>\n"
                                          f"💰 Введите сумму для пополнения средств")
    else:
        await message.answer("<b>❌ Данные были введены неверно.</b>\n"
                             "💰 Введите сумму для пополнения средств")


###################################################################################
################################ ПРОВЕРКА ПЛАТЕЖЕЙ ################################
# Проверка оплаты через форму
@dp.callback_query_handler(text_startswith="Pay:Form")
async def refill_check_form(call: CallbackQuery):
    receipt = call.data.split(":")[2]

    pay_status, pay_amount = await (
        await QiwiAPI(call, user_check_pass=True)
    ).check_form(receipt)

    if pay_status == "PAID":
        get_refill = get_refillx(refill_receipt=receipt)
        if get_refill is None:
            await refill_success(call, receipt, pay_amount, "Form")
        else:
            await call.answer("❗ Ваше пополнение уже было зачислено.", True)
    elif pay_status == "EXPIRED":
        await call.message.edit_text("<b>❌ Время оплаты вышло. Платёж был удалён.</b>")
    elif pay_status == "WAITING":
        await call.answer("❗ Платёж не был найден.\n"
                          "⌛ Попробуйте чуть позже.", True, cache_time=5)
    elif pay_status == "REJECTED":
        await call.message.edit_text("<b>❌ Счёт был отклонён.</b>")


# Проверка оплаты по переводу (по нику или номеру)
@dp.callback_query_handler(text_startswith=['Pay:Number', 'Pay:Nickname'])
async def refill_check_send(call: CallbackQuery):
    way_pay = call.data.split(":")[1]
    receipt = call.data.split(":")[2]

    pay_status, pay_amount = await (
        await QiwiAPI(call, user_check_pass=True)
    ).check_send(receipt)

    if pay_status == 1:
        await call.answer("❗ Оплата была произведена не в рублях.", True, cache_time=5)
    elif pay_status == 2:
        await call.answer("❗ Платёж не был найден.\n"
                          "⌛ Попробуйте чуть позже.", True, cache_time=5)
    elif pay_status != 4:
        get_refill = get_refillx(refill_receipt=receipt)
        if get_refill is None:
            await refill_success(call, receipt, pay_amount, way_pay)
        else:
            await call.answer("❗ Ваше пополнение уже зачислено.", True, cache_time=60)


##########################################################################################
######################################### ПРОЧЕЕ #########################################
# Зачисление средств
async def refill_success(call: CallbackQuery, receipt, amount, get_way):
    get_user = get_userx(user_id=call.from_user.id)

    add_refillx(get_user['user_id'], get_user['user_login'], get_user['user_name'], receipt,
                amount, receipt, get_way, get_date(), get_unix())

    update_userx(call.from_user.id,
                 user_balance=get_user['user_balance'] + amount,
                 user_refill=get_user['user_refill'] + amount)

    await call.message.edit_text(f"<b>💰 Вы пополнили баланс на сумму <code>{amount}₽</code>. Удачи ❤\n"
                                 f"🧾 Чек: <code>#{receipt}</code></b>")

    await send_admins(
        f"👤 Пользователь: <b>@{get_user['user_login']}</b> | <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a> | <code>{get_user['user_id']}</code>\n"
        f"💰 Сумма пополнения: <code>{amount}₽</code>\n"
        f"🧾 Чек: <code>#{receipt}</code>"
    )

tgbot >handlers>z_all_errors.py:
# - *- coding: utf- 8 - *-
from aiogram.types import Update

from tgbot.keyboards.inline_z_page import products_item_category_swipe_fp, products_item_position_swipe_fp
from tgbot.loader import dp
from tgbot.services.api_sqlite import get_categoryx, get_all_categoriesx, get_positionx, get_positionsx
from tgbot.utils.misc.bot_logging import bot_logger


# Обработка телеграм ошибок
@dp.errors_handler()
async def all_errors(update: Update, exception):
    get_data = None

    if (
        "'NoneType' object is not subscriptable" in str(exception)
        and "callback_query" in update
    ):
        get_data = update.callback_query.data

    if get_data is not None:
        split_data = get_data.split(":")

        if split_data[0] in ['buy_category_open']:
            get_category = get_categoryx(category_id=split_data[1])

            if get_category is None:
                get_categories = get_all_categoriesx()

                if len(get_categories) >= 1:
                    await update.callback_query.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                                                  reply_markup=products_item_category_swipe_fp(0))
                else:
                    await update.callback_query.message.edit_text(_("<b>🎁 Товары в данное время отсутствуют.</b>", locale=lang))
                await update.callback_query.answer(_("❗ Категория была изменена или удалена", locale=lang))
        elif split_data[0] in ['buy_position_open']:
            get_position = get_positionx(position_id=split_data[1])

            if get_position is None:
                get_positions = get_positionsx(category_id=split_data[3])

                if len(get_positions) >= 1:
                    await update.callback_query.message.edit_text(_("<b>🎁 Выберите нужный вам товар:</b>", locale=lang),
                                                                  reply_markup=products_item_position_swipe_fp(
                                                                      split_data[2], split_data[3]))
                else:
                    await update.callback_query.message.edit_text(_("<b>🎁 Товары в данное время отсутствуют.</b>", locale=lang))
                await update.callback_query.answer(_("❗ Позиция была изменена или удалена", locale=lang))
        elif split_data[0] in ['buy_item_select']:
            get_position = get_positionx(position_id=split_data[1])

            if get_position is None:
                await update.callback_query.message.edit_text(_("<b>🎁 Товары в данное время отсутствуют.</b>", locale=lang))
                await update.callback_query.answer(_("❗ Позиция была изменена или удалена", locale=lang))
    print(f"-Exception | {exception}")
    bot_logger.exception(
        f"Exception: {exception}\n"
        f"Update: {update}"
    )



tgbot >handlers>z_all_missed_.py:
# - *- coding: utf- 8 - *-
from aiogram.dispatcher import FSMContext
from aiogram.types import CallbackQuery, Message

from tgbot.keyboards.reply_z_all import menu_frep
from tgbot.loader import dp


# Колбэк с удалением сообщения
@dp.callback_query_handler(text="close_this", state="*")
async def missed_callback_close(call: CallbackQuery, state: FSMContext):
    await call.message.delete()


# Колбэк с обработкой кнопки
@dp.callback_query_handler(text="...", state="*")
async def missed_callback_answer(call: CallbackQuery, state: FSMContext):
    await call.answer(cache_time=60)

  
# Обработка всех колбэков которые потеряли стейты после перезапуска скрипта
@dp.callback_query_handler(state="*")
async def missed_callback(call: CallbackQuery, state: FSMContext):
    try:
        await call.message.delete()
    except Exception:
        pass

    await call.message.answer(_("<b>❌ Данные не были найдены из-за перезапуска скрипта.\n"
                              "♻ Выполните действие заново.</b>", locale=lang),
                              reply_markup=menu_frep(call.from_user.id, lang))

# Обработка всех неизвестных команд
@dp.message_handler()
async def missed_message(message: Message):
    await message.answer(_("♦ Неизвестная команда.\n"
                         "▶ Введите /start", locale=lang))


tgbot >keyboards
tgbot >keyboards>__pycache__
tgbot >keyboards>__init__.py:
empty

tgbot >keyboards>inline_admin.py:
# - *- coding: utf- 8 - *-
import gettext
from pathlib import Path
from contextvars import ContextVar
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton as ikb

from tgbot.services.api_sqlite import get_paymentx, get_settingsx, get_userx, update_settingsx, get_upaymentx, get_upaycount, create_upayments_row, get_places_in_cityx
from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR

from tgbot.middlewares.i18n import I18nMiddleware
i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)

print(i18n)
_ = i18n.gettext

# Поиск профиля
def select_place_finl(city_id):
    remover = 0
    get_places = get_places_in_cityx(city_id)
    keyboard = InlineKeyboardMarkup()

    for count, a in enumerate(range(remover, len(get_places))):
        print(get_places[a]['place_id'])
        if count < 10:
            keyboard.add(ikb(get_places[a]['name'],
                            callback_data=f"here_event_place:{get_places[a]['place_id']}"))

    return keyboard

# Поиск профиля
def profile_search_finl(user_id, lang):
    if lang == "en":
        chbbtn = "💰 Change Balance"
        tbbtn = "💰 Charge Balance"
        bbtn = "🎁 Purchaces"
        sbtn = "💌 Send Message To User"
        rebtn = "🔄 Refresh"
    if lang == "ru":
        chbbtn = "💰 Изменить баланс"
        tbbtn = "💰 Выдать баланс"
        bbtn = "🎁 Покупки"
        sbtn = "💌 Отправить сообщение пользователю"
        rebtn = "🔄 Обновить"

    return (
        InlineKeyboardMarkup()
        .add(
            ikb(
                chbbtn,
                callback_data=f"admin_user_balance_set:{user_id}",
            ),
            ikb(
                tbbtn,
                callback_data=f"admin_user_balance_add:{user_id}",
            ),
        )
        .add(
            ikb(
                bbtn,
                callback_data=f"admin_user_purchases:{user_id}",
            ),
            ikb(
                sbtn,
                callback_data=f"admin_user_message:{user_id}",
            ),
        )
        .add(
            ikb(
                rebtn,
                callback_data=f"admin_user_refresh:{user_id}",
            )
        )
    )


# Поиск профиля с запросом на продавца
def profile_search_reqs_finl(user_id, lang):
    if lang == "ru":
        submbtn = "Подтвердить"
        declbtn = "Отклонить"
        delbtn = "Удалить"
    if lang == "en":
        submbtn = "Submit"
        declbtn = "Decline"
        delbtn = "Delete"

    return InlineKeyboardMarkup().add(
        ikb(submbtn, callback_data=f"admin_user_request_approve:{user_id}"),
        ikb(declbtn, callback_data=f"admin_user_request_decline:{user_id}"),
        ikb(delbtn, callback_data=f"admin_user_request_delete:{user_id}"),
    )


# Способы пополнения
def payment_choice_finl(user_id, lang):
    keyboard = InlineKeyboardMarkup()
    print("inline_admin")
    print(user_id)
    print(lang)
    count = get_upaycount(user_id)
    print(count['paycount'])
    if count['paycount'] == 0:
        cur = create_upayments_row(user_id)
    else:
        get_payments = get_upaymentx(user_id)

    print(get_payments)
    if lang == "en":
        byqwformbtn = "📋 By QIWI Form"
        byqwphonebtn = "📞 By QIWI Number"
        byqwnickbtn = "Ⓜ By Nickname"
        byyoobtn = "📋 By Yoo Form"
        byfreereqs = "📋 By Free Data"
        bycbbtn = "Coinbase"
    if lang == "ru":
        byqwformbtn = "📋 По QIWI форме"
        byqwphonebtn = "📞 По QIWI номеру"
        byqwnickbtn = "Ⓜ По Никнейму"
        byyoobtn = "📋 По Yoo форме"
        byfreereqs = "📋 Свободные реквизиты"
        bycbbtn = "Coinbase"

    status_form_kb = ikb("✅", callback_data=f"change_payment:Form:False:{user_id}")
    status_number_kb = ikb("✅", callback_data=f"change_payment:Number:False:{user_id}")
    status_nickname_kb = ikb("✅", callback_data=f"change_payment:Nickname:False:{user_id}")
    status_formy_kb = ikb("✅", callback_data=f"change_payment:ForYm:False:{user_id}")
    status_freecredi_kb = ikb("✅", callback_data=f"change_payment:FreeCredi:False:{user_id}")
    status_coinbase_kb = ikb("✅", callback_data=f"change_payment:CoinBase:False:{user_id}")

    if get_payments['way_form'] == "False":
        status_form_kb = ikb("❌", callback_data=f"change_payment:Form:True:{user_id}")
    if get_payments['way_number'] == "False":
        status_number_kb = ikb("❌", callback_data=f"change_payment:Number:True:{user_id}")
    if get_payments['way_nickname'] == "False":
        status_nickname_kb = ikb("❌", callback_data=f"change_payment:Nickname:True:{user_id}")
    if get_payments['way_formy'] == "False":
        status_formy_kb = ikb("❌", callback_data=f"change_payment:ForYm:True:{user_id}")
    if get_payments['way_freecredi'] == "False":
        status_freecredi_kb = ikb("❌", callback_data=f"change_payment:FreeCredi:True:{user_id}")
    if get_payments['way_coinbase'] == "False":
        status_coinbase_kb = ikb("❌", callback_data=f"change_payment:CoinBase:True:{user_id}")

    keyboard.add(ikb(byqwformbtn, url="https://vk.cc/bYjKGM"), status_form_kb)
    keyboard.add(ikb(byqwphonebtn, url="https://vk.cc/bYjKEy"), status_number_kb)
    keyboard.add(ikb(byqwnickbtn, url="https://vk.cc/c8s66X"), status_nickname_kb)
    keyboard.add(ikb(byyoobtn, url="https://vk.cc/bYjKGM"), status_formy_kb)
    keyboard.add(ikb(byfreereqs, url="https://vk.cc/bYjKGM"), status_freecredi_kb)
    keyboard.add(ikb(bycbbtn, url="https://vk.cc/bYjKGM"), status_coinbase_kb)

    return keyboard


# Кнопки с настройками
def settings_open_finl(lang):
    keyboard = InlineKeyboardMarkup()
    get_settings = get_settingsx()
    if lang == "ru":
        settingnotexists = "❌ Не установлено"
        settingexist = "✅ Установлено"
        typenotset = "❌ Тип не задан"
        typeset = "✅:"
        faq = "ℹ FAQ"
        support = "☎ Поддержка"
        tradetype = "☎ Тип площадки"

    if lang == "en":
        settingnotexists = "❌ Empty"
        settingexist = "✅ Exist"
        typenotset = "❌ Platform Type"
        typeset = "✅:"
        faq = "ℹ FAQ"
        support = "☎ Support"
        tradetype = "☎ Platform type"

    if get_settings['misc_support'].isdigit():
        get_user = get_userx(user_id=get_settings['misc_support'])

        if get_user is not None:
            support_kb = ikb(f"@{get_user['user_login']} ✅", callback_data="settings_edit_support")
        else:
            support_kb = ikb(settingnotexists, callback_data="settings_edit_support")
            update_settingsx(misc_support="None")
    else:
        support_kb = ikb(settingexist, callback_data="settings_edit_support")

    if get_settings['misc_faq'] == "None":
        faq_kb = ikb(settingnotexists, callback_data="settings_edit_faq")
    else:
        faq_kb = ikb(settingexist, callback_data="settings_edit_faq")

    if get_settings['type_trade'] is None:
        trade_type_kb = ikb(typenotset, callback_data="settings_edit_trade_type")
    else:
        trade_type_kb = ikb(typeset + str(get_settings['type_trade']), callback_data="settings_edit_type_trade")

    keyboard.add(
        ikb(faq, callback_data="..."), faq_kb
    ).add(
        ikb(support, callback_data="..."), support_kb
    ).add(
        ikb(tradetype, callback_data="..."), trade_type_kb
    )

    return keyboard


# Выключатели
def turn_open_finl(lang):
    keyboard = InlineKeyboardMarkup()
    get_settings = get_settingsx()
    if lang == "ru":
        son = "Включены ✅"
        soff = "Выключены ❌"
        twork = "⛔ Тех. работы"
        tadd = "💰 Пополнения"
        tpays = "🎁 Покупки"

    if lang == "en":
        son = "On ✅"
        soff = "Off ❌"
        twork = "⛔ Tech. Works"
        tadd = "💰 Payments"
        tpays = "🎁 Purchases"

    if get_settings['status_buy'] == "True":
        status_buy_kb = ikb(son, callback_data="turn_buy:False")
    elif get_settings['status_buy'] == "False":
        status_buy_kb = ikb(soff, callback_data="turn_buy:True")

    if get_settings['status_work'] == "True":
        status_twork_kb = ikb(son, callback_data="turn_twork:False")
    elif get_settings['status_work'] == "False":
        status_twork_kb = ikb(soff, callback_data="turn_twork:True")

    if get_settings['status_refill'] == "True":
        status_pay_kb = ikb(son, callback_data="turn_pay:False")
    else:
        status_pay_kb = ikb(soff, callback_data="turn_pay:True")

    keyboard.row(ikb(twork, callback_data="..."), status_twork_kb)
    keyboard.row(ikb(tadd, callback_data="..."), status_pay_kb)
    keyboard.row(ikb(tpays, callback_data="..."), status_buy_kb)

    return keyboard

######################################## МАГАЗИНЫ ########################################
# Изменение магазина
def shop_name_edit_open_finl(shop_id, user_id, remover, lang):
    if lang == "ru":
        ebtn = "🏷 Изм. название"
        dbtn = "❌ Удалить"
        bbtn = "⬅ Вернуться ↩"
    if lang == "en":
        ebtn = "🏷 Change Name"
        dbtn = "❌ Delete"
        bbtn = "⬅ Back Up ↩"

    return (
        InlineKeyboardMarkup()
            .add(
            ikb(
                ebtn,
                callback_data=f"shop_edit_name:{category_id}:{remover}",
            ),
            ikb(
                dbtn,
                callback_data=f"shop_edit_delete:{category_id}:{remover}",
            ),
        )
            .add(
            ikb(
                bbtn,
                callback_data=f"shop_edit_return:{remover}",
            )
        )
    )

# Изменение магазина
def shop_description_edit_open_finl(shop_id, user_id, remover, lang):
    if lang == "ru":
        ebtn = "🏷 Изм. описание"
        dbtn = "❌ Удалить"
        bbtn = "⬅ Вернуться ↩"
    if lang == "en":
        ebtn = "🏷 Change Name"
        dbtn = "❌ Delete"
        bbtn = "⬅ Back Up ↩"

    return (
        InlineKeyboardMarkup()
            .add(
            ikb(
                ebtn,
                callback_data=f"shop_edit_description:{category_id}:{remover}",
            ),
            ikb(
                dbtn,
                callback_data=f"shop_edit_delete:{category_id}:{remover}",
            ),
        )
            .add(
            ikb(
                bbtn,
                callback_data=f"shop_edit_return:{remover}",
            )
        )
    )
######################################## ТОВАРЫ ########################################
# Изменение категории
def category_edit_open_finl(category_id, remover, lang):
    if lang == "ru":
        ebtn = "🏷 Изм. название"
        dbtn = "❌ Удалить"
        bbtn = "⬅ Вернуться ↩"
    if lang == "en":
        ebtn = "🏷 Change Name"
        dbtn = "❌ Delete"
        bbtn = "⬅ Back Up ↩"

    return (
        InlineKeyboardMarkup()
        .add(
            ikb(
                ebtn,
                callback_data=f"category_edit_name:{category_id}:{remover}",
            ),
            ikb(
                dbtn,
                callback_data=f"category_edit_delete:{category_id}:{remover}",
            ),
        )
        .add(
            ikb(
                bbtn,
                callback_data=f"category_edit_return:{remover}",
            )
        )
    )

# Кнопки с удалением категории
def category_edit_delete_finl(category_id, remover, lang):
    if lang == "ru":
        dbtn = "❌ Да, удалить"
        cbtn = "✅ Нет, отменить"

    if lang == "en":
        dbtn = "❌ Yes, Delete Please"
        cbtn = "✅ No, Cancel Please"

    return InlineKeyboardMarkup().add(
        ikb(
            dbtn,
            callback_data=f"category_delete:{category_id}:yes:{remover}",
        ),
        ikb(
            cbtn,
            callback_data=f"category_delete:{category_id}:not:{remover}",
        ),
    )

# Кнопки с удалением категории
def shop_edit_delete_finl2(shop_id, remover, lang):
    if lang == "ru":
        yesbtn = "❌ Да, удалить"
        nobtn =  "✅ Нет, отменить"
    if lang == "en":
        yesbtn = "❌ Да, удалить"
        nobtn =  "✅ Нет, отменить"

    return InlineKeyboardMarkup().add(
        ikb(
            yesbtn,
            callback_data=f"shop_delete:{shop_id}:yes:{remover}",
        ),
        ikb(
            nobtn,
            callback_data=f"shop_delete:{shop_id}:not:{remover}",
        ),
    )

# Кнопки при открытии позиции для изменения
def position_edit_open_finl(position_id, category_id, remover, lang):
    print(lang)
    if lang == "ru":
        chnbtn = "🏷 Изм. название"
        chpbtn = "💰 Изм. цену"
        chdbtn = "📜 Изм. описание"
        chphbtn = "📸 Изм. фото"
        chrbtn = "📜 Изменить остаток"
        chlbtn = "📸 <---<ВП>-->"
        chcbtn = "🏙 Изм. город"
        chsbtn = "🏙 Изм. магазин"
        chclbtn = "🗑 Очистить"
        agbtn = "🎁 Добавить товары"
        prsbtn = "📥 Товары"
        delbtn = "❌ Удалить"
        backbtn = "⬅ Вернуться ↩"
    if lang == "en":
        chnbtn = "🏷 Edit Name"
        chpbtn = "💰 Edit Price"
        chdbtn = "📜 Edit Description"
        chphbtn = "📸 Edit Photo"
        chrbtn = "📜 Edit Rest"
        chlbtn = "📸 <---<ВП>-->"
        chcbtn = "🏙 Edit City"
        chsbtn = "🏙 Edit Shop"
        chclbtn = "🗑 Clear"
        agbtn = "🎁 Add Goods"
        prsbtn = "📥 Goods"
        delbtn = "❌ Delete"
        backbtn = "⬅ Back ↩"

    return (
        InlineKeyboardMarkup()
        .add(
            ikb(
                chnbtn,
                callback_data=f"position_edit_name:{position_id}:{category_id}:{remover}",
            ),
            ikb(
                chpbtn,
                callback_data=f"position_edit_price:{position_id}:{category_id}:{remover}",
            ),
        )
        .add(
            ikb(
                chdbtn,
                callback_data=f"position_edit_description:{position_id}:{category_id}:{remover}",
            ),
            ikb(
                chphbtn,
                callback_data=f"position_edit_photo:{position_id}:{category_id}:{remover}",
            ),
            # добавил 12.08.22    -----------------------------------------------------------
        )
        .add(
            ikb(
                chrbtn,
                callback_data=f"position_edit_rest:{position_id}:{category_id}:{remover}",
            ),
            ikb(
                chlbtn,
                callback_data=f"position_edit_photo:{position_id}:{category_id}:{remover}",
            ),
            # добавил 1.02.23    -----------------------------------------------------------
        )
        .add(
            ikb(
                chcbtn,
                callback_data=f"position_edit_city:{position_id}:{category_id}:{remover}",
            ),
            ikb(
                chsbtn,
                callback_data=f"position_edit_shop:{position_id}:{category_id}:{remover}",
            ),
            # -------------------------------------------------------------------------
        )
        .add(
            ikb(
                chclbtn,
                callback_data=f"position_edit_clear:{position_id}:{category_id}:{remover}",
            ),
            ikb(
                agbtn,
                callback_data=f"products_add_position:{position_id}:{category_id}",
            ),
        )
        .add(
            ikb(
                prsbtn,
                callback_data=f"position_edit_items:{position_id}:{category_id}:{remover}",
            ),
            ikb(
                delbtn,
                callback_data=f"position_edit_delete:{position_id}:{category_id}:{remover}",
            ),
        )
        .add(
            ikb(
                backbtn,
                callback_data=f"position_edit_return:{category_id}:{remover}",
            ),
        )
    )


# Кнопки при открытии позиции для изменения
def artist_edit_open_finl(artist_id, user_id, remover):
    return (
        InlineKeyboardMarkup()
        .add(
            ikb(
                _("🏷 Изм. название", locale=lang),
                callback_data=f"artist_edit_name:{artist_id}:{user_id}:{remover}",
            ),
            ikb(
                _("🏙 Изм. город", locale=lang),
                callback_data=f"artist_edit_city:{artist_id}:{user_id}:{remover}",
            ),
        )
        .add(
            ikb(
                _("📜 Изм. описание", locale=lang),
                callback_data=f"artist_edit_description:{artist_id}:{user_id}:{remover}",
            ),
            ikb(
                _("📸 Изм. фото", locale=lang),
                callback_data=f"artist_edit_photo:{artist_id}:{user_id}:{remover}",
            ),
            # -------------------------------------------------------------------------
        )
        .add(
            ikb(
                _("🗑 Очистить", locale=lang),
                callback_data=f"artist_edit_clear:{artist_id}:{user_id}:{remover}",
            ),
            ikb(
                _("❌ Удалить", locale=lang),
                callback_data=f"artist_edit_delete:{artist_id}:{user_id}:{remover}",
            ),
        )
        .add(
            ikb(
                _("⬅ Вернуться ↩", locale=lang),
                callback_data=f"artist_edit_return:{user_id}:{remover}",
            ),
        )
    )

# Подтверждение удаления позиции
def artist_edit_delete_finl():
    return InlineKeyboardMarkup().add(
        ikb(
            _("❌ Да, удалить", locale=lang),
            callback_data=f"artist_delete:yes:{position_id}:{category_id}:{remover}",
        ),
        ikb(
            _("✅ Нет, отменить", locale=lang),
            callback_data=f"artist_delete:not:{position_id}:{category_id}:{remover}",
        ),
    )


# Подтверждение удаления позиции
def position_edit_delete_finl(position_id, category_id, remover, lang):
    if lang == "ru":
        dbtn = "❌ Да, удалить"
        cbtn = "✅ Нет, отменить"
    if lang == "en":
        dbtn = "❌ Yes, Delete"
        cbtn = "✅ No, Cancel"

    return InlineKeyboardMarkup().add(
        ikb(
            dbtn,
            callback_data=f"position_delete:yes:{position_id}:{category_id}:{remover}",
        ),
        ikb(
            cbtn,
            callback_data=f"position_delete:not:{position_id}:{category_id}:{remover}",
        ),
    )


# Подтверждение очистики позиции
def position_edit_clear_finl(position_id, category_id, remover, lang):
    if lang == "ru":
        clbtn = "❌ Да, очистить"
        ccbtn = "✅ Нет, отменить"
    if lang == "en":
        clbtn = "❌ Yes, Clear"
        ccbtn = "✅ No, Cancel"

    return InlineKeyboardMarkup().add(
        ikb(
            clbtn,
            callback_data=f"position_clear:yes:{position_id}:{category_id}:{remover}",
        ),
        ikb(
            ccbtn,
            callback_data=f"position_clear:not:{position_id}:{category_id}:{remover}",
        ),
    )

# Кнопки при открытии позиции для изменения
def shop_edit_open_finl(shop_id, remover, user_id, lang):
    if lang == "ru":
        chnbtn = "Изменить название"
        chpbtn = "💰 Изм. цену"
        chdbtn = "📜 Изм. описание"
        chfbtn = "📸 Изм. фото"
        chcbtn = "🏙 Изм. город"
        delntn = "❌ Удалить"
        bbbtn = "Вернуться"
    if lang == "en":
        chnbtn = "Change name"
        chpbtn = "💰 Change price"
        chdbtn = "📜 Change description"
        chfbtn = "📸 Change photo"
        chcbtn = "🏙 Change city"
        delntn = "❌ Delete"
        bbbtn = "Back"

    return (
        InlineKeyboardMarkup()
        .add(
            ikb(
                chnbtn,
                callback_data=f"shop_edit_name:{shop_id}:{user_id}:{remover}",
            ),
            ikb(
                chpbtn,
                callback_data=f"shop_edit_price:{shop_id}:{user_id}:{remover}",
            ),
        )
        .add(
            ikb(
                chdbtn,
                callback_data=f"shop_edit_description:{shop_id}:{user_id}:{remover}",
            ),
            ikb(
                chfbtn,
                callback_data=f"shop_edit_photo:{shop_id}:{user_id}:{remover}",
            ),
            # добавил 12.08.22    -----------------------------------------------------------
        )
        .add(
            ikb(
                chcbtn,
                callback_data=f"shop_edit_city:{shop_id}:{user_id}:{remover}",
            ),
            ikb(
                "Для симметрии",
                callback_data=f"shop____edit_photo:{shop_id}:{user_id}:{remover}",
            ),
            # -------------------------------------------------------------------------
        )
        .add(
            ikb(
                "X🗑 Очистить",
                callback_data=f"shop_edit_clear:{shop_id}:{user_id}:{remover}",
            ),
            ikb(
                "X🎁 Добавить товары",
                callback_data=f"shop_add_position:{shop_id}:{user_id}",
            ),
        )
        .add(
            # ikb(_("📥 Товары", locale=lang), callback_data=f"shop_edit_items:{shop_id}:{user_id}:{remover}"),
            ikb(
                delntn,
                callback_data=f"shop_edit_delete:{shop_id}:{user_id}:{remover}",
            ),
        )
        .add(
            ikb(
                bbbtn,
                callback_data=f"shop_edit_return:{user_id}:{remover}",
            ),
        )
    )

# Подтверждение покупки товара
def shop_edit_delete_finl(shop_id, user_id, lang):
    if lang == "ru":
        yesbtn = "✅ Да, удалить"
        nobtn = "❌ Отменить удаление"
    if lang == "en":
        yesbtn = "✅ Yes, delete"
        nobtn = "❌ Cancel Delete"

    return InlineKeyboardMarkup().add(
        ikb(yesbtn, callback_data=f"shop_delete:yes:{shop_id}:{user_id}"),
        ikb(nobtn, callback_data=f"shop_delete:not:{shop_id}:{user_id}"),
    )


tgbot >keyboards>inline_user copy.py:
# - *- coding: utf- 8 - *-
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

from tgbot.services.api_sqlite import get_paymentx


# Выбор способов пополнения
def refill_choice_finl():
    keyboard = InlineKeyboardMarkup()

    get_payments = get_paymentx()
    active_kb = []

    if get_payments['way_form'] == "True":
        active_kb.append(InlineKeyboardButton("📋 QIWI форма", callback_data="refill_choice:Form"))
    if get_payments['way_number'] == "True":
        active_kb.append(InlineKeyboardButton("📞 QIWI номер", callback_data="refill_choice:Number"))
    if get_payments['way_nickname'] == "True":
        active_kb.append(InlineKeyboardButton("Ⓜ QIWI никнейм", callback_data="refill_choice:Nickname"))

    if len(active_kb) == 3:
        keyboard.add(active_kb[0], active_kb[1])
        keyboard.add(active_kb[2])
    elif len(active_kb) == 2:
        keyboard.add(active_kb[0], active_kb[1])
    elif len(active_kb) == 1:
        keyboard.add(active_kb[0])
    else:
        keyboard = None

    if active_kb:
        keyboard.add(InlineKeyboardButton("⬅ Вернуться ↩", callback_data="user_profile"))

    return keyboard

# Проверка киви платежа
def refill_bill_finl(send_requests, get_receipt, get_way):
    return (
        InlineKeyboardMarkup()
        .add(InlineKeyboardButton("🌀 Перейти к оплате", url=send_requests))
        .add(
            InlineKeyboardButton(
                "🔄 Проверить оплату",
                callback_data=f"Pay:{get_way}:{get_receipt}",
            )
        )
    )


# Кнопки при открытии самого товара
def products_open_finl(position_id, remover, category_id):
    return (
        InlineKeyboardMarkup()
        .add(
            InlineKeyboardButton(
                "💰 Купить товар",
                callback_data=f"buy_item_select:{position_id}",
            )
        )
        .add(
            InlineKeyboardButton(
                "⬅ Вернуться ↩",
                callback_data=f"buy_position_return:{remover}:{category_id}",
            )
        )
    )

# Способы пополнения
def payment_as_choice_finl():
    keyboard = InlineKeyboardMarkup()
    get_payments = get_paymentx()

    if get_payments['way_form'] == "True":
        status_form_kb = InlineKeyboardButton("✅", callback_data="change_payment:Form:False")
    else:
        status_form_kb = InlineKeyboardButton("❌", callback_data="change_payment:Form:True")

    if get_payments['way_number'] == "True":
        status_number_kb = InlineKeyboardButton("✅", callback_data="change_payment:Number:False")
    else:
        status_number_kb = InlineKeyboardButton("❌", callback_data="change_payment:Number:True")

    if get_payments['way_nickname'] == "True":
        status_nickname_kb = InlineKeyboardButton("✅", callback_data="change_payment:Nickname:False")
    else:
        status_nickname_kb = InlineKeyboardButton("❌", callback_data="change_payment:Nickname:True")

    keyboard.add(InlineKeyboardButton("📋 По форме", url="https://vk.cc/bYjKGM"), status_form_kb)
    keyboard.add(InlineKeyboardButton("📞 По номеру", url="https://vk.cc/bYjKEy"), status_number_kb)
    keyboard.add(InlineKeyboardButton("Ⓜ По никнейму", url="https://vk.cc/c8s66X"), status_nickname_kb)

    return keyboard

    

# Подтверждение покупки товара
def products_confirm_finl(position_id, get_count):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            "✅ Подтвердить",
            callback_data=f"xbuy_item:yes:{position_id}:{get_count}",
        ),
        InlineKeyboardButton(
            "❌ Отменить",
            callback_data=f"xbuy_item:not:{position_id}:{get_count}",
        ),
    )


# Ссылка на поддержку
def user_support_finl(user_name):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            "💌 Написать в поддержку", url=f"https://t.me/{user_name}"
        ),
    )


tgbot >keyboards>inline_user.py:
# - *- coding: utf- 8 - *-
import gettext
from pathlib import Path
from contextvars import ContextVar

from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

from tgbot.services.api_sqlite import get_paymentx, get_upaymentx, get_upaycount, create_upayments_row

from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR

from tgbot.middlewares.i18n import I18nMiddleware
i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)

print(i18n)
_ = i18n.gettext

# Кнопки при поиске профиля через админ-меню
def refill_open_finl(lang):
    keyboard = InlineKeyboardMarkup()

    k1 = InlineKeyboardButton(_("💰 Пополнить", locale=lang), callback_data="user_refill")
    keyboard.insert(k1)

    return keyboard

def profile_open_finl(lang):
    print(lang)
    print("buyerway")
    keyboard = InlineKeyboardMarkup()
    if lang == "ru":
        print("rumenu")
        topupbtn = "💰 Пополнить"
        mybuyes = "🎁 Мои покупки"
        pcbtn = "➰ Ввести промокод"
        chcbtn = "📡 Изменить город"
    if lang == "en":
        print("engmenu")
        topupbtn = "💰 Top Up"
        mybuyes = "🎁 My Purchases"
        pcbtn = "➰ Enter Promocode"
        chcbtn = "📡 Change City"

    k1 = InlineKeyboardButton(topupbtn, callback_data="user_refill"),
    k2 = InlineKeyboardButton(mybuyes, callback_data="user_history"),
    k3 = InlineKeyboardButton(pcbtn, callback_data="enter_promocode"),
    k4 = InlineKeyboardButton(chcbtn, callback_data="edit_location")
    keyboard.insert(k1)
    keyboard.insert(k2)
    keyboard.insert(k3)
    keyboard.insert(k4)

    return keyboard

def profile_seller_open_finl(lang):
    print(lang)
    print("sellway")
    keyboard = InlineKeyboardMarkup()
    if lang == 'ru':
        print("rumenu")
        topupbtn = "💰 Пополнить"
        mybuyes = "🎁 Мои покупки"
        pcbtn = "➰ Ввести промокод"
        chcbtn = "📡 Изменить город"
        chsdbtn = "🚛 Изменить настройки доставки"
        print("rumenu2")
    if lang == 'en':
        print("engmenu")
        topupbtn = "💰 Top Up"
        mybuyes = "🎁 My Purchases"
        pcbtn = "➰ Enter Promocode"
        chcbtn = "📡 Change City"
        chsdbtn = "🚛 Change Delivery Settings"

    print("rumenu3")
    k1 = InlineKeyboardButton(topupbtn, callback_data="user_refill"),
    k2 = InlineKeyboardButton(mybuyes, callback_data="user_history"),
    k3 = InlineKeyboardButton(pcbtn, callback_data="enter_promocode"),
    k4 = InlineKeyboardButton(chcbtn, callback_data="edit_locatoin"),
    k5 = InlineKeyboardButton(chsdbtn, callback_data="edit_delivery_settings")
    keyboard.insert(k1)
    keyboard.insert(k2)
    keyboard.insert(k3)
    keyboard.insert(k4)
    keyboard.insert(k5)
    print("rumenu4")

    return keyboard

# Проверка киви платежа
def confirm_cart_del_finl(order_id):
    keyboard = InlineKeyboardMarkup()

    k1 = InlineKeyboardButton(_("Да, удалите", locale=lang), callback_data="confirm_del_user_cart:{order_id}")
    k2 = InlineKeyboardButton(_("Нет, вернуться в корзину", locale=lang), callback_data="user_cart")
    keyboard.insert(k1)
    keyboard.insert(k2)

    return keyboard

# Проверка киви платежа
def lang_menu_finl(lang):
    keyboard = InlineKeyboardMarkup()
    if lang == "ru":
        rubtn = "🇷🇺 Русский"
        enbtn = "🇬🇧 Английский"
    if lang == "en":
        rubtn = "🇷🇺 Russian"
        enbtn = "🇬🇧 English"

    k1 = InlineKeyboardButton(rubtn, callback_data="lang:ru")
    k2 = InlineKeyboardButton(enbtn, callback_data="lang:en")
    keyboard.insert(k1)
    keyboard.insert(k2)

    return keyboard

def lang_menu_ext_finl():
    keyboard = InlineKeyboardMarkup()

    k1 = InlineKeyboardButton("🇷🇺 Русский", callback_data="lang:ru")
    k2 = InlineKeyboardButton("🇬🇧 English", callback_data="lang:en")
    k3 = InlineKeyboardButton("Продолжить", callback_data="continue")
    keyboard.insert(k1)
    keyboard.insert(k2)
    keyboard.insert(k3)

    return keyboard

# Проверка киви платежа
def lang_menu_finl2():
    keyboard = InlineKeyboardMarkup()
    ak = [InlineKeyboardButton("🇷🇺 Русский", callback_data="lang_ru")]
    ak.append(InlineKeyboardButton("🇬🇧 English", callback_data="lang_en"))
    keyboard.add(ak[0], ak[1])

    return keyboard

# Выбор способов пополнения
def refill_choice_finl(lang): #lang
    keyboard = InlineKeyboardMarkup()

    #print(lang)
    print(":::")
    get_payments = get_paymentx()
    print(get_payments)

    #currencies = ['USDT', 'BUSD', 'USDC', 'BTC', 'ETH', 'TON', 'BNB']
    currencies = ["USDT", "BUSD", "USDC", "BTC", "ETH", "TON", "BNB"]
    active_kb = []

    if get_payments['way_form'] == "True":
        active_kb.append(InlineKeyboardButton(_("📋 QIWI форма", locale=lang), callback_data="refill_choice:Form"))
    if get_payments['way_number'] == "True":
        active_kb.append(InlineKeyboardButton(_("📞 QIWI номер", locale=lang), callback_data="refill_choice:Number"))
    if get_payments['way_nickname'] == "True":
        active_kb.append(InlineKeyboardButton(_("Ⓜ QIWI никнейм", locale=lang), callback_data="refill_choice:Nickname"))
    if get_payments['way_formy'] == "True":
        active_kb.append(InlineKeyboardButton(_("📋 Yoo форма", locale=lang), callback_data="refill_choice:ForYm"))
    if get_payments['way_coinbase'] == "True":
        active_kb.append(InlineKeyboardButton("USDT", callback_data="refill_choice:Tron:USDT"))
        active_kb.append(InlineKeyboardButton("TRX", callback_data="refill_choice:Tron:TRX"))
        active_kb.append(InlineKeyboardButton("BTC BEP20", callback_data="refill_choice:BTCB"))

    if len(active_kb) == 9:
        keyboard.add(active_kb[0], active_kb[1])
        keyboard.add(active_kb[2], active_kb[3])
        keyboard.add(active_kb[4], active_kb[5])
        keyboard.add(active_kb[6], active_kb[7])
        keyboard.add(active_kb[8])
    if len(active_kb) == 8:
        keyboard.add(active_kb[0], active_kb[1])
        keyboard.add(active_kb[2], active_kb[3])
        keyboard.add(active_kb[4], active_kb[5])
        keyboard.add(active_kb[6], active_kb[7])
    if len(active_kb) == 7:
        keyboard.add(active_kb[0], active_kb[1])
        keyboard.add(active_kb[2], active_kb[3])
        keyboard.add(active_kb[4], active_kb[5])
        keyboard.add(active_kb[6])
    if len(active_kb) == 6:
        keyboard.add(active_kb[0], active_kb[1])
        keyboard.add(active_kb[2], active_kb[3])
        keyboard.add(active_kb[4], active_kb[5])
    if len(active_kb) == 5:
        keyboard.add(active_kb[0], active_kb[1])
        keyboard.add(active_kb[2], active_kb[3])
        keyboard.add(active_kb[4])
    elif len(active_kb) == 4:
        keyboard.add(active_kb[0], active_kb[1])
        keyboard.add(active_kb[2], active_kb[3])
    elif len(active_kb) == 3:
        keyboard.add(active_kb[0], active_kb[1])
        keyboard.add(active_kb[2])
    elif len(active_kb) == 2:
        keyboard.add(active_kb[0], active_kb[1])
    elif len(active_kb) == 1:
        keyboard.add(active_kb[0])
    else:
        keyboard = None

    if active_kb:
        keyboard.add(InlineKeyboardButton("⬅ Вернуться в профиль ↩", callback_data="user_profile"))
        keyboard.add(InlineKeyboardButton("⬅ Вернуться в корзину ↩", callback_data="user_cart"))

    return keyboard


# Проверка киви платежа
def position_select_type_finl(lang):
    if lang == "ru":
        realbtn = "✅ Реальная"
        digibtn = "❌ Цифровая"
    if lang == "en":
        realbtn = "✅ Real"
        digibtn = "❌ Digital"

    return (
        InlineKeyboardMarkup()
        .add(
            InlineKeyboardButton(
                realbtn,
                callback_data="here_position_type:real",
            )
        )
        .add(
            InlineKeyboardButton(
                digibtn,
                callback_data="here_position_type:digital",
            )
        )
    )


# Проверка киви платежа
def open_deep_link_object_finl(object_id, category_id, remover, city_id):
    return (
        InlineKeyboardMarkup()
        .add(
            InlineKeyboardButton(
                _("✅ Открыть", locale=lang),
                callback_data=f"buy_position_open:{object_id}:{category_id}:{remover}:{city_id}",
            )
        )
        .add(
            InlineKeyboardButton(
                _("❌ Стартовать магазин", locale=lang), callback_data="start"
            )
        )
    )

# Проверка киви платежа
def refill_bill_crypto_finl(get_way, type_net, receipt, lang):
    print(get_way, type_net, receipt, lang)
    return (InlineKeyboardMarkup().add(
            InlineKeyboardButton(
                _("🔄 Проверить оплату", locale=lang), callback_data=f"Pay:{get_way}:{type_net}:{receipt}",
            )
        )
    )



# Проверка киви платежа
def refill_bill_finl(send_requests, get_receipt, get_way, lang):
    return (
        InlineKeyboardMarkup()
        .add(
            InlineKeyboardButton(
                _("🌀 Перейти к оплате", locale=lang), url=send_requests
            )
        )
        .add(
            InlineKeyboardButton(
                _("🔄 Проверить оплату", locale=lang),
                callback_data=f"Pay:{get_way}:{get_receipt}",
            )
        )
    )

# Поделиться телефоном
def give_number_inl():
    return InlineKeyboardMarkup().add(
        # InlineKeyboardButton("Поделиться номером", callback_data="enter_phone_auto")
        InlineKeyboardButton(
            _("Поделиться номером", locale=lang), request_contact=True
        )
    )

# Кнопки при открытии самого товара
def event_open_finl(event_id, remover, place_id, city_id, lang):
    keyboard = InlineKeyboardMarkup(
    ).add(
        InlineKeyboardButton(_("💰 Забронировать столик", locale=lang), callback_data=f"book_event_ticket:{event_id}")
    )
    if place_id != 0:
        keyboard.add(
        InlineKeyboardButton(_("⬅ Вернуться в место ↩", locale=lang), callback_data=f"book_place_open:{place_id}")     #callback_data=f"events_place_swipe:{remover}:{place_id}:{city_id}")
        )
    if city_id != 0:
        keyboard.add(
        InlineKeyboardButton(_("⬅ Вернуться в город ↩", locale=lang), callback_data=f"events_city_swipe:{remover}:{city_id}")
        )

    return keyboard

# Кнопки при открытии самого товара
def shop_creation_request_finl(lang):
    if lang == "ru":
        csbtn = "🏪 Создать магазин ➕"
        wscbtn = "Продолжить без создания магазина"
    if lang == "en":
        csbtn = "🏪 Create shop ➕"
        wscbtn = "Continue without shop creation"

    return (
        InlineKeyboardMarkup()
        .add(
            InlineKeyboardButton(
                csbtn, callback_data="product_shop_create"
            )
        )
        .add(
            InlineKeyboardButton(
                wscbtn,
                callback_data="here_position_addtoshop:NoCreate",
            )
        )
    )

# Кнопки при открытии самого товара
def edit_delivery_settings_finl():
    return (
        InlineKeyboardMarkup()
        .add(
            InlineKeyboardButton(
                _("⬅ Вернуться в профиль ↩", locale=lang),
                callback_data="user_profile",
            )
        )
        .add(
            InlineKeyboardButton(
                _("⬅ Ввести данные заново ↩", locale=lang),
                callback_data="edit_delivery_settings",
            )
        )
    )


# Кнопки при открытии самого товара c корзиной
def products_open_cart_finl2(position_id, remover, category_id):
    return (
        InlineKeyboardMarkup()
        .add(
            InlineKeyboardButton(
                _("🛒 Добавить в корзину", locale=lang),
                callback_data=f"add_item_cart:{position_id}",
            )
        )
        .add(
            InlineKeyboardButton(
                _("⬅ Вернуться ↩", locale=lang),
                callback_data=f"buy_position_return:{remover}:{category_id}",
            )
        )
    )

# Кнопки при открытии самого товара c корзиной
def products_open_finl(cart, position_id, remover, category_id, shop_id, lang):
    if lang == "ru":
        acbtn = "🛒 Добавить в корзину"
        bpbtn = "💰 Купить товар"
        bbtn = "⬅ Вернуться ↩"
    if lang == "en":
        acbtn = "🛒 Add to Cart"
        bpbtn = "💰 Buy Product"
        bbtn = "⬅ Back ↩"

    if cart == 1 and category_id != 0:
        keyboard = (
            InlineKeyboardMarkup()
            .add(
                InlineKeyboardButton(
                    acbtn,
                    callback_data=f"add_item_cart:{position_id}",
                )
            )
            .add(
                InlineKeyboardButton(
                    bbtn,
                    callback_data=f"buy_position_return:{remover}:{category_id}:0",
                )
            )
        )

    if cart == 1 and shop_id != 0:
        keyboard = (
            InlineKeyboardMarkup()
            .add(
                InlineKeyboardButton(
                    acbtn,
                    callback_data=f"add_item_cart:{position_id}",
                )
            )
            .add(
                InlineKeyboardButton(
                    bbtn,
                    callback_data=f"buy_position_return:{remover}:0:{shop_id}",
                )
            )
        )
    if cart == 0 and category_id != 0:
        keyboard = (
            InlineKeyboardMarkup()
            .add(
                InlineKeyboardButton(
                    bpbtn,
                    callback_data=f"buy_item_select:{position_id}",
                )
            )
            .add(
                InlineKeyboardButton(
                    bbtn,
                    callback_data=f"buy_position_return:{remover}:{category_id}:0",
                )
            )
        )
    if cart == 0 and shop_id != 0:
        keyboard = (
            InlineKeyboardMarkup()
            .add(
                InlineKeyboardButton(
                    bpbtn,
                    callback_data=f"buy_item_select:{position_id}",
                )
            )
            .add(
                InlineKeyboardButton(
                    bbtn,
                    callback_data=f"buy_position_return:{remover}:0:{shop_id}",
                )
            )
        )

    return keyboard

def switch_category_shop_finl():
    return (
        InlineKeyboardMarkup()
        .add(
            InlineKeyboardButton(
                _("🛒 Переключиться в категории", locale=lang),
                callback_data='products_item_category_open_fp:0:None',
            )
        )
        .add(
            InlineKeyboardButton(
                _("🛒 Переключиться в магазины", locale=lang),
                callback_data='products_item_shop_open_fp:0:None',
            )
        )
        .add(
            InlineKeyboardButton(
                _("⬅ Вернуться ↩", locale=lang),
                callback_data=f"buy_position_return:{remover}:{category_id}",
            )
        )
    )


# Возврат в профиль
def back_to_profile_finl(lang):
    return (
        InlineKeyboardMarkup()
            .add(
            InlineKeyboardButton(
                _("🌀 Вернуться в профиль", locale=lang),
                callback_data="user_profile",
            )
        )
    )

# Проверка киви платежа
def enter_promocode_finl():
    return (
        InlineKeyboardMarkup()
        .add(
            InlineKeyboardButton(
                _("🌀 Вернуться в профиль", locale=lang),
                callback_data="user_profile",
            )
        )
        .add(
            InlineKeyboardButton(
                _("🔄 Повторить ввод промокода", locale=lang),
                callback_data="enter_promocode",
            )
        )
    )

#).add(
#InlineKeyboardButton("💰 Купить товар", callback_data=f"buy_item_select:{position_id}")

def charge_button_add(anull):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            _("💰 Пополнить", locale=lang), callback_data="user_refill"
        )
    )

#просмотр корзины
# Открытие корзины
def cart_open_created_finl(order_id, lang):
    print(lang)
    print(":::")
    if lang == "ru":
        enad = "🏢 Ввести адрес"
        entph = "📱 Ввести телефон"
        shtph = "📱 Поделиться номером"
        pap = "   Оплата при получении"
        pthacc = "💰 Пополнить счет"
        doord = f" ! Оформить заказ{order_id}"
        delcart = "   Удалить корзину"
        askseller = "❓ Спросить продавца"
    if lang == "en":
        enad = "🏢 Enter address"
        entph = "📱 Enter phone"
        shtph = "📱 Share phone"
        pap = "   Pay after get"
        pthacc = "💰 Charge account"
        doord = f" ! Make order: {order_id}"
        delcart = "   Delete cart"
        askseller = "❓ Ask seller"

    return (
        InlineKeyboardMarkup()
        .add(
            InlineKeyboardButton(enad, callback_data="enter_address_manualy"),
            InlineKeyboardButton(entph, callback_data="enter_phone_manualy"),
            InlineKeyboardButton(shtph, callback_data="enter_phone_auto"),
        )
        .add(
            InlineKeyboardButton(pap, callback_data=f"pay_after_delivery:{order_id}"),
            InlineKeyboardButton(pthacc, callback_data="user_refill"),
            InlineKeyboardButton(doord, callback_data=f"checkout_start:{order_id}"),
        )
        .add(
            InlineKeyboardButton(delcart, callback_data=f"del_user_cart:{order_id}"),
            InlineKeyboardButton(askseller, callback_data="enter_message_manualy"),
        )
    )


# Подтверждение оформления заказа
def checkout_step2_accept_finl(order_id):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            _("✅ Да, оформить", locale=lang),
            callback_data=f"checkout_finish:{order_id}",
        ),
        InlineKeyboardButton(
            _("❌ Вернуться в Корзину", locale=lang), callback_data="user_cart"
        ),
    )

#корзина - заказ в статусе доставка
def cart_open_delivery_finl(order_id, lang):
    print(lang)
    print("III")
    if lang == "ru":
        subm = "📱 Подтвердить получение"
        askseller = "❓ Задать вопрос продавцу"
    if lang == "en":
        subm = "📱 Submit Receiption"
        askseller = "❓ Ask Seller"

    return (
        InlineKeyboardMarkup()
        .add(InlineKeyboardButton(subm, callback_data=f"submit_order:{order_id}"),)
        .add(InlineKeyboardButton(askseller, callback_data="enter_message_manualy"),)
    )

# Корзина - заказ для администратора площадки
def cart_open_admin_finl(order_id, lang):
    print(lang)
    if lang == "ru":
        enad = "🏢 Ввести адрес"
        entph = "📱 Ввести телефон"
        shtph = "📱 Поделиться номером"
        pap = "   Оплата при получении"
        pthacc = "💰 Пополнить счет"
        doord = f" ! Оформить заказ{order_id}"
        delcart = "   Удалить корзину"
        askseller = "❓ Спросить продавца"
    if lang == "en":
        enad = "🏢 Enter address"
        entph = "📱 Enter phone"
        shtph = "📱 Share phone"
        pap = "   Pay after get"
        pthacc = "💰 Charge account"
        doord = f" ! Make order: {order_id}"
        delcart = "   Delete cart"
        askseller = "❓ Ask seller"

    return (
        InlineKeyboardMarkup()
            .add(
            InlineKeyboardButton(enad, callback_data="enter_address_manualy"),
            InlineKeyboardButton(entph, callback_data="enter_phone_manualy"),
            InlineKeyboardButton(shtph, callback_data="enter_phone_auto"),
        )
            .add(
            InlineKeyboardButton(pap, callback_data=f"pay_after_delivery:{order_id}"),
            InlineKeyboardButton(pthacc, callback_data="user_refill"),
            InlineKeyboardButton(doord, callback_data=f"checkout_start:{order_id}"),
        )
            .add(
            InlineKeyboardButton(delcart, callback_data=f"del_user_cart:{order_id}"),
            InlineKeyboardButton(askseller, callback_data="enter_message_manualy"),
        )
    )


# Способы пополнения
def payment_as_choice_finl(user_id):
    keyboard = InlineKeyboardMarkup()
    print("|||||")
    print(user_id)
    print("inline_user")
    count = get_upaycount(user_id)
    print(count['paycount'])
    if count['paycount'] == 0:
        cur = create_upayments_row(user_id)
    else:
        get_payments = get_upaymentx(user_id)

    if get_payments['way_form'] == "True":
        status_form_kb = InlineKeyboardButton("✅", callback_data=f"change_payment:Form:False:{user_id}")
    else:
        status_form_kb = InlineKeyboardButton("❌", callback_data=f"change_payment:Number:False:{user_id}")

    if get_payments['way_number'] == "True":
        status_number_kb = InlineKeyboardButton("✅", callback_data=f"change_payment:Nickname:False:{user_id}")
    else:
        status_number_kb = InlineKeyboardButton("❌", callback_data=f"change_payment:ForYm:False:{user_id}")

    if get_payments['way_nickname'] == "True":
        status_nickname_kb = InlineKeyboardButton("✅", callback_data=f"change_payment:Form:True:{user_id}")
    else:
        status_nickname_kb = InlineKeyboardButton("❌", callback_data=f"change_payment:Number:True:{user_id}")

    if get_payments['way_formy'] == "True":
        status_formy_kb = InlineKeyboardButton("✅", callback_data=f"change_payment:Nickname:True:{user_id}")
    else:
        status_formy_kb = InlineKeyboardButton("❌", callback_data=f"change_payment:ForYm:True:{user_id}")

    keyboard.add(InlineKeyboardButton(_("📋 По форме", locale=lang), url="https://vk.cc/bYjKGM"), status_form_kb)
    keyboard.add(InlineKeyboardButton(_("📞 По номеру", locale=lang), url="https://vk.cc/bYjKEy"), status_number_kb)
    keyboard.add(InlineKeyboardButton(_("Ⓜ По никнейму", locale=lang), url="https://vk.cc/c8s66X"), status_nickname_kb)
    keyboard.add(InlineKeyboardButton(_("📋 По форме Yoo", locale=lang), url="https://vk.cc/bYjKGM"), status_formy_kb)

    return keyboard

# Удаление корзины
def confirm_user_cart(user_id, ):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            _("✅ Подтвердить", locale=lang),
            callback_data=f"xaddcart_item:yes:{position_id}:{get_count}",
        ),
        InlineKeyboardButton(
            _("❌ Отменить", locale=lang),
            callback_data=f"xaddcart_item:not:{position_id}:{get_count}",
        ),
    )

# Подтверждение покупки товара
def products_addcart_confirm_finl(position_id, get_count, lang):
    if lang == "ru":
        sbmbtn = "✅ Подтвердить"
        clbtn = "❌ Отменить"
    if lang == "en":
        sbmbtn = "✅ Submit"
        clbtn = "❌ Cancel"
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            sbmbtn,
            callback_data=f"xaddcart_item:yes:{position_id}:{get_count}:{lang}",
        ),
        InlineKeyboardButton(
            clbtn,
            callback_data=f"xaddcart_item:not:{position_id}:{get_count}:{lang}",
        ),
    )

# Подтверждение покупки товара
def products_confirm_finl(position_id, get_count):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            _("✅ Подтвердить", locale=lang),
            callback_data=f"xbuy_item:yes:{position_id}:{get_count}",
        ),
        InlineKeyboardButton(
            _("❌ Отменить", locale=lang),
            callback_data=f"xbuy_item:not:{position_id}:{get_count}",
        ),
    )


# Подтверждение покупки товара
def products_confirm_finl(position_id, get_count):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            _("✅ Подтвердить", locale=lang),
            callback_data=f"xbuy_item:yes:{position_id}:{get_count}",
        ),
        InlineKeyboardButton(
            _("❌ Отменить", locale=lang),
            callback_data=f"xbuy_item:not:{position_id}:{get_count}",
        ),
    )


# Подтверждение сохранения адреса доставки
def accept_saved_adr(user_id):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            _("✅ Да, оставить текущий адрес", locale=lang),
            callback_data="user_cart",
        ),
        InlineKeyboardButton(
            _("❌ Ввести новый адрес", locale=lang),
            callback_data=f"enter_address_manualy:{user_id}",
        ),
    )



def accept_saved_phone(user_id):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            _("✅ Да, оставить текущий номер", locale=lang),
            callback_data="user_cart",
        ),
        InlineKeyboardButton(
            _("❌ Ввести новый номер", locale=lang),
            callback_data=f"enter_phone_manualy:{user_id}",
        ),
    )

# Подтверждение отправки сообщения продавцом
def order_reply_message_finl(user_id):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            _("✅ Вернуться в Корзину", locale=lang), callback_data="user_cart"
        ),
        InlineKeyboardButton(
            _("❌ Ввести новое сообщение", locale=lang),
            callback_data="reply_toorder_message",
        ),
    )

# Подтверждение отправки сообщения покупателем
def cart_enter_message_finl(user_id):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            _("✅ Ответить на сообщение", locale=lang),
            callback_data="enter_message_manualy",
        ),
        InlineKeyboardButton(
            _("❌ Остановить сделку", locale=lang),
            callback_data="stop_sale_process",
        ),
    )

# Ответ на сообщение продавца
def enter_cart_message_finl(user_id):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            _("✅ Вернуться в Корзину", locale=lang), callback_data="user_cart"
        ),
        InlineKeyboardButton(
            _("❌ Ввести новое сообщение", locale=lang),
            callback_data="enter_message_manualy",
        ),
    )


# Ответ на сообщение покупателя
def reply_order_message_finl(user_id):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            _("✅ Ответить на сообщение покупателя", locale=lang),
            callback_data="reply_toorder_message",
        ),
        InlineKeyboardButton(
            _("❌ Остановить сделку", locale=lang),
            callback_data="stop_sale_process",
        ),
    )

# Ссылка на поддержку
def user_support_finl(user_name):
    return InlineKeyboardMarkup().add(
        InlineKeyboardButton(
            _("💌 Написать в поддержку", locale=lang),
            url=f"https://t.me/{user_name}",
        ),
    )


tgbot >keyboards>inline_z_all.py:
# - *- coding: utf- 8 - *-
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from tgbot.services.api_sqlite import get_settingsx
#from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR

settings = get_settingsx()
type_trade = settings['type_trade']
print(type_trade)

# Рассылка
ad_confirm_inl = InlineKeyboardMarkup(
).add(
    InlineKeyboardButton("✅ Отправить", callback_data="confirm_ad:yes"),
    InlineKeyboardButton("❌ Отменить", callback_data="confirm_ad:not")
)

# Рассылка
ad_add_to_plan_inl = InlineKeyboardMarkup(
).add(
    InlineKeyboardButton("✅ Включить", callback_data="plan_once_ad:yes"),
    InlineKeyboardButton("❌ Отправить только один раз", callback_data="plan_once_ad:not")
)

# Кнопки при поиске профиля через админ-меню
refill_open_inl = InlineKeyboardMarkup(
).add(
    InlineKeyboardButton("💰 Пополнить", callback_data="user_refill")
)

partners_list_open_inl = InlineKeyboardMarkup(row_width=2
).add(
    InlineKeyboardButton("Обновить", callback_data="open_partners_list"),
    InlineKeyboardButton("Разместить ссылку в каталоге", callback_data="partner_submit")
)

# Кнопки при поиске профиля через админ-меню
profile_open_inl = InlineKeyboardMarkup(
).add(
    InlineKeyboardButton("💰 Пополнить", callback_data="user_refill"),
    InlineKeyboardButton("🎁 Мои покупки", callback_data="user_history")
).add(
    InlineKeyboardButton("💰 Адрес BTC BEP20", callback_data="change_bep20"),
    InlineKeyboardButton("💰 Адрес TRC20", callback_data="change_trc20"),
)

if(type_trade != 'digital'):
    profile_open_inl = InlineKeyboardMarkup(row_width=2).add(
        InlineKeyboardButton("💰 Пополнить", callback_data="user_refill"),
        InlineKeyboardButton("🎁 Мои покупки", callback_data="user_history"),
        InlineKeyboardButton("➰ Ввести промокод", callback_data="enter_promocode"),
        InlineKeyboardButton("📡 Изменить город", callback_data="edit_location"),
        InlineKeyboardButton("💰 Адрес BTC BEP20", callback_data="change_bep20"),
        InlineKeyboardButton("💰 Адрес TRC20", callback_data="change_trc20"),
    )

profile_seller_open_inl = InlineKeyboardMarkup(row_width=2).add(
        InlineKeyboardButton("💰 Пополнить", callback_data="user_refill"),
        InlineKeyboardButton("🎁 Мои покупки", callback_data="user_history"),
        InlineKeyboardButton("➰ Ввести промокод", callback_data="enter_promocode"),
        InlineKeyboardButton("📡 Изменить город", callback_data="edit_location"),
        InlineKeyboardButton("🚛 Изменить настройки доставки", callback_data="edit_delivery_settings"),
        InlineKeyboardButton("💰 Адрес BTC BEP20", callback_data="change_bep20"),
        InlineKeyboardButton("💰 Адрес TRC20", callback_data="change_trc20"),
    )

give_number_inl = InlineKeyboardMarkup(
    ).add(
        InlineKeyboardButton("Поделиться номером", callback_data="enter_phone_auto_fin")
    )

# Удаление сообщения
close_inl = InlineKeyboardMarkup(
).add(
    InlineKeyboardButton("❌ Закрыть", callback_data="close_this"),
)

# Открытие корзины
cart_open_created_inl = InlineKeyboardMarkup(
    ).add(InlineKeyboardButton("🏢 Ввести адрес", callback_data="enter_address_manualy"),
        InlineKeyboardButton("📱 Ввести телефон", callback_data="enter_phone_manualy"),
        InlineKeyboardButton(" ! Оформить заказ", callback_data="checkout_start"),
    ).add(
        InlineKeyboardButton("📱 Поделиться номером", callback_data="enter_phone_auto" ),
        InlineKeyboardButton("💰 Пополнить счет", callback_data="user_refill"),
        InlineKeyboardButton("❓ Спросить продавца", callback_data="enter_message_manualy"),
    ).add(
        InlineKeyboardButton(" Удалить корзину", callback_data="del_user_cart")
    )


cart_open_delivery_inl = InlineKeyboardMarkup(
    ).add(
        InlineKeyboardButton("📱 Подтвердить получение", callback_data="submit_order"),
        InlineKeyboardButton("❓ Задать вопрос продавцу",callback_data="enter_message_manualy")
    )

# Удаление корзина
confirm_delete_user_cart_inl = InlineKeyboardMarkup(
).add(
    InlineKeyboardButton("❌ Да, удалить корзину", callback_data="confirm_del_user_cart"),
    InlineKeyboardButton("✅ Нет, вернуться в корзину", callback_data="user_cart")
)

######################################## ТОВАРЫ ########################################
# Удаление категорий
category_remove_confirm_inl = InlineKeyboardMarkup(
).add(
    InlineKeyboardButton("❌ Да, удалить все", callback_data="confirm_remove_category:yes"),
    InlineKeyboardButton("✅ Нет, отменить", callback_data="confirm_remove_category:not")
)

# Подтверждение оформления заказа
checkout_step2_accept = InlineKeyboardMarkup(
).add(
    InlineKeyboardButton("✅ Да, оформить", callback_data="checkout_finish"),
    InlineKeyboardButton("❌ Вернуться в Корзину", callback_data="user_cart")
)

# Подтверждение полполнения счета
order_user_refill = InlineKeyboardMarkup(
    ).add(
        InlineKeyboardButton("✅ Да, пополнить баланс", callback_data="user_refill"),
        InlineKeyboardButton("❌ Вернуться в Корзину", callback_data="user_cart")
    )

# Удаление позиций
position_remove_confirm_inl = InlineKeyboardMarkup(
).add(
    InlineKeyboardButton("❌ Да, удалить все", callback_data="confirm_remove_position:yes"),
    InlineKeyboardButton("✅ Нет, отменить", callback_data="confirm_remove_position:not")
)

partners_list_inl = InlineKeyboardMarkup(
).add(
    InlineKeyboardButton("Психологическая помощь PsyBorBot", url="https://t.me/PsyBorBot")
).add(
    InlineKeyboardButton("Юридический сервис \"Спроси Юриста\"", url="https://t.me/SprosiYuristaRBot")
)

# Удаление товаров
item_remove_confirm_inl = InlineKeyboardMarkup(
).add(
    InlineKeyboardButton("❌ Да, удалить все", callback_data="confirm_remove_item:yes"),
    InlineKeyboardButton("✅ Нет, отменить", callback_data="confirm_remove_item:not")
)


tgbot >keyboards>inline_z_page.py:
# - *- coding: utf- 8 - *-
import math
import gettext
from pathlib import Path
from contextvars import ContextVar
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton as ikb

from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR
#from tgbot.middlewares.i18n import I18nMiddleware
#from aiogram.contrib.middlewares.i18n import I18nMiddleware
from tgbot.middlewares.i18n import I18nMiddleware

from tgbot.services.api_sqlite import get_all_categoriesx, get_itemsx, get_positionsx, get_all_shopx, get_city_user\
    , get_position_on_city, get_category_in_city, get_shopsxx, get_paramposition_on_city, get_shopposition_on_city,\
    get_all_shopx, get_my_shopx, get_events_in_city, get_all_events, get_all_places, get_eventxx, get_events_in_place, \
    get_eventsxx,  get_artistsxx, get_category_in_cityx, get_shop_in_cityx, get_events_in_cityx, get_places_in_cityx, \
    get_category_in_citypx, get_positionsorder, get_parent_cat, get_category_count, get_parent_catc

cpage = 10

'''i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
#I18nMiddleware.setup_middlewares(i18n)
print(i18n)
# Alias for gettext method
_ = i18n.gettext
#_ = i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
#lang1 = gettext.translation('mybot', languages=['ru'])
#lang1.install()
print(i18n.find_locales())
#current_user_id_ctx = ContextVar('current_user_id_ctx')
ctx_user_locale = ContextVar('ctx_user_locale')'''

# fp - flip page
# cpage - count page
##############################################################################################
################################################################################################
###################################### ИЗМЕНЕНИЕ КАТЕГОРИИ #####################################
# Стартовые страницы выбора категории для изменения
def shop_edit_swipe_fp(user_id, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"
    get_shops = get_my_shopx(user_id)
    keyboard = InlineKeyboardMarkup()

    if remover >= len(get_shops): remover -= 10

    for count, a in enumerate(range(remover, len(get_shops))):
        if count < 10:
            keyboard.add(ikb(get_shops[a]['name'],
                             callback_data=f"shop_edit_open:{get_categories[a]['category_id']}:{remover}"))

    if len(get_categories) <= 10:
        pass
    elif remover < 10:
        keyboard.add(
            ikb(f"🔸 1/{math.ceil(len(get_categories) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"catategory_edit_swipe:{remover + 10}")
        )
    elif remover + 10 >= len(get_categories):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"catategory_edit_swipe:{remover - 10}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_categories) / 10)} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"catategory_edit_swipe:{remover - 10}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_categories) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"catategory_edit_swipe:{remover + 10}"),
        )

    return keyboard

def open_partners_list():
    get_partners = get_all_partnersx()
    keyboard = InlineKeyboardMarkup()

    keyboard = types.ReplyKeyboardMarkup(row_width=3, resize_keyboard=True)
    for partner in get_partners:
        buttons_to_add = append([InlineKeyboardButton(text=partner['name'], url=partner['link'])])

    keyboard.add(*buttons_to_add)

    return keyboard

################################################################################################
################################# СТРАНИЦЫ ИЗМЕНЕНИЯ КАТЕГОРИЙ #################################
# Стартовые страницы выбора категории для изменения
def category_edit_open_fp(remover, lang):
    print(lang)
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
    get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                             callback_data=f"category_edit_here:{get_categories[a]['category_id']}:{remover}"))
    if len(get_categories) <= 10:
        pass
    elif len(get_categories) > cpage and remover < 10:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"catategory_edit_nextp:{remover + cpage}")
        )
    elif remover + cpage >= len(get_categories):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"catategory_edit_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"catategory_edit_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"catategory_edit_nextp:{remover + cpage}"),
        )

    return keyboard


# Следующая страница выбора категории для изменения
def category_edit_next_page_fp(remover, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"
    get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                             callback_data=f"category_edit_here:{get_categories[a]['category_id']}:{remover}"))
    if remover + cpage >= len(get_categories):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"catategory_edit_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"catategory_edit_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"catategory_edit_nextp:{remover + cpage}"),
        )

    return keyboard

################################################################################################
################################# СТРАНИЦЫ ИЗМЕНЕНИЯ МАГАЗИНА #################################
# Стартовые страницы выбора магазина для изменения
def artist_edit_open_fp(remover, user_id):
    get_my_artists = get_artistsxx(admin=user_id)
    keyboard = InlineKeyboardMarkup()
    print(len(get_my_artists))

    for count, a in enumerate(range(remover, len(get_my_artists))):
        if count < cpage:
            keyboard.add(ikb(f"{get_my_artists[a]['name']}",
                             callback_data=f"artist_edit:{get_my_artists[a]['artist_id']}:{user_id}:{remover}"))
    if len(get_my_artists) <= 10:
        pass
    elif len(get_my_artists) > cpage and remover < 10:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(_("Далее ➡", locale=lang), callback_data=f"artist_edit_swipe:{remover + cpage}:{user_id}")
        )
    elif remover + cpage >= len(get_my_artists):
        keyboard.add(
            ikb(_("⬅ Назад", locale=lang), callback_data=f"artist_edit_swipe:{remover - cpage}:{user_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(_("⬅ Назад", locale=lang), callback_data=f"artist_edit_swipe:{remover - cpage}:{user_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(_("Далее ➡", locale=lang), callback_data=f"artist_edit_swipe:{remover + cpage}:{user_id}"),
        )
    return keyboard


# Предыдующая страница выбора категории для изменения
def category_edit_back_page_fp(remover, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"
    get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                             callback_data=f"category_edit_here:{get_categories[a]['category_id']}:{remover}"))
    if remover <= 0:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"catategory_edit_nextp:{remover + cpage}")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"catategory_edit_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"catategory_edit_nextp:{remover + cpage}"),
        )

    return keyboard



#############################################################################################
####################################### ПОКУПКИ ТОВАРОВ #####################################
# Страницы категорий при покупке товара
def position_2people_create_open_fp(category_id, remover, level, parent, city_id): # + action = create / open
    print(city_id)
    #if parent == "" or parent is None: parent = 0

    '''if category_id != 0:
        get_categories = get_category_in_citypx(parent_id=category_id)
    elif level == 1:
        get_categories = get_category_in_citypx(level=1)
    else:'''
    get_categories = get_category_in_citypx(parent_id=parent)
    #get_categories = get_category_in_city(city_id)
    #get_categories = get_category_in_cityx(position_city_id=city_id, position_type=1, flagallc=1)

    #get_categories = get_all_categoriesx()
    print(len(get_categories))
    #keyboard = InlineKeyboardMarkup()
    count = 0
    if city_id is None: city_id = 0

    #get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()

    if remover >= len(get_categories): remover -= 10

    for count, a in enumerate(range(remover, len(get_categories))):
        level = get_categories[a]['level']
        if count < 10:
            if level == 1:
                keyboard.add(
                    ikb(
                        get_categories[a]['category'],
                        callback_data=f"buy_people_category_swipe:{get_categories[a]['parent_id']}:0:0:{get_categories[a]['category_id']}:{city_id}",
                    )
                )
            elif level == 2:
                keyboard.add(ikb(get_categories[a]['category'],
                                 callback_data=f"position_people_create_here:{get_categories[a]['category_id']}:{get_categories[a]['parent_id']}:{city_id}"))

    if len(get_categories) <= 10:
        pass
    elif remover < 10:
        keyboard.add(
            ikb(
                f"🔸 1/{math.ceil(len(get_categories) / 10)} 🔸",
                callback_data="...",
            ),
            ikb(
                _("Далее ➡", locale=lang),
                callback_data=f"buy_people_category_swipe:0:{remover + 10}:0:0:{city_id}",
            ),
        )
    elif remover + 10 >= len(get_categories):
        keyboard.add(
            ikb(
                _("⬅ Назад", locale=lang),
                callback_data=f"buy_people_category_swipe:0:{remover - 10}:0:0:{city_id}",
            ),
            ikb(
                f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_categories) / 10)} 🔸",
                callback_data="...",
            ),
        )
    else:
        keyboard.add(
            ikb(
                _("⬅ Назад", locale=lang),
                callback_data=f"buy_people_category_swipe:0:{remover - 10}:0:0:{city_id}",
            ),
            ikb(
                f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_categories) / 10)} 🔸",
                callback_data="...",
            ),
            ikb(
                _("Далее ➡", locale=lang),
                callback_data=f"buy_people_category_swipe:0:{remover + 10}:0:0:{city_id}",
            ),
        )

    keyboard.add(
        ikb(
            _("⬅ Вернуться ↩", locale=lang),
            callback_data=f"buy_people_category_swipe:{get_categories[a]['parent_id']}:0:{level - 1}:0:{city_id}",
        )
    )

    return keyboard

#############################################################################################
####################################### ПОКУПКИ ТОВАРОВ #####################################
# Страницы категорий при покупке товара
def position_people_create_open_fp(category_id, remover, level, parent, city_id, action, lang): #+ action = create / open
    print(city_id, action)
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"
    #if parent == "" or parent is None: parent = 0
    #lang = ctx_user_locale.get()
    #print(lang)
    #user_id = message.from_user.id
    #lang = get_user_lang(user_id)
    '''if category_id != 0:
        get_categories = get_category_in_citypx(parent_id=category_id)
    elif level == 1:
        get_categories = get_category_in_citypx(level=1)
    else:'''
    get_categories = get_category_in_citypx(parent_id=parent)

    print(len(get_categories))
    print(category_id, remover, level, parent, city_id, action, lang)

    count = 0
    if city_id is None: city_id = 0

    keyboard = InlineKeyboardMarkup()

    if remover >= len(get_categories): remover -= 10

    for count, a in enumerate(range(remover, len(get_categories))):
        level = get_categories[a]['level']
        if count < 10:
            if get_categories[a]['level'] == 1:
                keyboard.add(
                    ikb(
                        get_categories[a]['category'],
                        callback_data=f"buy_people_category_swipe:{get_categories[a]['parent_id']}:0:0:{get_categories[a]['category_id']}:{city_id}:{action}",
                    )
                )
            elif get_categories[a]['level'] == 2 and action == "create":
                keyboard.add(ikb(get_categories[a]['category'],
                                 callback_data=f"position_people_create_here:{get_categories[a]['category_id']}:{get_categories[a]['parent_id']}:{city_id}:{lang}"))
            elif get_categories[a]['level'] == 2 and action == "open":
                keyboard.add(ikb(get_categories[a]['category'],
                             callback_data=f"position_people_open_here:{get_categories[a]['category_id']}:{get_categories[a]['parent_id']}:{city_id}:{lang}"))

    if len(get_categories) <= 10:
        pass
    elif remover < 10:
        keyboard.add(
            ikb(
                f"🔸 1/{math.ceil(len(get_categories) / 10)} 🔸",
                callback_data="...",
            ),
            ikb(
                fwdbutton,
                callback_data=f"buy_people_category_swipe:0:{remover + 10}:0:0:{city_id}:{action}",
            ),
        )
    elif remover + 10 >= len(get_categories):
        keyboard.add(
            ikb(
                bwdbutton,
                callback_data=f"buy_people_category_swipe:0:{remover - 10}:0:0:{city_id}:{action}",
            ),
            ikb(
                f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_categories) / 10)} 🔸",
                callback_data="...",
            ),
        )
    else:
        keyboard.add(
            ikb(
                bwdbutton,
                callback_data=f"buy_people_category_swipe:0:{remover - 10}:0:0:{city_id}:{action}",
            ),
            ikb(
                f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_categories) / 10)} 🔸",
                callback_data="...",
            ),
            ikb(
                fwdbutton,
                callback_data=f"buy_people_category_swipe:0:{remover + 10}:0:0:{city_id}:{action}",
            ),
        )

    keyboard.add(
        ikb(
            bbutton,
            callback_data=f"buy_people_category_swipe:{get_categories[a]['parent_id']}:0:{level - 1}:0:{city_id}:{action}",
        )
    )

    return keyboard

####################################### ПОКУПКИ ТОВАРОВ #####################################
# Страницы категорий при покупке товара
def cources_opcr_fp(category_id, remover, level, parent, city_id, action, lang): #+ action = create / open
    print(category_id, remover, level, parent, city_id, action, lang)
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"

    get_categories = get_curcategory_in_citypx(parent_id=parent)

    print(len(get_categories))

    count = 0
    if city_id is None: city_id = 0

    keyboard = InlineKeyboardMarkup()

    if remover >= len(get_categories): remover -= 10

    for count, a in enumerate(range(remover, len(get_categories))):
        level = get_categories[a]['level']
        if count < 10:
            if get_categories[a]['level'] == 1:
                keyboard.add(
                    ikb(
                        get_categories[a]['category'],
                        callback_data=f"cources_category_swipe:{get_categories[a]['parent_id']}:0:0:{get_categories[a]['category_id']}:{city_id}:{action}",
                    )
                )
            elif get_categories[a]['level'] == 2 and action == "create":
                keyboard.add(ikb(get_categories[a]['category'],
                                 callback_data=f"cources_create_here:{get_categories[a]['category_id']}:{get_categories[a]['parent_id']}:{city_id}:{lang}"))
            elif get_categories[a]['level'] == 2 and action == "open":
                keyboard.add(ikb(get_categories[a]['category'],
                                 callback_data=f"cources_open_here:{get_categories[a]['category_id']}:{get_categories[a]['parent_id']}:{city_id}:{lang}"))

    if len(get_categories) <= 10:
        pass
    elif remover < 10:
        keyboard.add(
            ikb(
                f"🔸 1/{math.ceil(len(get_categories) / 10)} 🔸",
                callback_data="...",
            ),
            ikb(
                fwdbutton,
                callback_data=f"cources_category_swipe:0:{remover + 10}:0:0:{city_id}:{action}",
            ),
        )
    elif remover + 10 >= len(get_categories):
        keyboard.add(
            ikb(
                bwdbutton,
                callback_data=f"cources_category_swipe:0:{remover - 10}:0:0:{city_id}:{action}",
            ),
            ikb(
                f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_categories) / 10)} 🔸",
                callback_data="...",
            ),
        )
    else:
        keyboard.add(
            ikb(
                bwdbutton,
                callback_data=f"cources_category_swipe:0:{remover - 10}:0:0:{city_id}:{action}",
            ),
            ikb(
                f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_categories) / 10)} 🔸",
                callback_data="...",
            ),
            ikb(
                fwdbutton,
                callback_data=f"cources_category_swipe:0:{remover + 10}:0:0:{city_id}:{action}",
            ),
        )

    keyboard.add(
        ikb(
            bbutton,
            callback_data=f"cources_category_swipe:{get_categories[a]['parent_id']}:0:{level - 1}:0:{city_id}:{action}",
        )
    )

    return keyboard

################################################################################################
################################### СТРАНИЦЫ СОЗДАНИЯ ПОЗИЦИЙ ##################################
# Стартовые страницы выбора категории для добавления позиции
def position_create_open_fp(remover, lang):
    get_categories = get_all_categoriesx()
    if lang == 'ru':
        fwdbutton = "Далее ➡"
    if lang == 'en':
        fwdbutton = "Next ➡"

    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                             callback_data=f"position_create_here:{get_categories[a]['category_id']}"))
    if len(get_categories) <= 10:
        pass
    elif len(get_categories) > cpage:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_create_nextp:{remover + cpage}:{lang}")
        )

    return keyboard

# Стартовые страницы выбора категории для добавления позиции
def position_select_shop_fp(user_id, lang):
    get_shops = get_all_shopx()
    if lang == 'ru':
        fwdbutton = "Далее ➡"
    if lang == 'en':
        fwdbutton = "Next ➡"
    #get_shops = get_my_shopx(user_id)
    keyboard = InlineKeyboardMarkup()
    remover = 0
    cpage = 10

    for a in range(remover, len(get_shops)):
        keyboard.add(ikb(f"{get_shops[a]['name']}",
                             callback_data=f"here_position_addtoshop:{get_shops[a]['shop_id']}"))
    if len(get_shops) <= 10:
        pass
    elif len(get_shops) > cpage:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_addtoshop_nextp:{remover + cpage}:{lang}")
        )

    return keyboard

# Следующая страница выбора категории для добавления позиции
def position_addtoshop_nextp(remover, lang):
    #get_categories = get_all_categoriesx()
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"

    get_shops = get_all_shopx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_shops))):
        if count < cpage:
            keyboard.add(ikb(f"{get_shops[a]['name']}",
                             callback_data=f"here_position_addtoshop:{get_shops[a]['shop_id']}"))
    if remover + cpage >= len(get_shops):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_addtoshop_backp:{remover - cpage}:{lang}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_addtoshop_backp:{remover - cpage}:{lang}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_addtoshop_nextp:{remover + cpage}:{lang}"),
        )

    return keyboard

# Предыдующая страница выбора категории для добавления позиции
def position_addtoshop_backp(remover, lang):
    #get_categories = get_all_categoriesx()
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
    get_shops = get_all_shopx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_shops))):
        if count < cpage:
            keyboard.add(ikb(f"{get_shops[a]['category_name']}",
                             callback_data=f"position_create_here:{get_shops[a]['category_id']}"))
    if remover <= 0:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_addtoshop_nextp:{remover + cpage}:{lang}")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_addtoshop_backp:{remover - cpage}:{lang}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_addtoshop_nextp:{remover + cpage}:{lang}")
        )

    return keyboard

# Следующая страница выбора категории для добавления позиции
def position_create_next_page_fp2(remover, lang):
    #get_categories = get_all_categoriesx()
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
    get_shops = get_all_shopx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_shops[a]['name']}",
                             callback_data=f"position_create_here:{get_shops[a]['shop_id']}"))
    if remover + cpage >= len(get_shops):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_create_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_create_backp:{remover - cpage}:{lang}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_create_nextp:{remover + cpage}:{lang}"),
        )

    return keyboard

# Следующая страница выбора категории для добавления позиции
def position_create_next_page_fp(remover, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"
    get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                             callback_data=f"position_create_here:{get_categories[a]['category_id']}"))
    if remover <= 0:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_create_nextp:{remover + cpage}")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_create_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            #ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_categories) / 10)} 🔸"),
            ikb(fwdbutton, callback_data=f"position_create_nextp:{remover + cpage}")
        )

    return keyboard



# Предыдующая страница выбора категории для добавления позиции
def position_create_back_page_fp(remover, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
    get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                             callback_data=f"position_create_here:{get_categories[a]['category_id']}"))
    if remover <= 0:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_create_nextp:{remover + cpage}")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_create_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_create_nextp:{remover + cpage}")
        )

    return keyboard

################################################################################################
################################## СТРАНИЦЫ ИЗМЕНЕНИЯ ПОЗИЦИЙ ##################################
########################################### Категории ##########################################
# Стартовые страницы категорий при изменении позиции
def position_edit_category_open_fp(remover, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
    get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                             callback_data=f"position_edit_category:{get_categories[a]['category_id']}"))
    if len(get_categories) <= 10:
        pass
    elif len(get_categories) > cpage and remover < 10:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_edit_category_nextp:{remover + cpage}")
        )
    elif remover + cpage >= len(get_categories):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_edit_category_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_edit_category_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_edit_category_nextp:{remover + cpage}"),
        )

    return keyboard

# Следующая страница категорий при изменении позиции
def position_edit_category_next_page_fp(remover, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
    get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                             callback_data=f"position_edit_category:{get_categories[a]['category_id']}"))
    if remover + cpage >= len(get_categories):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_edit_category_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_edit_category_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_edit_category_nextp:{remover + cpage}"),
        )

    return keyboard

# Предыдующая страница категорий при изменении позиции
def position_edit_category_back_page_fp(remover, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
    get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                             callback_data=f"position_edit_category:{get_categories[a]['category_id']}"))
    if remover <= 0:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_edit_category_nextp:{remover + cpage}")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_edit_category_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_edit_category_nextp:{remover + cpage}"),
        )

    return keyboard

########################################### ПОЗИЦИИ ##########################################
# Стартовые страницы позиций для их изменения
def position_edit_open_fp(remover, category_id, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"
    #order
    get_positions = get_positionsx(category_id=category_id)
    #get_positions = get_positionsorder(category_id)
    keyboard = InlineKeyboardMarkup()
    print(get_positions)

    for count, a in enumerate(range(remover, len(get_positions))):
        if count < cpage:
            keyboard.add(ikb(
                f"{get_positions[a]['position_name']} | {get_positions[a]['position_price']}₽", # {len(get_items)} шт",
                callback_data=f"position_edit:{get_positions[a]['position_id']}:{remover}:{category_id}"))
    if len(get_positions) <= 10:
        pass
    elif len(get_positions) > cpage and remover < 10:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_edit_nextp:{remover + cpage}:{category_id}")
        )
    elif remover + cpage >= len(get_positions):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_edit_backp:{remover - cpage}:{category_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]}/{math.ceil(len(get_positions) / 10)} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_edit_backp:{remover - cpage}:{category_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]}/{math.ceil(len(get_positions) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_edit_nextp:{remover + cpage}:{category_id}"),
        )
    keyboard.add(ikb(bbutton, callback_data="position_edit_category_return"))

    return keyboard

# Следующая страница позиций для их изменения
def position_edit_next_page_fp(remover, category_id, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"
    get_positions = get_positionsx(category_id=category_id)
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_positions))):
        if count < cpage:
            #get_items = get_itemsx(position_id=get_positions[a]['position_id'])
            keyboard.add(ikb(
                f"{get_positions[a]['position_name']} | {get_positions[a]['position_price']}₽ |", # {len(get_items)} шт",
                callback_data=f"position_edit:{get_positions[a]['position_id']}:{remover}:{category_id}"))
    if remover + cpage >= len(get_positions):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_edit_backp:{remover - cpage}:{category_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_edit_backp:{remover - cpage}:{category_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_edit_nextp:{remover + cpage}:{category_id}"),
        )
    keyboard.add(ikb(bbutton, callback_data="position_edit_category_return"))

    return keyboard

# Предыдующая страница позиций для их изменения
def position_edit_back_page_fp(remover, category_id, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"
    get_positions = get_positionsx(category_id=category_id)
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_positions))):
        if count < cpage:
            #get_items = get_itemsx(position_id=get_positions[a]['position_id'])
            keyboard.add(ikb(
                f"{get_positions[a]['position_name']} | {get_positions[a]['position_price']}₽", # | {len(get_items)} шт",
                callback_data=f"position_edit:{get_positions[a]['position_id']}:{remover}:{category_id}"))
    if remover <= 0:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_edit_nextp:{remover + cpage}:{category_id}")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"position_edit_backp:{remover - cpage}:{category_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"position_edit_nextp:{remover + cpage}:{category_id}"),
        )
    keyboard.add(ikb(bbutton, callback_data="position_edit_category_return"))

    return keyboard

################################################################################################
################################## СТРАНИЦЫ ДОБАВЛЕНИЯ ТОВАРОВ #################################
# Стартовые страницы категорий при добавлении товара
def products_add_category_open_fp(remover, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"
    get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                             callback_data=f"products_add_category:{get_categories[a]['category_id']}"))
    if len(get_categories) <= 10:
        pass
    elif len(get_categories) > cpage and remover < 10:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"products_add_category_nextp:{remover + cpage}")
        )
    elif remover + cpage >= len(get_categories):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"products_add_category_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"products_add_category_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"products_add_category_nextp:{remover + cpage}"),
        )

    return keyboard

# Следующая страница категорий при добавлении товара
def products_add_category_next_page_fp(remover):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"
    get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                             callback_data=f"products_add_category:{get_categories[a]['category_id']}"))
    if remover + cpage >= len(get_categories):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"products_add_category_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"products_add_category_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"products_add_category_nextp:{remover + cpage}"),
        )

    return keyboard

# Предыдующая страница категорий при добавлении товара
def products_add_category_back_page_fp(remover):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"
    get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_categories))):
        if count < cpage:
            keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                             callback_data=f"products_add_category:{get_categories[a]['category_id']}"))
    if remover <= 0:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"products_add_category_nextp:{remover + cpage}")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"products_add_category_backp:{remover - cpage}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"products_add_category_nextp:{remover + cpage}"),
        )

    return keyboard

########################################### ПОЗИЦИИ ##########################################
# Стартовые страницы позиций для добавления товаров
def products_add_position_open_fp(remover, category_id, lang):
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"
    if lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"
    get_positions = get_positionsx(category_id=category_id)
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_positions))):
        if count < cpage:
            get_items = get_itemsx(position_id=get_positions[a]['position_id'])
            keyboard.add(ikb(
                f"{get_positions[a]['position_name']} | {get_positions[a]['position_price']}₽ | {len(get_items)} шт",
                callback_data=f"products_add_position:{get_positions[a]['position_id']}:{category_id}"))
    if len(get_positions) <= 10:
        pass
    elif len(get_positions) > cpage and remover < 10:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"products_add_position_nextp:{remover + cpage}:{category_id}")
        )
    elif remover + cpage >= len(get_positions):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"products_add_position_backp:{remover - cpage}:{category_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"products_add_position_backp:{remover - cpage}:{category_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"products_add_position_nextp:{remover + cpage}:{category_id}"),
        )
    keyboard.add(ikb(bbutton, callback_data="back_add_products_to_category"))

    return keyboard

################################################################################
##################### Страница подтверждения запроса на продавца ###############
################################################################################

def request_seller_role(user_id, lang):
    keyboard = InlineKeyboardMarkup()
    keyboard.add(
            ikb(_("🔸 Запросить права продавца 🔸", locale=lang), callback_data="create_seller_request"))

    return keyboard


#############################################################################################
####################################### ПОКУПКИ ТОВАРОВ #####################################
# Страницы категорий при покупке товара
def products_item_category_swipe_fp(remover, parent_id, city_id, action, lang):
    print(remover, parent_id, city_id, action, lang)
    #get_categories = get_category_in_city(city_id)
    #if parent_id == 0:
    #    get_categories = get_category_in_cityx(level=1)
    #else:
    #category_precount = get_category_count(category_id)['countp']
    #if category_precount == 0:
    get_categories = get_category_in_cityx(parent_id=parent_id) #, position_city_id=city_id position_type=1, flagallc=1

    #get_categories = get_all_categoriesx()
    #lang = get_user_lang(user_id)['user_lang']
    #print(get_categories, len(get_categories))
    #keyboard = InlineKeyboardMarkup()
    count = 0

    if lang == "ru":
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbbutton = "Вверх"
    elif lang == "en":
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbbutton = "Level Up"

    if city_id is None: city_id = 0
    bbtntext = ""

    keyboard = InlineKeyboardMarkup()

    if remover >= len(get_categories): remover -= 10

    keyboard.add(ikb(" Барахолка Вашего города ", callback_data="privateMarket"))

    for count, a in enumerate(range(remover, len(get_categories))):
        category_count = get_category_count(get_categories[a]['category_id'])['countp']
        #print(category_count)

        if count < 10:
            if get_categories[a]['level'] == 1 and action == "edit":
                keyboard.add(ikb(f"{get_categories[a]['category_name']}",
                                 callback_data=f"position_edit_category_swipe:{get_categories[a]['category_id']}:{city_id}:{lang}"))

            elif get_categories[a]['level'] == 2 and action == "edit" or get_categories[a]['level'] == 1 and category_count > 0 and action == "edit":
                keyboard.add(ikb(get_categories[a]['category_name'],
                             callback_data=f"position_edit_category_open:{get_categories[a]['category_id']}:{city_id}:{lang}"))

            elif get_categories[a]['level'] == 1 and category_count == 0 and action in ["open", "edit"]:
                print("way3")
                keyboard.add(ikb(get_categories[a]['category_name'],
                                 callback_data=f"buy_category_swipe:{remover}:{get_categories[a]['category_id']}:{city_id}:{action}"))
                #bbtntext = ikb(bbbutton, callback_data="start")

            elif get_categories[a]['level'] == 2 and action == "create":
                keyboard.add(ikb(get_categories[a]['category_name'],
                                 callback_data=f"position_create_here:{get_categories[a]['category_id']}:{get_categories[a]['parent_id']}:{city_id}:{lang}"))
                #bbtntext = ikb(bbbutton, callback_data=f"buy_category_swipe:{0}:{0}:{city_id}:{action}")

            elif get_categories[a]['level'] == 2 and action == "open" or get_categories[a]['level'] == 1 and action == "open" and category_count > 0:
                print("way5")
                keyboard.add(ikb(get_categories[a]['category_name'],
                                 callback_data=f"buy_category_open:{get_categories[a]['category_id']}:{city_id}"))
                bbtntext = ikb(bbbutton, callback_data=f"buy_category_swipe:{0}:{0}:{city_id}:{action}")


    if len(get_categories) <= 10:
        pass
    elif remover < 10:
        keyboard.add(
            ikb(f"🔸 1/{math.ceil(len(get_categories) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"buy_category_swipe:{remover + 10}:{get_categories[a]['parent_id']}:{city_id}:{action}"),
        )
    elif remover + 10 >= len(get_categories):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"buy_category_swipe:{remover - 10}:{get_categories[a]['parent_id']}:{city_id}:{action}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_categories) / 10)} 🔸", callback_data="..."),
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"buy_category_swipe:{remover - 10}:{get_categories[a]['parent_id']}:{city_id}:{action}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_categories) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"buy_category_swipe:{remover + 10}:{get_categories[a]['parent_id']}:{city_id}:{action}"),
        )
    keyboard.add(bbtntext)

    return keyboard

# Страницы магазин при покупке товара
def select_place_in_city_swipe_fp(city_id, lang):
    #get_categories = get_category_in_city(city_id)
    #get_categories = get_all_categoriesx()
    #get_events = get_events_in_city(city_id)

    get_places = get_places_in_cityx(city_id)
    #get_shops = get_shopsxx()
    print(get_places)
    print(len(get_places))
    remover = 0
    count = 0
    if city_id is None: city_id = 0
    keyboard = InlineKeyboardMarkup()

    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    elif lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"

    if remover >= len(get_places): remover -= 10
    keyboard.add(
        ikb(
            "🔸 События в Вашем городе🔸",
            callback_data=f"events_city_swipe:0:{city_id}",
        )
    )

    for count, a in enumerate(range(remover, len(get_places))):
        print(get_places[a]['place_id'])
        if count < 10:
            keyboard.add(ikb(get_places[a]['name'], # + " | " + get_places[a]['city_id'],
                             callback_data=f"here_event_place:{get_places[a]['place_id']}"))

    if len(get_places) <= 10:
        pass
    elif remover < 10:
        keyboard.add(
            ikb(f"🔸 1/{math.ceil(len(get_places) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"places_city_swipe:{remover + 10}:{city_id}"),
        )
    elif remover + 10 >= len(get_places):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"places_city_swipe:{remover - 10}:{city_id}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_places) / 10)} 🔸", callback_data="..."),
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"places_city_swipe:{remover - 10}:{city_id}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_places) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"places_city_swipe:{remover + 10}:{city_id}"),
        )
    #keyboard.add(ikb("⬅ Вернуться ↩", callback_data=f"buy_shop_swipe:0:{city_id}"))
    return keyboard

# Страницы магазин при покупке товара
def places_in_city_swipe_fp(remover, city_id, lang):
    #get_categories = get_category_in_city(city_id)
    #get_categories = get_all_categoriesx()
    #get_events = get_events_in_city(city_id)
    #get_places = get_all_places()
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    elif lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"

    print(remover, city_id)
    get_places = get_places_in_cityx(city_id, flagallc=1, position_type=1)
    #get_shops = get_shopsxx()
    print(len(get_places))
    count = 0
    if city_id is None: city_id = 0
    keyboard = InlineKeyboardMarkup()

    if remover >= len(get_places): remover -= 10
    keyboard.add(
        ikb(
            "🔸 События в Вашем городе🔸",
            callback_data=f"events_city_swipe:0:{city_id}",
        )
    )

    for count, a in enumerate(range(remover, len(get_places))):
        if count < 10:
            keyboard.add(ikb(get_places[a]['name'], # + " | " + get_places[a]['city'],
                             callback_data=f"book_place_open:{get_places[a]['place_id']}"))

    if len(get_places) <= 10:
        pass
    elif remover < 10:
        keyboard.add(
            ikb(f"🔸 1/{math.ceil(len(get_places) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"places_city_swipe:{remover + 10}:{city_id}"),
        )
    elif remover + 10 >= len(get_places):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"places_city_swipe:{remover - 10}:{city_id}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_places) / 10)} 🔸", callback_data="..."),
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"places_city_swipe:{remover - 10}:{city_id}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_places) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"places_city_swipe:{remover + 10}:{city_id}"),
        )
    #keyboard.add(ikb("⬅ Вернуться ↩", callback_data=f"buy_shop_swipe:0:{city_id}"))
    return keyboard

# Страницы магазин при покупке товара
def events_in_city_swipe_fp(remover, city_id, lang):
    #get_categories = get_category_in_city(city_id)
    #get_categories = get_all_categoriesx()
    #get_events = get_events_in_city(city_id)
    get_events = get_events_in_cityx(city_id, flagallc=1, position_type=1)
    #get_shops = get_shopsxx()
    print(len(get_events))
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    elif lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
    #keyboard = InlineKeyboardMarkup()
    count = 0
    #if place_id is None: place_id = 0
    if city_id is None: city_id = 0

    #get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()

    if remover >= len(get_events): remover -= 10
    keyboard.add(
        ikb(
            "Добавить место или событие, нажмите 🔸",
            callback_data="open_inline_support",
        )
    )
    keyboard.add(
        ikb(
            "🔸 Места в Вашем городе🔸",
            callback_data=f"places_city_swipe:0:{city_id}",
        )
    )

    for count, a in enumerate(range(remover, len(get_events))):
        if count < 10:
            #edate = get_events[a]['event_date'] if get_events[a]['event_date'] else ""
            keyboard.add(
                ikb(
                    get_events[a]['event_name'] + " | ",
                    callback_data=f"book_event_open:{get_events[a]['event_id']}:0:{city_id}",
                )
            )

    if len(get_events) <= 10:
        pass
    elif remover < 10:
        keyboard.add(
            ikb(f"🔸 1/{math.ceil(len(get_events) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"events_city_swipe:{remover + 10}:{city_id}"),
        )
    elif remover + 10 >= len(get_events):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"events_city_swipe:{remover - 10}:{city_id}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_events) / 10)} 🔸", callback_data="..."),
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"events_city_swipe:{remover - 10}:{city_id}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_events) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"events_city_swipe:{remover + 10}:{city_id}"),
        )
    #keyboard.add(ikb("⬅ Вернуться ↩", callback_data=f"buy_shop_swipe:0:{city_id}"))
    return keyboard

# Страницы магазин при покупке товара
def events_in_place_swipe_fp(remover, place_id, city_id, lang):
    #get_categories = get_category_in_city(city_id)
    #get_categories = get_all_categoriesx()
    #get_events = get_events_in_city(city_id)
    #get_events = get_all_events()
    print("||||")
    #get_events = get_events_in_place(place_id)
    get_events = get_eventsxx(place_id=place_id)
    #get_shops = get_shopsxx()
    print(get_events)
    print(get_events[0])
    print(remover, place_id)
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    elif lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
    #keyboard = InlineKeyboardMarkup()
    count = 0
    print(city_id)
    if place_id is None: place_id = 0
    if city_id is None: city_id = 0
    #get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()

    if remover >= len(get_events[0]): remover -= 10
    keyboard.add(
        ikb(
            "🔸 Места в Вашем городе🔸",
            callback_data=f"places_city_swipe:0:{city_id}",
        )
    )

    for count, a in enumerate(range(remover, len(get_events))):
        if count < 10:
            keyboard.add(ikb(get_events[a]['event_name'] + " | " + get_events[a]['event_date'],
                             callback_data=f"book_event_open:{get_events[a]['event_id']}:{place_id}:{city_id}"))

    if len(get_events) <= 10:
        pass
    elif remover < 10:
        keyboard.add(
            ikb(f"🔸 1/{math.ceil(len(get_events) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"events_city_swipe:{remover + 10}:{city_id}"),
        )
    elif remover + 10 >= len(get_events):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"events_city_swipe:{remover - 10}:{city_id}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_events) / 10)} 🔸", callback_data="..."),
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"events_city_swipe:{remover - 10}:{city_id}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_events) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"events_city_swipe:{remover + 10}:{city_id}"),
        )
    #keyboard.add(ikb("⬅ Вернуться ↩", callback_data=f"buy_shop_swipe:0:{city_id}"))
    return keyboard

# Страницы магазин при покупке товара
def products_item_shop_swipe_fp(remover, city_id, lang):
    #get_categories = get_category_in_city(city_id)
    #get_categories = get_all_categoriesx()
    get_shops = get_all_shopx()
    get_shops = get_shop_in_cityx(city_id=city_id, position_type=1, flagallc=1)
    #get_shops = get_shopsxx()
    print(len(get_shops))
    #keyboard = InlineKeyboardMarkup()
    count = 0
    if city_id is None: city_id = 0

    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
    elif lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"

    #get_categories = get_all_categoriesx()
    keyboard = InlineKeyboardMarkup()

    if remover >= len(get_shops): remover -= 10

    for count, a in enumerate(range(remover, len(get_shops))):
        if count < 10:
            keyboard.add(ikb(get_shops[a]['name'],
                             callback_data=f"buy_shop_open:{get_shops[a]['shop_id']}:{city_id}:{lang}"))

    if len(get_shops) <= 10:
        pass
    elif remover < 10:
        keyboard.add(
            ikb(f"🔸 1/{math.ceil(len(get_shops) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"buy_shop_swipe:{remover + 10}:{city_id}"),
        )
    elif remover + 10 >= len(get_shops):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"buy_shop_swipe:{remover - 10}:{city_id}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_shops) / 10)} 🔸", callback_data="..."),
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"buy_shop_swipe:{remover - 10}:{city_id}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_shops) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"buy_shop_swipe:{remover + 10}:{city_id}"),
        )
    #keyboard.add(ikb("⬅ Вернуться ↩", callback_data=f"buy_shop_swipe:0:{city_id}"))
    return keyboard

# Страницы позиций для покупки товаров
def products_item_position_swipe_fp(remover, action, category_id, city_id, source, lang): # + source = people / commercial
    source = str(source)
    if source == "people":
        parent_category = get_parent_cat(category_id)[0]
    elif source == "commerce":
        parent_category = get_parent_catc(category_id)[0]
    print(parent_category)
    get_positions = get_positionsx(category_id=category_id, position_city_id=city_id)
    print(remover, category_id, city_id, source, lang)
    print(get_positions)
    position_rest = 0

    keyboard = InlineKeyboardMarkup()
    if lang == "ru":
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"

    elif lang == "en":
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"

    #city_id = сity_id if city_id else 0
    #category_id = category_id if category_id else 0
    #if category_id is None: category_id = 0

    if remover >= len(get_positions): remover -= 10

    for count, a in enumerate(range(remover, len(get_positions))):
        if count < 10:
            #get_items = len(get_itemsx(position_id=get_positions[a]['position_id']))
            if get_positions[a]['position_type'] == 1: position_rest = get_positions[a]['position_rest']
            if get_positions[a]['position_type'] == 2: position_rest = len(get_itemsx(position_id=get_positions[a]['position_id']))

            if action == "open":
                keyboard.add(ikb(
                    f"{get_positions[a]['position_name']} | {get_positions[a]['position_price']}₽| {position_rest} шт",
                    callback_data=f"buy_position_open:{get_positions[a]['position_id']}:{category_id}:{remover}:{city_id}:{lang}"))
            if action == "edit":
                keyboard.add(ikb(
                    f"{get_positions[a]['position_name']} | {get_positions[a]['position_price']}₽| {position_rest} шт",
                    callback_data=f"position_edit:{get_positions[a]['position_id']}:{category_id}:{remover}:{city_id}:{lang}"))

    if len(get_positions) <= 10:
        pass
    elif remover < 10:
        keyboard.add(
            ikb(f"🔸 1/{math.ceil(len(get_positions) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"buy_position_swipe:{category_id}:{remover + 10}:{city_id}"),
        )
    elif remover + 10 >= len(get_positions):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"buy_position_swipe:{category_id}:{remover - 10}:{city_id}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_positions) / 10)} 🔸", callback_data="..."),
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"buy_position_swipe:{category_id}:{remover - 10}:{city_id}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_positions) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"buy_position_swipe:{category_id}:{remover + 10}:{city_id}"),
        )
    keyboard.add(
        ikb(bbutton, callback_data=f"buy_category_swipe:{0}:{parent_category}:{city_id}:{action}")
    )

    return keyboard

# Следующая страница позиций для добавления товаров
def products_add_position_next_page_fp(remover, category_id, lang):
    get_positions = get_positionsx(category_id=category_id)
    keyboard = InlineKeyboardMarkup()
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"

    elif lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"

    for count, a in enumerate(range(remover, len(get_positions))):
        if count < cpage:
            get_items = get_itemsx(position_id=get_positions[a]['position_id'])
            keyboard.add(ikb(
                f"{get_positions[a]['position_name']} | {get_positions[a]['position_price']}₽ | {len(get_items)} шт",
                callback_data=f"products_add_position:{get_positions[a]['position_id']}:{category_id}"))
    if remover + cpage >= len(get_positions):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"products_add_position_backp:{remover - cpage}:{category_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"products_add_position_backp:{remover - cpage}:{category_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"products_add_position_nextp:{remover + cpage}:{category_id}"),
        )
    keyboard.add(ikb(bbutton, callback_data="back_add_products_to_category"))

    return keyboard

# Страницы позиций для покупки товаров
def products_shopitem_position_swipe_fp(remover, shop_id, city_id, lang):
    get_positions = get_positionsx(store_id=shop_id)
    keyboard = InlineKeyboardMarkup()
    print(remover, shop_id, city_id, lang)
    if city_id is None: city_id = 0
    position_rest = 0
    print(lang)
    if lang == 'ru':
        fwdbutton = "Далее ➡"
        bwdbutton = "⬅ Назад"
        bbutton = "⬅ Вернуться ↩"

    elif lang == 'en':
        fwdbutton = "Next ➡"
        bwdbutton = "⬅ Back"
        bbutton = "⬅ Back to UP ↩"

    if remover >= len(get_positions): remover -= 10
    print("||||")

    for count, a in enumerate(range(remover, len(get_positions))):
        if count < 10:
            if get_positions[a]['position_type'] == 1: position_rest = get_positions[a]['position_rest']
            if get_positions[a]['position_type'] == 2: position_rest = len(get_itemsx(position_id=get_positions[a]['position_id']))

            keyboard.add(ikb(
                f"{get_positions[a]['position_name']} | {get_positions[a]['position_price']}₽ | {position_rest} шт",
                callback_data=f"buy_parposition_open:{get_positions[a]['position_id']}:{shop_id}:{remover}:{city_id}:{lang}"))

    if len(get_positions) <= 10:
        pass
    elif remover < 10:
        keyboard.add(
            ikb(f"🔸 1/{math.ceil(len(get_positions) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"buy_parposition_swipe:{shop_id}:{remover + 10}:{city_id}:{lang}"),
        )
    elif remover + 10 >= len(get_positions):
        keyboard.add(
            ikb(bwdbutton, callback_data=f"buy_parposition_swipe:{shop_id}:{remover - 10}:{city_id}:{lang}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_positions) / 10)} 🔸", callback_data="..."),
        )
    else:
        keyboard.add(
            ikb(bwdbutton, callback_data=f"buy_parposition_swipe:{shop_id}:{remover - 10}:{city_id}:{lang}"),
            ikb(f"🔸 {str(remover + 10)[:-1]}/{math.ceil(len(get_positions) / 10)} 🔸", callback_data="..."),
            ikb(fwdbutton, callback_data=f"buy_parposition_swipe:{shop_id}:{remover + 10}:{city_id}:{lang}"),
        )
    keyboard.add(ikb(bbutton, callback_data=f"buy_shop_swipe:0:{city_id}:{lang}"))

    return keyboard


tgbot >keyboards>location_keyboards.py:

from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
import sqlite3
from tgbot.data.config import PATH_DATABASE

def geo_11_kb():
    markup = ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True, row_width=1)
    bt1 = KeyboardButton('📡 Поделиться своим местоположением', request_location=True)
    bt2 = KeyboardButton('📋 Выбрать город из списка')
    bt3 = KeyboardButton('⬆️ Выбрать город позже')
    markup.add(bt1, bt2, bt3)
    return markup

def geo_1_kb():
    markup = ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True, row_width=1)
    bt1 = KeyboardButton('📡 Поделиться своим местоположением', request_location=True)
    bt2 = KeyboardButton('📋 Выбрать город из списка')
    markup.add(bt1, bt2)
    return markup

def geo_2_kb(city_id, city):
    print(city_id, city)
    markup = InlineKeyboardMarkup(row_width=1)
    bt1 = InlineKeyboardButton('✅ Подтвердить', callback_data=f"geo_chosen_cities:{city_id}:{city}")
    bt2 = InlineKeyboardButton('Выбрать город из списка', callback_data='choice_city_list')
    markup.add(bt1, bt2)
    return markup

def geo_3_kb():
    markup = InlineKeyboardMarkup(row_width=6)
    #lang = "ru"
    #if lang == "ru":
    letters_list = ['А','Б','В','Г','Д','Е','Ж','З','И','Й','К','Л','М','Н','О','П','Р','С','Т','У','Х','Ч','Ш','Щ','Э','Ю','Я']
    #if lang == "en":
    #    letters_list = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    for letter in letters_list:
        button = InlineKeyboardButton(letter, callback_data=f"geo_first_letter:{letter}")
        markup.insert(button)
    return markup

def geo_4_kb(letter):
    print(letter)
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select id, city FROM data_cities where temp = ?'''
    cur.execute(query, (letter,))
    city = 0
    cities = cur.fetchall()
    conn.commit()
    print(len(cities))
    markup = InlineKeyboardMarkup(row_width=1)
    for city in cities:
        button = InlineKeyboardButton(str(city[1]), callback_data=f"geo_chosen_cities:{city[0]}:{city[1]}")
        markup.add(button)
    return markup


tgbot >keyboards>reply_z_all.py:
# - *- coding: utf- 8 - *-
from aiogram.types import ReplyKeyboardMarkup

from tgbot.data.config import get_admins, get_shopadmins
from tgbot.services.api_sqlite import get_userx, check_user_shop_exist, get_user_lang
from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR
#from tgbot.middlewares.i18n import I18nMiddleware
#from aiogram.contrib.middlewares.i18n import I18nMiddleware
#from tgbot.middlewares.i18n import I18nMiddleware
#i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
#I18nMiddleware.setup_middlewares(i18n)
#print(i18n)
# Alias for gettext method
#_ = i18n.gettext


# Кнопки главного меню
def menu_frep(user_id, lang):
    user_role = get_userx(user_id=user_id)['user_role']
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = "User" if user_role is None else user_role

    if lang == 'ru':
        buybtn = "🎁 Купить"
        sellbtn = "🌐 Продать"
        shopbtn = "🎁 Магазины"
        enbtn = "🏫 Кружки"
        entbtn = "Афиша"
        ptfbtn = "👤 Профиль"
        tubtn = "💰 Пополнить"
        crtbtn = "🧮 Корзина"
        supbtn = "☎ Поддержка"
        isbtn = "Я продавец"
        esbtn = "Админ Афиши"
        stabtn = "📊 Статистика"
        prtbtn = "Партнеры"
        pmbtn = "🎁 Управление товарами 🖍"
        stbtn = "⚙ Настройки"
        embtn = "🎫 Управление событиями 🖍"
        ufbtn = "🔆 Общие функции"
        psbtn = "🔑 Платежные системы"
        rsbtn = "Запросы продавцов"
        obtn = "🚛 Заказы"
        srbtn = "📊 Отчет о продажах"

    if lang == 'en':
        buybtn = "🎁 Buy"
        sellbtn = "🌐 Sell"
        shopbtn = "🎁 Shops"
        enbtn = "🏫 Cources"
        entbtn = "Events"
        ptfbtn = "👤 Profile"
        tubtn = "💰 Top Up"
        crtbtn = "🧮 Cart"
        supbtn = "☎ Support"
        isbtn = "I'm seller"
        esbtn = "Events Admin"
        stabtn = "📊 Statistic"
        prtbtn = "Partners"
        pmbtn = "🎁 Products Management 🖍"
        stbtn = "⚙ Settings"
        embtn = "🎫 Events Management 🖍"
        ufbtn = "🔆 General Functions"
        psbtn = "🔑 Payment Systems"
        rsbtn = "Sellers Request"
        obtn = "🚛 Orders"
        srbtn = "📊 Sales Report"

    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.row(buybtn, sellbtn)
    keyboard.row(shopbtn, entbtn)
    keyboard.row(ptfbtn, tubtn, crtbtn)

    if user_role is None or user_role == "":
        keyboard.row(supbtn, isbtn, esbtn, prtbtn)

    if user_role == "Admin": #in get_admins():
        keyboard.row(pmbtn, stabtn, prtbtn)
        keyboard.row(stbtn, embtn, ufbtn, psbtn)
        keyboard.row(rsbtn, obtn, srbtn)

    if user_role == "ShopAdmin":
        keyboard.row(supbtn, prtbtn)
        keyboard.row(pmbtn, psbtn)

    return keyboard

# Кнопки продавца
def lang_menu_frep(user_id):
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.row("🇷🇺 Русский","🇬🇧 English")

    return keyboard

# Кнопки продавца
def shop_admin_frep(lang):
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    if lang == 'ru':
        sabtn = "Отправить заявку"
        mmbtn = "⬅ Главное меню"
    if lang == 'en':
        sabtn = "Send Request"
        mmbtn = "⬅ Main Menu"

    keyboard.row(sabtn)
    keyboard.row(mmbtn)

    return keyboard


# Кнопки платежных систем
def payments_frep(lang):
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    if lang == 'ru':
        chqbtn = "🥝 Изменить QIWI 🖍"
        chkqbtn = "🥝 Проверить QIWI ♻"
        bqbtn = "🥝 Баланс QIWI 👁"
        mmbtn = "⬅ Главное меню"
        chybtn = "💳 Изменить Yoo 🖍"
        pmbtn = "🖲 Способы пополнения"
    if lang == 'en':
        chqbtn = "🥝 Change QIWI 🖍"
        chkqbtn = "🥝 Check QIWI ♻"
        bqbtn = "🥝 Balance QIWI 👁"
        mmbtn = "⬅ Main Menu"
        chybtn = "💳 Change Yoo 🖍"
        pmbtn = "🖲 Payment Methods"

    keyboard.row(chqbtn, chkqbtn, bqbtn)
    keyboard.row(mmbtn, chybtn, pmbtn)

    return keyboard


# Кнопки общих функций
def functions_frep(lang):
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    if lang == 'ru':
        fpbtn = "👤 Поиск профиля 🔍"
        msbtn = "📢 Рассылка"
        mslbtn = "📢 Рассылка_lite"
        fcbtn = "🧾 Поиск чеков 🔍"
        mmbtn = "⬅ Главное меню"
    if lang == 'en':
        fpbtn = "👤 Find Profile 🔍"
        mslbtn = "📢 MassSendlite"
        msbtn = "📢 Mass Send"
        fcbtn = "🧾 Find Checks 🔍"
        mmbtn = "⬅ Main Menu"

    keyboard.row(fpbtn, fcbtn)
    keyboard.row(msbtn, mslbtn)
    keyboard.row(mmbtn)

    return keyboard

# Кнопки запросов в продавцы
def seller_requests_frep(lang):
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    if lang == 'ru':
        keyboard.row("🖍 Посмотреть запросы")
        keyboard.row("⬅ Главное меню")
    if lang == 'en':
        keyboard.row("🖍 Show list requests")
        keyboard.row("⬅ Main Menu")

    return keyboard

# Кнопки настроек
def settings_frep(lang):
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    print(lang)
    if lang == 'ru':
        keyboard.row("🖍 Изменить данные", "🕹 Выключатели")
        keyboard.row("⬅ Главное меню")
    if lang == 'en':
        keyboard.row("🖍 Edit data", "🕹 Switches")
        keyboard.row("⬅ Main Menu")

    return keyboard

# Кнопки изменения товаров
def events_frep(lang):
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    print(lang)
    if lang == 'ru':
        cebtn = "📁 Создать событие ➕"
        chbtn = "📁 Изменить событие 🖍"
        dabtn = "📁 Удалить все события ❌"
        cpbtn = "🗃 Создать место ➕"
        chpbtn = "🗃 Изменить место 🖍"
        dapbtn = "🗃 Удалить все места ❌"
        cabtn = "🏪 Создать артиста ➕"
        chabtn = "🏪 Изменить артиста 🖍"
        daabtn = "🏪 Удалить всех артистов ❌"
        mmbtn = "⬅ Главное меню"

    if lang == 'en':
        cebtn = "📁 Create Event ➕"
        chbtn = "📁 Edit Event 🖍"
        dabtn = "📁 Delete all Events ❌"
        cpbtn = "🗃 Create Place ➕"
        chpbtn = "🗃 Edit Place 🖍"
        dapbtn = "🗃 Delete all Places ❌"
        cabtn = "🏪 Create Artist ➕"
        chabtn = "🏪 Edit Artist 🖍"
        daabtn = "🏪 Delete all Artists ❌"
        mmbtn = "⬅ Main Menu"

    keyboard.row(cebtn, chbtn, dabtn)
    keyboard.row(cpbtn, chpbtn, dapbtn)
    keyboard.row(cabtn, chabtn, daabtn)
    keyboard.row(mmbtn)

    return keyboard


# Кнопки изменения товаров
def items_frep(lang):
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    print(lang)
    if lang == 'ru':
        apbtn = "🎁 Добавить товары ➕"
        dpbtn = "🎁 Удалить товары 🖍"
        dapbtn = "🎁 Удалить все товары ❌"
        cpbtn = "📁 Создать позицию ➕"
        chpbtn = "📁 Изменить позицию 🖍"
        dagbtn = "📁 Удалить все позиции ❌"
        ccbtn = "🗃 Создать категорию ➕"
        chcbtn = "🗃 Изменить категорию 🖍"
        dacbtn = "🗃 Удалить все категории ❌"
        cshbtn = "🏪 Создать магазин ➕"
        chbtn = "🏪 Изменить магазин 🖍"
        dashbtn = "🏪 Удалить все магазины ❌"
        mmbtn = "⬅ Главное меню"
    if lang == 'en':
        apbtn = "🎁 Add Goods➕"
        dpbtn = "🎁 Delete Goods 🖍"
        dapbtn = "🎁 Delete All Goods ❌"
        cpbtn = "📁 Create Position ➕"
        chpbtn = "📁 Edit Position 🖍"
        dagbtn = "📁 Delete all Positions ❌"
        ccbtn = "🗃 Create Category ➕"
        chcbtn = "🗃 Edit Category 🖍"
        dacbtn = "🗃 Delete all Categories ❌"
        cshbtn = "🏪 Create Shop ➕"
        chbtn = "🏪 Edit Shop 🖍"
        dashbtn = "🏪 Delete all Shops ❌"
        mmbtn = "⬅ Main Menu"

    keyboard.row(apbtn, dpbtn, dapbtn)
    keyboard.row(cpbtn, chpbtn, dagbtn)
    keyboard.row(ccbtn, chcbtn, dacbtn)
    keyboard.row(cshbtn, chbtn, dashbtn)
    keyboard.row(mmbtn)

    return keyboard

# Кнопки изменения товаров
def items_sh_frep(lang):
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    if lang == 'ru':
        apbtn = "🎁 Добавить товары ➕"
        dpbtn = "🎁 Удалить товары 🖍"
        dapbtn = "🎁 Удалить все товары ❌"
        cpbtn = "📁 Создать позицию ➕"
        chpbtn = "📁 Изменить позицию 🖍"
        dagbtn = "📁 Удалить все позиции ❌"
        ccbtn = "🗃 Создать категорию ➕"
        chcbtn = "🗃 Изменить категорию 🖍"
        dacbtn = "🗃 Удалить все категории ❌"
        cshbtn = "🏪 Создать магазин ➕"
        chbtn = "🏪 Изменить магазин 🖍"
        dashbtn = "🏪 Удалить все магазины ❌"
        mmbtn = "⬅ Главное меню"
    if lang == 'en':
        apbtn = "🎁 Add Goods➕"
        dpbtn = "🎁 Delete Goods 🖍"
        dapbtn = "🎁 Delete All Goods ❌"
        cpbtn = "📁 Create position ➕"
        chpbtn = "📁 Edit position 🖍"
        dagbtn = "📁 Delete all positions ❌"
        ccbtn = "🗃 Create category ➕"
        chcbtn = "🗃 Edit category 🖍"
        dacbtn = "🗃 Delete all categories ❌"
        cshbtn = "🏪 Create shop ➕"
        chbtn = "🏪 Edit shop 🖍"
        dashbtn = "🏪 Delete all shops ❌"
        mmbtn = "⬅ Main Menu"

    keyboard.row(apbtn, dpbtn, dapbtn)
    keyboard.row(cpbtn, chpbtn, dagbtn)
    #keyboard.row("🗃 Создать категорию ➕", "🗃 Изменить категорию 🖍") #, "🗃 Удалить все категории ❌")
    #user_id = message.from_user.id
    #if check_user_shop_exist(message.from_user.id) == 'True':
    #keyboard.row("🏪 Изменить магазин 🖍") #, "🏪 Удалить все магазины ❌")
    #if check_user_shop_exist(message.from_user.id) == 'False':
    keyboard.row(cshbtn, chbtn)  # , "🏪 Удалить все магазины ❌")
    keyboard.row(mmbtn)

    return keyboard

# Завершение загрузки товаров
finish_load_rep = ReplyKeyboardMarkup(resize_keyboard=True)
finish_load_rep.row("📥 Закончить загрузку товаров")


tgbot >keyboards>shop_keyboards.py:
# - *- coding: utf- 8 - *-
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton as ikb

from tgbot.data.config import get_admins
from tgbot.services.api_sqlite_shop import get_all_shopx, get_shopx
from tgbot.services.api_sqlite import get_shopsxx, get_shopsxy

cpage = 10


# fp - flip page
# cpage - count page

################################################################################################
################################# СТРАНИЦЫ ИЗМЕНЕНИЯ МАГАЗИНА #################################
# Стартовые страницы выбора магазина для изменения
def shop_edit_open_fp(remover, user_id, lang):
    if user_id in get_admins():
        get_my_shops = get_shopsxy()
    else:
        get_my_shops = get_shopsxx(admin=user_id)

    keyboard = InlineKeyboardMarkup()
    print(len(get_my_shops))

    for count, a in enumerate(range(remover, len(get_my_shops))):
        if count < cpage:
            keyboard.add(ikb(f"{get_my_shops[a]['name']}",
                             callback_data=f"shop_edit_open:{get_my_shops[a]['shop_id']}:{remover}:{user_id}"))
    if len(get_my_shops) <= 10:
        pass
    elif len(get_my_shops) > cpage and remover < 10:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb("Далее ➡", callback_data=f"shop_edit_nextp:{remover + cpage}:{user_id}")
        )
    elif remover + cpage >= len(get_my_shops):
        keyboard.add(
            ikb("⬅ Назад", callback_data=f"shop_edit_backp:{remover - cpage}:{user_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="...")
        )
    else:
        keyboard.add(
            ikb("⬅ Назад", callback_data=f"shop_edit_backp:{remover - cpage}:{user_id}"),
            ikb(f"🔸 {str(remover + cpage)[:-1]} 🔸", callback_data="..."),
            ikb("Далее ➡", callback_data=f"shop_edit_nextp:{remover + cpage}:{user_id}"),
        )
    return keyboard


# Стартовые страницы выбора категории для добавления позиции
def position_create_shop_fp(remover):
    #get_shops = get_all_shopx()
    if user_id in get_admins():
        get_my_shops = get_shopsxy()
    else:
        get_my_shops = get_shopsxx(admin=user_id)
    keyboard = InlineKeyboardMarkup()
    for count, a in enumerate(range(remover, len(get_shops))):
        if count < cpage:
            keyboard.add(ikb(f"{get_my_shops[a]['shop_name']}",
                             callback_data=f"position_shop_create_here:{get_my_shops[a]['shop_id']}"))
    if len(get_my_shops) <= 10:
        pass
    elif len(get_my_shops) > cpage:
        keyboard.add(
            ikb("🔸 1 🔸", callback_data="..."),
            ikb(_("Далее ➡", locale=lang), callback_data=f"position_shop_create_nextp:{remover + cpage}")
        )

    return keyboard





tgbot >locales
tgbot >locales>en(folder)
tgbot >locales>ru(folder)
tgbot>middlewares
tgbot>middlewares>__pycache__
tgbot>middlewares>__init__.py:
# - *- coding: utf- 8 - *-
from aiogram import Dispatcher


from tgbot.data.config import I18N_DOMAIN, LOCALES_DIR
from tgbot.middlewares.exists_user import ExistsUserMiddleware
from tgbot.middlewares.throttling import ThrottlingMiddleware
from tgbot.middlewares.i18n import I18nMiddleware


# Подключение милдварей
def setup_middlewares(dp: Dispatcher):
    dp.middleware.setup(ExistsUserMiddleware())
    dp.middleware.setup(ThrottlingMiddleware())
    dp.middleware.setup(I18nMiddleware())

def setup_middleware(dp: Dispatcher):
    i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
    dp.middleware.setup(i18n)
    return i18n

#i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
#dp.middleware.setup(i18n)
#print(i18n)
#_ = i18n.gettext
#_ = i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
#_ = i18n

#print(i18n.find_locales())

#print(i18n.gettext("<b>📁 Enter type of goods, what you want to sell:</b>", locale='ru'))

tgbot>middlewares>exists_user.py:
# - *- coding: utf- 8 - *-
from aiogram import Dispatcher
from aiogram.dispatcher.middlewares import BaseMiddleware
from aiogram.types import Update


from tgbot.data.config import get_admins
from tgbot.loader import dp
from tgbot.services.api_sqlite import get_userx, add_userx, update_userx, get_settingsx
from tgbot.utils.const_functions import clear_html
from tgbot.utils.misc_functions import send_admins


async def notify(dp: Dispatcher, msg):
    print('Уведомление exists_user!')
    await send_admins(msg, markup="default")


# Проверка юзеров в БД и его добавление
class ExistsUserMiddleware(BaseMiddleware):
    def __init__(self):
        self.prefix = "key_prefix"
        super(ExistsUserMiddleware, self).__init__()

    async def on_process_update(self, update: Update, data: dict):
        if "message" in update:
            this_user = update.message.from_user
        elif "callback_query" in update:
            this_user = update.callback_query.from_user
        else:
            this_user = None

        if this_user is not None:
            get_settings = get_settingsx()
            get_prefix = self.prefix

            if (
                get_settings['status_work'] == "False"
                or this_user.id in get_admins()
            ) and not this_user.is_bot:
                get_user = get_userx(user_id=this_user.id)

                user_id = this_user.id
                user_login = this_user.username
                user_name = clear_html(this_user.first_name)
                if user_login is None: user_login = ""

                if get_user is None:
                    user_lang = 'ru'

                    add_userx(user_id, user_login.lower(), user_name, user_lang, "User")
                    if user_login:
                        await notify(dp, f"В боте новый пользователь:@{user_login}!")
                    else:
                        await notify(dp, f"В боте новый пользователь:{user_id}!")

                else:
                    if user_name != get_user['user_name']:
                        update_userx(get_user['user_id'], user_name=user_name)
                        await notify(dp, f"В боте пользователь, username: @{user_name}!")

                    if len(user_login) >= 1:
                        if user_login.lower() != get_user['user_login']:
                            update_userx(get_user['user_id'], user_login=user_login.lower())
                    else:
                        update_userx(get_user['user_id'], user_login="")

tgbot>middlewares>i18n_or.py:
# - *- coding: utf- 8 - *-
import os
from pathlib import Path
import gettext
from contextvars import ContextVar
from typing import Any, Dict, Tuple
from babel import Locale

from aiogram.types import Message, User
from tgbot.data.config import I18N_DOMAIN, LOCALES_DIR
from aiogram import Bot, Dispatcher, executor, types
from aiogram.dispatcher.handler import CancelHandler, current_handler
from aiogram.dispatcher.middlewares import BaseMiddleware
#from aiogram.contrib.middlewares.i18n import I18nMiddleware as BaseMiddleware

#from tgbot.data.config import I18N_DOMAIN, LOCALES_DIR

class I18nMiddleware(BaseMiddleware):
    """
    I18n middleware based on gettext util

    >>> dp = Dispatcher(bot)
    >>> i18n = I18nMiddleware(DOMAIN, LOCALES_DIR)
    >>> dp.middleware.setup(i18n)
    and then
    >>> _ = i18n.gettext
    or
    >>> _ = i18n = I18nMiddleware(DOMAIN_NAME, LOCALES_DIR)
    """

    #domain = 'messages'
    #BASE_DIR = 'tgbot' #Path(__file__).parent
    #path = f"{BASE_DIR}{os.sep}locales"

    ctx_locale = ContextVar('ctx_user_locale', default='ru')

    def __init__(self, domain='mybot', path='/var/local/bot3101f/tgbot/locales', default='ru'):  #domain={I18N_DOMAIN},
        """
        :param domain: domain
        :param path: path where located all *.mo files
        :param default: default locale name
        """
        #super(I18nMiddleware, self).__init__(domain='mybot', path='/var/local/bot3101f/tgbot/locales', default='ru')
        super(I18nMiddleware, self).__init__()

        if path is None:
            path = os.path.join(os.getcwd(), 'locales')

        self.domain = 'mybot' #domain
        self.path = '/var/local/bot3101f/tgbot/locales' #path
        self.default = 'ru' #default

        self.locales = self.find_locales()
        #self.locales = {'ru', 'en'}


    def find_locales(self) -> Dict[str, gettext.GNUTranslations]:
        """
        Load all compiled locales from path

        :return: dict with locales
        """
        translations = {}

        for name in os.listdir(self.path):
            print(name)
            if not os.path.isdir(self.path):
                continue
            mo_path = os.path.join(self.path, name, 'LC_MESSAGES', self.domain, '.mo')

            if os.path.exists(mo_path):
                with open(mo_path, 'rb') as fp:
                    translations[name] = gettext.GNUTranslations(fp)

        return translations

    def reload(self):
        """
        Hot reload locles
        """
        self.locales = self.find_locales()

    @property
    def available_locales(self) -> Tuple[str]:
        """
        list of loaded locales

        :return:
        """
        return tuple(self.locales.keys())

    def __call__(self, singular, plural=None, n=1, locale=None) -> str:
        return self.gettext(singular, plural, n, locale)

    def gettext(self, singular, plural=None, n=1, locale=None) -> str:
        """
        Get text

        :param singular:
        :param plural:
        :param n:
        :param locale:
        :return:
        """
        if locale is None:
            locale = self.ctx_locale.get()

        if locale not in self.locales:
            return singular if n == 1 else plural
        print(f"Locale: {locale}")
        translator = self.locales[locale]

        if plural is None:
            return translator.gettext(singular)
        else:
            return translator.ngettext(singular, plural, n)

    async def get_user_locale(self, action: str, args: Tuple[Any]) -> str:
        """
        User locale getter
        You can override the method if you want to use different way of getting user language.

        :param action: event name
        :param args: event arguments
        :return: locale name
        """
        user: types.User = types.User.get_current()
        if locale := user.locale:
            *_, data = args
            language = data['locale'] = locale.language
            return language

    async def trigger(self, action, args):
        """
        Event trigger

        :param action: event name
        :param args: event arguments
        :return:
        """
        if 'update' not in action \
                and 'error' not in action \
                and action.startswith('pre_process'):
            locale = await self.get_user_locale(action, args)
            self.ctx_locale.set(locale)
            return True

    async def set_user_locale(self, locale: str) -> None:
        if user := types.User.get_current():
            state = Dispatcher.get_current().current_state(user=user.id)

            async with state.proxy() as data:
                data["lang"] = locale
                i18n.ctx_locale.set(locale)
    #await i18n.set_user_locale(callback_data["selected_lang"])

#_ = i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
tgbot>middlewares>i18n.py:
# - *- coding: utf- 8 - *-
import os
from pathlib import Path
import gettext
from contextvars import ContextVar
from typing import Any, Dict, Tuple
from babel import Locale

from aiogram.types import Message, User
from tgbot.data.config import I18N_DOMAIN, LOCALES_DIR
from aiogram import Bot, Dispatcher, executor, types
from aiogram.dispatcher.handler import CancelHandler, current_handler
from aiogram.dispatcher.middlewares import BaseMiddleware
from tgbot.services.api_sqlite import get_user_lang, get_userx
#from aiogram.contrib.middlewares.i18n import I18nMiddleware as BaseMiddleware

#from tgbot.data.config import I18N_DOMAIN, LOCALES_DIR

class I18nMiddleware(BaseMiddleware):
    """
    I18n middleware based on gettext util

    >>> dp = Dispatcher(bot)
    >>> i18n = I18nMiddleware(DOMAIN, LOCALES_DIR)
    >>> dp.middleware.setup(i18n)
    and then
    >>> _ = i18n.gettext
    or
    >>> _ = i18n = I18nMiddleware(DOMAIN_NAME, LOCALES_DIR)
    """

    ctx_locale = ContextVar('ctx_user_locale', default=None)

    def __init__(self, domain='mybot', path=None, default='ru'):
        """
        :param domain: domain
        :param path: path where located all *.mo files
        :param default: default locale name
        """
        super(I18nMiddleware, self).__init__()

        if path is None:
            rd = Path(__file__).parents
            base_dir = rd[1]
            path = str(f"{base_dir}{os.sep}locales")
            #path = os.path.join(os.getcwd(), 'locales')

        self.domain = domain
        self.path = path
        self.default = default
        #self.locale = locale

        self.locales = self.find_locales()

    def find_locales(self) -> Dict[str, gettext.GNUTranslations]:
        """
        Load all compiled locales from path

        :return: dict with locales
        """
        translations = {}

        for name in os.listdir(self.path):
            if not os.path.isdir(self.path):
                continue
            mo_path = os.path.join(self.path, name, 'LC_MESSAGES', f'{self.domain}.mo')

            if os.path.exists(mo_path):
                with open(mo_path, 'rb') as fp:
                    translations[name] = gettext.GNUTranslations(fp)

        return translations

    def reload(self):
        """
        Hot reload locles
        """
        self.locales = self.find_locales()

    @property
    def available_locales(self) -> Tuple[str]:
        """
        list of loaded locales

        :return:
        """
        return tuple(self.locales.keys())

    def __call__(self, singular, plural=None, n=1, locale=None) -> str:
        return self.gettext(singular, plural, n, locale)

    def gettext(self, singular, plural=None, n=1, locale=None) -> str:
        """
        Get text

        :param singular:
        :param plural:
        :param n:
        :param locale:
        :return:
        """
        if locale is None:
            locale = self.ctx_locale.get()

        if locale not in self.locales:
            return singular if n == 1 else plural
        translator = self.locales[locale]

        if plural is None:
            return translator.gettext(singular)
        else:
            return translator.ngettext(singular, plural, n)

    async def get_user_locale(self, action: str, args: Tuple[Any]) -> str:
        """
        User locale getter
        You can override the method if you want to use different way of getting user language.

        :param action: event name
        :param args: event arguments
        :return: locale name
        """
        user: types.User = types.User.get_current()
        if locale := user.locale:
            *_, data = args
            language = data['locale'] = locale.language
            return language

    async def get_user_locale2(self, user_id) -> str:
        """
        User locale getter
        You can override the method if you want to use different way of getting user language.

        :param action: event name
        :param args: event arguments
        :return: locale name
        """
        user_lang = get_userx(user_id=user_id)['user_lang']
        if len(user_lang) == 0: user_lang = "ru"
        return user_lang

    async def set_user_locale(self, locale: str) -> None:
        if user := types.User.get_current():
            state = Dispatcher.get_current().current_state(user=user.id)

            async with state.proxy() as data:
                data["locale"] = locale
                i18n.ctx_locale.set(locale)

    async def trigger(self, action, args):
        """
        Event trigger

        :param action: event name
        :param args: event arguments
        :return:
        """
        if 'update' not in action \
                and 'error' not in action \
                and action.startswith('pre_process'):
            locale = await self.get_user_locale(action, args)
            self.ctx_locale.set(locale)
            return True

        if action == 'pre_process_error':
            self.ctx_locale.reset()
            return True

    '''async def process_message(self, message: types.Message) -> None:
        """
        Process message

        :param message:
        :return:
        """
        await self.set_user_locale(self.default)
        self.ctx_locale.set(self.default)'''

tgbot>middlewares>i18n3.py:
from typing import Any, Dict, Optional

from aiogram import Dispatcher
from aiogram.types import User
from aiogram.utils.i18n import I18n
from aiogram.utils.i18n import I18nMiddleware as BaseI18nMiddleware
from aiogram.dispatcher.middlewares import BaseMiddleware
from babel import Locale, UnknownLocaleError

from tgbot.data.config import I18N_DOMAIN, LOCALES_DIR #I18N_DEFAULT_LOCALE,
from tgbot.services.api_sqlite import *
#from src.models.user import UserModel


class I18nMiddleware(BaseI18nMiddleware):
    def get_internal_locale(self, language_code: str):
        if language_code and language_code in self.i18n.available_locales:
            return language_code

    def get_external_locale(self, user_id: str):
        user: UserModel = get_userx(user_id)

        if user and user.settings.language_code and user.settings.language_code in self.i18n.available_locales:
            return user.settings.language_code

    async def get_locale(self, event: TelegramObject, data: Dict[str, Any]) -> str:
        user: Optional[User] = data.get("event_from_user")

        if user is None:
            return self.i18n.default_locale

        internal_locale = self.get_internal_locale(user.language_code)
        print("internal_locale:", internal_locale)  # ! en
        external_locale = self.get_external_locale(user.id)
        print("external_locale:", external_locale)  # ! None

        locale = external_locale or internal_locale

        try:
            locale = Locale.parse(locale, sep="-")
            print("locale:", locale)  # ! en
        except UnknownLocaleError:
            return self.i18n.default_locale


def setup(dispatcher: Dispatcher):
    i18n = I18n(path=I18N_LOCALES_PATH,
                default_locale=I18N_DEFAULT_LOCALE, domain=I18N_DOMAIN)
    i18nMiddleware = I18nMiddleware(i18n=i18n)

    return dispatcher.message.middleware(i18nMiddleware)
tgbot>middlewares>i18n7.py:
# - *- coding: utf- 8 - *-
import os
import gettext
from contextvars import ContextVar
from typing import Any, Dict, Tuple
from babel import Locale

from aiogram.types import Message, User
from tgbot.data.config import I18N_DOMAIN, LOCALES_DIR
from aiogram import Bot, Dispatcher, executor, types
from aiogram.dispatcher.handler import CancelHandler, current_handler
#from aiogram.contrib.middlewares.i18n import I18nMiddleware as BaseMiddleware
from aiogram.dispatcher.middlewares import BaseMiddleware


#from tgbot.data.config import I18N_DOMAIN, LOCALES_DIR


class I18nMiddleware(BaseMiddleware):
    async def get_user_locale(self, action: str, args: Tuple[Any]) -> str:
        if user := types.User.get_current():
            locale: Locale = user.locale

            state = Dispatcher.get_current().current_state(user=user.id)
            try:
                async with state.proxy() as data:
                    return data["lang"]
            except KeyError:

                if locale:
                    *_, data = args
                    language = data['locale'] = locale.language
                    return language

    async def set_user_locale(self, locale: str) -> None:
        if user := types.User.get_current():
            state = Dispatcher.get_current().current_state(user=user.id)

            async with state.proxy() as data:
                data["lang"] = locale
                i18n.ctx_locale.set(locale)

i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)
tgbot>middlewares>throttling.py:
# - *- coding: utf- 8 - *-
from aiogram import types, Dispatcher
from aiogram.dispatcher.handler import CancelHandler, current_handler
from aiogram.dispatcher.middlewares import BaseMiddleware
from aiogram.types import Message
from aiogram.utils.exceptions import Throttled

from tgbot.data.config import get_admins


# Мидлварь для антиспама
class ThrottlingMiddleware(BaseMiddleware):
    def __init__(self, limit=0.5, key_prefix='antiflood_'):
        self.rate_limit = limit
        self.prefix = key_prefix
        super(ThrottlingMiddleware, self).__init__()

    async def on_process_message(self, message: Message, data: dict):
        handler = current_handler.get()
        dispatcher = Dispatcher.get_current()

        if handler:
            limit = getattr(handler, "throttling_rate_limit", self.rate_limit)
            key = getattr(handler, "throttling_key", f"{self.prefix}_{handler.__name__}")
        else:
            limit = self.rate_limit
            key = f"{self.prefix}_message"

        if message.from_user.id not in get_admins():
            try:
                await dispatcher.throttle(key, rate=limit)
            except Throttled as t:
                await self.message_throttled(message, t)
                raise CancelHandler() from t

    @staticmethod
    async def message_throttled(message: types.Message, throttled: Throttled):
        if throttled.exceeded_count <= 2:
            await message.reply("<b>❗ Пожалуйста, не спамьте.</b>")


# Изменение лимитов отправки сообщения у декораторов
def rate_limit(limit: int, key=None):
    def decorator(func):
        setattr(func, "throttling_rate_limit", limit)
        if key:
            setattr(func, "throttling_key", key)
        return func

    return decorator


tgbot >services
tgbot >services>__pycache__
tgbot >services>__init__.py:

tgbot >services>api_binance.py:
from binance.spot import Spot

client = Spot()

# Get server timestamp
print(client.time())
# Get klines of BTCUSDT at 1m interval
print(client.klines("BTCUSDT", "1m"))
# Get last 10 klines of BNBUSDT at 1h interval
print(client.klines("BNBUSDT", "1h", limit=10))

# API key/secret are required for user data endpoints
client = Spot(api_key='XXXXXXXXX', api_secret='XXXXXXXXX')

# Get account and balance information
print(client.account())




# Post a new order
params = {
    'coin': 'USDT',
    'status': '1',
    'recvWindow': 5000
}

#response = client.new_order(**params)
response = client.deposit_history(**params)
print(response)

# Post a new order
params = {
    'coin': 'USDT',
    'network': 'TRX',
    'recvWindow': 5000
}

#response = client.new_order(**params)
response2 = client.deposit_address(**params)
print(response2)
tgbot >services>api_cb.py:
# - *- coding: utf- 8 - *-
import asyncio
import json
import time

from aiohttp import ClientConnectorCertificateError
from async_class import AsyncClass
#from yoomoney import Client
from coinbase.wallet.client import Client

from tgbot.services.api_session import RequestsSession
from tgbot.services.api_sqlite import update_paymentx, get_upaymentx, get_paymentx, update_upaymentx
from tgbot.utils.misc_functions import send_admins


# Апи работы с YooMoney
class CoinbaseAPI(AsyncClass):
    async def __ainit__(self, suser_id=919148970, api_key=None, api_token=None):
        self.suser_id = 919148970
        self.api_token = get_upaymentx(self.suser_id)['coinbase_token']
        self.api_key = get_upaymentx(self.suser_id)['coinbase_key']
        self.pay_method = get_upaymentx(self.suser_id)['way_coinbase']
        print(self.api_token, self.api_key, self.pay_method)
        client = Client(api_key, api_secret)
        account_id = client.get_primary_account()['id']
        print("111")
        print(account_id)
        sum = float(str(get_amount / usdt_price)[:10]) #сколько сатох нужно юзеру оплатить
        address_for_tranz = client.create_address(account_id)['address'] #получение кошелька для оплаты
        print(address_for_tranz)

        '''if suser_id is not None:
            self.suser_id = suser_id
            self.api_token = get_upaymentx(self.suser_id)['coinbase_token']
            self.api_key = get_upaymentx(self.suser_id)['coinbase_key']
            self.pay_method = get_upaymentx(self.suser_id)['way_coinbase']
                #self.token = token
                #self.client_id = client_id
                #self.acc_number = acc_number
                #self.redirect_url = redirect_url
        else:
            #self.login = get_upaymentx(self.user_id)['qiwi_login']
            #self.token = get_upaymentx(self.user_id)['qiwi_token']
            #self.secret = get_upaymentx(self.user_id)['qiwi_secret']
            #self.login = get_paymentx()['qiwi_login']
            self.suser_id = 919148970
            self.api_token = get_upaymentx(self.suser_id)['coinbase_token']
            self.api_key = get_upaymentx(self.suser_id)['coinbase_key']
            self.pay_method = get_upaymentx(self.suser_id)['way_coinbase']
            #self.base_url = "https://yoomoney.ru/api/"
            #self.headers = {"authorization": f"Bearer {self.token}"}
            #self.client_id = get_paymentx()['yoo_client_id']
            #self.user_check_pass = user_check_pass
            #self.user_bill_pass = user_bill_pass
            #self.check_pass = check_pass
            #self.add_pass = add_pass
            #self.dp = dp
        print(self.api_token, self.api_key, self.pay_method)

            #api_key = 'QUmnMHJ7OrOJnIM4'
            #api_secret = 'gQr0L7ypPQXTpYRDzXJFILcAARRjBynH'
            #client = Client(api_key, api_secret)
            #account_id = client.get_primary_account()['id']


            #sum = int(sum) + 10 #прибавляется комиссия в btc
            #btc_price = round(float((client.get_buy_price(currency_pair='BTC-RUB')["amount"])))
            #print(btc_price)
            #sum = float(str(sum / btc_price)[:10]) #сколько сатох нужно юзеру оплатить
            #address_for_tranz = client.create_address(account_id)['address'] #получение кошелька для оплты
            #print(address_for_tranz)'''

    # Рассылка админам о нерабочем киви
    @staticmethod
    async def error_wallet():
        await send_admins("<b> Yoo кошелёк недоступен ❌</b>\n"
                          "❗ Как можно быстрее его замените ❗")

    #Обновление данных
    async def update_coinbase(self):
        update_upaymentx(user_id=self.suser_id, coinbase_key=self.api_key, coinbase_token=self.api_token, yoo_client_id=self.client_id)

    # Обязательная проверка перед каждым запросом
    async def pre_checker(self):
        if self.acc_number != "None":
            if self.add_pass:
                status, response = await self.check_account()
            else:
                status, response, code = await self.check_logpass()
            await asyncio.sleep(0.5)

            if self.add_pass:
                await self.dp.edit_text(response)
                if status:
                    update_upaymentx(user_id=self.suser_id, coinbase_key=self.api_key, coinbase_token=self.api_token, yoo_client_id=self.client_id)
                else:
                    return False
            elif self.check_pass:
                if status:
                    text_secret = "Отсутствует" if self.secret == "None" else self.secret
                    await self.dp.answer(f"<b> Coinbase кошелёк полностью функционирует ✅</b>\n"
                                         f"◾ Кошелек: <code>{self.login}</code>\n"
                                         f"◾ Токен: <code>{self.token}</code>")
                else:
                    await self.error_wallet()
                    return False
            elif self.user_bill_pass:
                if not status:
                    await self.dp.edit_text(
                        "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                        "⌛ Попробуйте чуть позже.</b>")
                    await self.error_wallet()
                    return False
            elif self.user_check_pass:
                if not status:
                    await self.dp.answer(
                        "❗ Извиняемся за доставленные неудобства, проверка временно недоступна.\n"
                        "⌛ Попробуйте чуть позже.", True)
                    await self.error_wallet()
                    return False
            elif not status:
                await self.error_wallet()
                return False

            return True
        else:
            if self.user_bill_pass:
                await self.dp.edit_text(
                    "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                    "⌛ Попробуйте чуть позже.</b>")
            await self.error_wallet()
            return False


    # Создание платежа
    async def bill_pay(self, get_amount, get_way):
        client = Client(api_key, api_secret)
        account_id = client.get_primary_account()['id']
        print(get_amount)
        sum = float(str(get_amount / usdt_price)[:10]) #сколько сатох нужно юзеру оплатить
        address_for_tranz = client.create_address(account_id)['address'] #получение кошелька для оплаты
        print(address_for_tranz)
        '''account_id = client.get_primary_account()['id']
        sum = int(sum) + 10 #прибавляется комиссия в btc
        usdt_price = round(float((client.get_buy_price(currency_pair='USDT-RUB')["amount"])))
        print(usdt_price)
        sum = float(str(sum / usdt_price)[:10]) #сколько сатох нужно юзеру оплатить
        address_for_tranz = client.create_address(account_id)['address'] #получение кошелька для оплты
        print(address_for_tranz)
        receipt = str(int(time.time() * 100))'''

        if get_way == "CoinBase":
            return_message = f"<b>🆙 Пополнение баланса USDT</b>\n" \
                             f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                             f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                             f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                             f"❗ У вас имеется 30 минут на оплату счета.\n" \
                             f"❗ Адрес:{address_for_tranz}.\n" \
                             f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                             f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                             f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"

            return return_message, receipt
        return False, False

    # Проверка платежа по форме
    async def check_formy(self, receipt):

        print(self.token)

        client = Client(self.token)
        history = client.operation_history(label=receipt)

        for operation in history.operations:

            pay_status = operation.status  # Получение статуса платежа
            pay_amount = int(float(operation.amount))  # Получение суммы платежа в рублях

        return pay_status, pay_amount

    # Проверка платежа по переводу
    async def check_send(self, receipt):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "payment-history",
                "v2",
                "payments",
                {"rows": 30, "operation": "IN"},
            )

            pay_status = False
            pay_amount = 0

            for check_pay in response['data']:
                if str(receipt) == str(check_pay['comment']):
                    if str(check_pay['sum']['currency']) == "643":
                        pay_status = True
                        pay_amount = int(float(check_pay['sum']['amount']))
                    else:
                        return_message = 1
                    break

            return_message = 3 if pay_status else 2
            return return_message, pay_amount

        return 4, False

tgbot >services>api_coinbasey.py:
# - *- coding: utf- 8 - *-
import asyncio
import json
import time

from aiohttp import ClientConnectorCertificateError
from async_class import AsyncClass
#from yoomoney import Client
from cb.wallet.client import Client
#from yoomoney import Quickpay


from tgbot.services.api_session import RequestsSession
from tgbot.services.api_sqlite import update_paymentx, get_upaymentx, get_paymentx, update_upaymentx
from tgbot.utils.misc_functions import send_admins


# Апи работы с YooMoney
class CoinbaseAPI(AsyncClass):
    async def __ainit__(self, suser_id=None, api_key=None, api_token=None):
        #self.user_id = user_id
        #check_pass=False, user_bill_pass=False, user_check_pass=False
        if suser_id is not None:
            self.suser_id = suser_id
            self.api_token = get_upaymentx(self.suser_id)['coinbase_token']
                #self.token = token
                #self.client_id = client_id
                #self.acc_number = acc_number
                #self.redirect_url = redirect_url
        else:
            #self.login = get_upaymentx(self.user_id)['qiwi_login']
            #self.token = get_upaymentx(self.user_id)['qiwi_token']
            #self.secret = get_upaymentx(self.user_id)['qiwi_secret']
            #self.login = get_paymentx()['qiwi_login']
            self.suser_id = 919148970
            self.api_token = get_upaymentx(self.suser_id)['coinbase_token']
        self.api_key = get_upaymentx(self.suser_id)['coinbase_key']
        self.pay_method = get_upaymentx(self.suser_id)['way_coinbase']
        #self.base_url = "https://yoomoney.ru/api/"
        #self.headers = {"authorization": f"Bearer {self.token}"}
        #self.client_id = get_paymentx()['yoo_client_id']
        #self.user_check_pass = user_check_pass
        #self.user_bill_pass = user_bill_pass
        #self.check_pass = check_pass
        #self.add_pass = add_pass
        #self.dp = dp
        api_key = 'QUmnMHJ7OrOJnIM4'
        api_secret = 'gQr0L7ypPQXTpYRDzXJFILcAARRjBynH'
        client = Client(api_key, api_secret)
        account_id = client.get_primary_account()['id']
        #sum = int(sum) + 10 #прибавляется комиссия в btc
        #btc_price = round(float((client.get_buy_price(currency_pair='BTC-RUB')["amount"])))
        #print(btc_price)
        #sum = float(str(sum / btc_price)[:10]) #сколько сатох нужно юзеру оплатить
        address_for_tranz = client.create_address(account_id)['address'] #получение кошелька для оплты
        print(address_for_tranz)

    # Рассылка админам о нерабочем киви
    @staticmethod
    async def error_wallet():
        await send_admins("<b> Yoo кошелёк недоступен ❌</b>\n"
                          "❗ Как можно быстрее его замените ❗")

    #Обновление данных
    async def update_coinbase(self):
        update_upaymentx(user_id=self.suser_id, coinbase_key=self.api_key, coinbase_token=self.api_token, yoo_client_id=self.client_id)


    # Обязательная проверка перед каждым запросом
    async def pre_checker(self):
        if self.acc_number != "None":
            if self.add_pass:
                status, response = await self.check_account()
            else:
                status, response, code = await self.check_logpass()
            await asyncio.sleep(0.5)

            if self.add_pass:
                await self.dp.edit_text(response)
                if status:
                    update_upaymentx(user_id=self.suser_id, coinbase_key=self.api_key, coinbase_token=self.api_token, yoo_client_id=self.client_id)
                else:
                    return False
            elif self.check_pass:
                if status:
                    text_secret = "Отсутствует" if self.secret == "None" else self.secret
                    await self.dp.answer(f"<b> Coinbase кошелёк полностью функционирует ✅</b>\n"
                                         f"◾ Кошелек: <code>{self.login}</code>\n"
                                         f"◾ Токен: <code>{self.token}</code>")
                else:
                    await self.error_wallet()
                    return False
            elif self.user_bill_pass:
                if not status:
                    await self.dp.edit_text(
                        "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                        "⌛ Попробуйте чуть позже.</b>")
                    await self.error_wallet()
                    return False
            elif self.user_check_pass:
                if not status:
                    await self.dp.answer(
                        "❗ Извиняемся за доставленные неудобства, проверка временно недоступна.\n"
                        "⌛ Попробуйте чуть позже.", True)
                    await self.error_wallet()
                    return False
            elif not status:
                await self.error_wallet()
                return False

            return True
        else:
            if self.user_bill_pass:
                await self.dp.edit_text(
                    "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                    "⌛ Попробуйте чуть позже.</b>")
            await self.error_wallet()
            return False

    # Проверка баланса
    async def get_balance(self):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "funding-sources",
                "v2",
                "accounts",
            )

            save_balance = []
            for balance in response['accounts']:
                if balance['alias'] == "qw_wallet_usd":
                    save_balance.append(f"🇺🇸 Долларов: <code>{balance['balance']['amount']}$</code>")

                if balance['alias'] == "qw_wallet_rub":
                    save_balance.append(f"🇷🇺 Рублей: <code>{balance['balance']['amount']}₽</code>")

                if balance['alias'] == "qw_wallet_eur":
                    save_balance.append(f"🇪🇺 Евро: <code>{balance['balance']['amount']}€</code>")

                if balance['alias'] == "qw_wallet_kzt":
                    save_balance.append(f"🇰🇿 Тенге: <code>{balance['balance']['amount']}₸</code>")

            save_balance = "\n".join(save_balance)
            await self.dp.answer(f"<b>🥝 Баланс кошелька <code>{self.login}</code> составляет:</b>\n"
                                 f"{save_balance}")

    # Проверка п2п ключа
    async def check_secret(self):
        try:
            qiwi_p2p = QiwiP2P(self.secret)
            bill = qiwi_p2p.bill(amount=1, lifetime=1)
            qiwi_p2p.reject(bill_id=bill.bill_id)
            return True
        except Exception:
            return False


    def creat_bill_btc(self, callback_id, message_id, sum, name_good, amount):

        if self.get_coinbasedata() is None: bot.answer_callback_query(callback_query_id=callback_id, show_alert=True, text='Принять деньги на btc кошелёк в данный момент невозможно!')
        else:
            api_key, api_secret = get_settings()
            client = Client(api_key, api_secret)
            account_id = client.get_primary_account()['id']
            sum = int(sum) + 10 #прибавляется комиссия в btc
            btc_price = round(float((client.get_buy_price(currency_pair='USDT-RUB')["amount"])))
            print(btc_price)
            sum = float(str(sum / btc_price)[:10]) #сколько сатох нужно юзеру оплатить
            address_for_tranz = client.create_address(account_id)['address'] #получение кошелька для оплты

            with open(f'data/Temp/{str(self)}.txt', 'w', encoding='utf-8') as f:
                f.write(str(amount)+ '\n')
                f.write(str(sum)+ '\n')
                f.write(address_for_tranz)
            key = telebot.types.InlineKeyboardMarkup()
            key.add(telebot.types.InlineKeyboardButton(text='Проверить оплату', callback_data='Проверить оплату USDT'))
            key.add(telebot.types.InlineKeyboardButton(text = 'Вернуться в начало', callback_data = 'Вернуться в начало'))
            try:
                bot.edit_message_text(
                    self=self,
                    message_id=message_id,
                    text=f'Чтобы купить {name_good} количеством {str(amount)}'
                    + '\nПереведите `'
                    + str(sum)
                    + '` usdt на адрес `'
                    + str(address_for_tranz)
                    + '`',
                    parse_mode='Markdown',
                    reply_markup=key,
                )
            except Exception:
                pass
            he_client.append(self)
    # Создание платежа
    async def bill_pay(self, get_amount, get_way):
        #print(self, get_amount, get_way)

        receipt = str(int(time.time() * 100))
        #print(self)

        if get_way == "Coinbase":
            quickpay = Quickpay(
            receiver=self.acc_number, #'410011512189686', 
            quickpay_form="shop",
            targets="Pay for goods in bot",
            paymentType="SB",
            sum=get_amount,
            label=receipt,
            )

            print(quickpay.base_url)

            send_requests = quickpay.base_url

            print(quickpay.redirected_url)

            return_message = f"<b>🆙 Пополнение баланса USDT</b>\n" \
                             f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                             f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                             f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                             f"❗ У вас имеется 30 минут на оплату счета.\n" \
                             f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                             f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                             f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"

            return return_message, send_requests, receipt
        return False, False, False

    # Проверка платежа по форме
    async def check_formy(self, receipt):

        print(self.token)

        client = Client(self.token)
        history = client.operation_history(label=receipt)

        for operation in history.operations:

            pay_status = operation.status  # Получение статуса платежа
            pay_amount = int(float(operation.amount))  # Получение суммы платежа в рублях

        return pay_status, pay_amount

    # Проверка платежа по переводу
    async def check_send(self, receipt):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "payment-history",
                "v2",
                "payments",
                {"rows": 30, "operation": "IN"},
            )

            pay_status = False
            pay_amount = 0

            for check_pay in response['data']:
                if str(receipt) == str(check_pay['comment']):
                    if str(check_pay['sum']['currency']) == "643":
                        pay_status = True
                        pay_amount = int(float(check_pay['sum']['amount']))
                    else:
                        return_message = 1
                    break

            return_message = 3 if pay_status else 2
            return return_message, pay_amount

        return 4, False

    # Запросы
'''    async def _request(self, action, version, get_way, params=None):
        url = self.base_url.format(action, version, self.login, get_way)

        rSession: RequestsSession = self.dp.bot['rSession']
        session = await rSession.get_session()

        try:
            response = await session.get(url, params=params, headers=self.headers, ssl=False)
            return True, json.loads((await response.read()).decode()), response.status
        except ClientConnectorCertificateError:
            return False, None, "CERTIFICATE_VERIFY_FAILED"
        except:
            return False, None, response.status'''

tgbot >services>api_qiwi-orig.py:
# - *- coding: utf- 8 - *-
import asyncio
import json
import time

from aiohttp import ClientConnectorCertificateError
from async_class import AsyncClass
from pyqiwip2p import QiwiP2P

from tgbot.services.api_session import RequestsSession
from tgbot.services.api_sqlite import update_paymentx, get_paymentx
from tgbot.utils.misc_functions import send_admins


# Апи работы с QIWI
class QiwiAPI(AsyncClass):
    async def __ainit__(self, dp, login=None, token=None, secret=None, add_pass=False,
                        check_pass=False, user_bill_pass=False, user_check_pass=False):
        if login is not None:
            self.login = login
            self.token = token
            self.secret = secret
        else:
            self.login = get_paymentx()['qiwi_login']
            self.token = get_paymentx()['qiwi_token']
            self.secret = get_paymentx()['qiwi_secret']

        self.base_url = "https://edge.qiwi.com/{}/{}/persons/{}/{}"
        self.headers = {"authorization": f"Bearer {self.token}"}
        self.nickname = get_paymentx()['qiwi_nickname']
        self.user_check_pass = user_check_pass
        self.user_bill_pass = user_bill_pass
        self.check_pass = check_pass
        self.add_pass = add_pass
        self.dp = dp

    # Рассылка админам о нерабочем киви
    @staticmethod
    async def error_wallet():
        await send_admins("<b>🥝 Qiwi кошелёк недоступен ❌</b>\n"
                          "❗ Как можно быстрее его замените ❗")

    # Обязательная проверка перед каждым запросом
    async def pre_checker(self):
        if self.login != "None":
            if self.add_pass:
                status, response = await self.check_account()
            else:
                status, response, code = await self.check_logpass()
            await asyncio.sleep(0.5)

            if self.add_pass:
                await self.dp.edit_text(response)
                if status:
                    update_paymentx(qiwi_login=self.login, qiwi_token=self.token, qiwi_secret=self.secret)
                else:
                    return False
            elif self.check_pass:
                if status:
                    text_secret = "Отсутствует" if self.secret == "None" else self.secret
                    await self.dp.answer(f"<b>🥝 Qiwi кошелёк полностью функционирует ✅</b>\n"
                                         f"◾ Номер: <code>{self.login}</code>\n"
                                         f"◾ Токен: <code>{self.token}</code>\n"
                                         f"◾ Приватный ключ: <code>{text_secret}</code>")
                else:
                    await self.error_wallet()
                    return False
            elif self.user_bill_pass:
                if not status:
                    await self.dp.edit_text(
                        "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                        "⌛ Попробуйте чуть позже.</b>")
                    await self.error_wallet()
                    return False
            elif self.user_check_pass:
                if not status:
                    await self.dp.answer(
                        "❗ Извиняемся за доставленные неудобства, проверка временно недоступна.\n"
                        "⌛ Попробуйте чуть позже.", True)
                    await self.error_wallet()
                    return False
            elif not status:
                await self.error_wallet()
                return False

            return True
        else:
            if self.user_bill_pass:
                await self.dp.edit_text(
                    "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                    "⌛ Попробуйте чуть позже.</b>")
            await self.error_wallet()
            return False

    # Проверка баланса
    async def get_balance(self):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "funding-sources",
                "v2",
                "accounts",
            )

            save_balance = []
            for balance in response['accounts']:
                if balance['alias'] == "qw_wallet_usd":
                    save_balance.append(f"🇺🇸 Долларов: <code>{balance['balance']['amount']}$</code>")

                if balance['alias'] == "qw_wallet_rub":
                    save_balance.append(f"🇷🇺 Рублей: <code>{balance['balance']['amount']}₽</code>")

                if balance['alias'] == "qw_wallet_eur":
                    save_balance.append(f"🇪🇺 Евро: <code>{balance['balance']['amount']}€</code>")

                if balance['alias'] == "qw_wallet_kzt":
                    save_balance.append(f"🇰🇿 Тенге: <code>{balance['balance']['amount']}₸</code>")

            save_balance = "\n".join(save_balance)
            await self.dp.answer(f"<b>🥝 Баланс кошелька <code>{self.login}</code> составляет:</b>\n"
                                 f"{save_balance}")

    # Получение никнейма аккаунта
    async def get_nickname(self):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "qw-nicknames",
                "v1",
                "nickname",
            )

            if response['nickname'] is None:
                return False, "❗ На аккаунте отсутствует QIWI Никнейм. Установите его в настройках своего кошелька."
            else:
                return True, response['nickname']

        return False, ""

    # Проверка аккаунта (логпаса и п2п)
    async def check_account(self):
        status_history, response_history, code_history = await self.check_logpass()
        status_balance, response_balance, code_balance = await self._request(
            "funding-sources",
            "v2",
            "accounts"
        )

        if status_history and status_balance:
            if self.secret == "None":
                return True, "<b>🥝 QIWI кошелёк был успешно изменён ✅</b>"
            status_secret = await self.check_secret()
            if status_secret:
                return True, "<b>🥝 QIWI кошелёк был успешно изменён ✅</b>"
            else:
                return_message = "<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                     "<code>▶ Код ошибки: Неверный приватный ключ</code>\n" \
                                     "❕ Указывайте ПРИВАТНЫЙ КЛЮЧ, а не публичный. " \
                                     "Приватный ключ заканчивается на ="
        elif 400 in [code_history, code_balance]:
            return_message = f"<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Код ошибки: Номер телефона указан в неверном формате</code>"
        elif 401 in [code_history, code_balance]:
            return_message = f"<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Код ошибки: Неверный токен или истек срок действия токена API</code>"
        elif 403 in [code_history, code_balance]:
            return_message = f"<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Ошибка: Нет прав на данный запрос (недостаточно разрешений у токена API)</code>"
        elif code_history == "CERTIFICATE_VERIFY_FAILED":
            return_message = "<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Код ошибки: CERTIFICATE_VERIFY_FAILED certificate verify failed: self signed certificate in certificate chain</code>\n" \
                                 f"❗ Ваш сервер/дедик/устройство блокирует запросы к QIWI. Отключите антивирус или другие блокирующие ПО."
        else:
            return_message = "<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Код ошибки: {code_history}/{code_balance}</code>"

        return False, return_message

    # Проверка логпаса киви
    async def check_logpass(self):
        status, response, code = await self._request(
            "payment-history",
            "v2",
            "payments",
            {"rows": 1, "operation": "IN"},
        )

        if status and "data" in response:
            return True, response, code
        else:
            return False, None, code

    # Проверка п2п ключа
    async def check_secret(self):
        try:
            qiwi_p2p = QiwiP2P(self.secret)
            bill = qiwi_p2p.bill(amount=1, lifetime=1)
            qiwi_p2p.reject(bill_id=bill.bill_id)
            return True
        except Exception:
            return False

    # Создание платежа
    async def bill_pay(self, get_amount, get_way):
        response = await self.pre_checker()
        if response:
            receipt = str(int(time.time() * 100))

            if get_way == "Form":
                qiwi = QiwiP2P(self.secret)
                bill = qiwi.bill(bill_id=receipt, amount=get_amount, comment=receipt)
                send_requests = bill.pay_url

                return_message = f"<b>🆙 Пополнение баланса</b>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                                 f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                                 f"❗ У вас имеется 30 минут на оплату счета.\n" \
                                 f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"
            elif get_way == "Number":
                send_requests = f"https://qiwi.com/payment/form/99?extra%5B%27account%27%5D={self.login}&amountInteger=" \
                                f"{get_amount}&amountFraction=0&extra%5B%27comment%27%5D={receipt}&currency=" \
                                f"643&blocked%5B0%5D=sum&blocked%5B1%5D=comment&blocked%5B2%5D=account"

                return_message = f"<b>🆙 Пополнение баланса</b>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                                 f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                                 f"📞 QIWI кошелёк: <code>{self.login}</code>\n" \
                                 f"🏷 Комментарий: <code>{receipt}</code>\n" \
                                 f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"
            elif get_way == "Nickname":
                send_requests = f"https://qiwi.com/payment/form/99999?amountInteger={get_amount}&amountFraction=0&currency=643" \
                                f"&extra%5B%27comment%27%5D={receipt}&extra%5B%27account%27%5D={self.nickname}&blocked%5B0%5D=" \
                                f"comment&blocked%5B1%5D=account&blocked%5B2%5D=sum&0%5Bextra%5B%27accountType%27%5D%5D=nickname"

                return_message = f"<b>🆙 Пополнение баланса</b>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                                 f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                                 f"❗ Не забудьте указать <u>КОММЕНТАРИЙ</u> к платежу\n" \
                                 f"Ⓜ QIWI Никнейм: <code>{self.nickname}</code>\n" \
                                 f"🏷 Комментарий: <code>{receipt}</code>\n" \
                                 f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"

            return return_message, send_requests, receipt
        return False, False, False

    # Проверка платежа по форме
    async def check_form(self, receipt):
        qiwi_p2p = QiwiP2P(self.secret)
        get_pay = qiwi_p2p.check(bill_id=receipt)

        pay_status = get_pay.status  # Получение статуса платежа
        pay_amount = int(float(get_pay.amount))  # Получение суммы платежа в рублях

        return pay_status, pay_amount

    # Проверка платежа по переводу
    async def check_send(self, receipt):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "payment-history",
                "v2",
                "payments",
                {"rows": 30, "operation": "IN"},
            )

            pay_status = False
            pay_amount = 0

            for check_pay in response['data']:
                if str(receipt) == str(check_pay['comment']):
                    if str(check_pay['sum']['currency']) == "643":
                        pay_status = True
                        pay_amount = int(float(check_pay['sum']['amount']))
                    else:
                        return_message = 1
                    break

            return_message = 3 if pay_status else 2
            return return_message, pay_amount

        return 4, False

    # Запросы
    async def _request(self, action, version, get_way, params=None):
        url = self.base_url.format(action, version, self.login, get_way)

        rSession: RequestsSession = self.dp.bot['rSession']
        session = await rSession.get_session()

        try:
            response = await session.get(url, params=params, headers=self.headers, ssl=False)
            return True, json.loads((await response.read()).decode()), response.status
        except ClientConnectorCertificateError:
            return False, None, "CERTIFICATE_VERIFY_FAILED"
        except Exception:
            return False, None, response.status

tgbot >services>api_qiwi.py:
# - *- coding: utf- 8 - *-
import asyncio
import json
import time

from aiohttp import ClientConnectorCertificateError
from async_class import AsyncClass
from pyqiwip2p import QiwiP2P

from tgbot.services.api_session import RequestsSession
from tgbot.services.api_sqlite import update_paymentx, get_upaymentx, update_upaymentx, get_settingsx
from tgbot.data.config import get_admins
from tgbot.utils.misc_functions import send_admins


# Апи работы с QIWI
class QiwiAPI(AsyncClass):
    async def __ainit__(self, dp, login=None, token=None, secret=None, add_pass=False,
                        check_pass=False, user_bill_pass=False, user_check_pass=False, **kwargs):

        print(dp['chat']['id'])
        self.suser_id = dp['chat']['id'] or 919148970
        self.login = get_upaymentx(self.suser_id)['qiwi_login']
        self.token = get_upaymentx(self.suser_id)['qiwi_token']
        self.secret = get_upaymentx(self.suser_id)['qiwi_secret']

        self.base_url = "https://edge.qiwi.com/{}/{}/persons/{}/{}"
        self.headers = {"authorization": f"Bearer {self.token}"}
        self.nickname = get_upaymentx(self.suser_id)['qiwi_nickname']
        self.user_check_pass = user_check_pass
        self.user_bill_pass = user_bill_pass
        self.check_pass = check_pass
        self.add_pass = add_pass
        self.dp = dp

        print(self)
        

    # Рассылка админам о нерабочем киви
    @staticmethod
    async def error_wallet():
        await send_admins("<b>🥝 Qiwi кошелёк недоступен ❌</b>\n"
                          "❗ Как можно быстрее его замените ❗")

    # Обязательная проверка перед каждым запросом
    async def pre_checker(self):
        if self.login != "None":
            if self.add_pass:
                status, response = await self.check_account()
            else:
                status, response, code = await self.check_logpass()
            await asyncio.sleep(0.5)

            if self.add_pass:
                await self.dp.edit_text(response)
                if status:
                    update_upaymentx(user_id=self.suser_id, qiwi_login=self.login, qiwi_token=self.token, qiwi_secret=self.secret)
                else:
                    return False
            elif self.check_pass:
                if status:
                    text_secret = "Отсутствует" if self.secret == "None" else self.secret
                    await self.dp.answer(f"<b>🥝 Qiwi кошелёк полностью функционирует ✅</b>\n"
                                         f"◾ Номер: <code>{self.login}</code>\n"
                                         f"◾ Токен: <code>{self.token}</code>\n"
                                         f"◾ Приватный ключ: <code>{text_secret}</code>")
                else:
                    await self.error_wallet()
                    return False
            elif self.user_bill_pass:
                if not status:
                    await self.dp.edit_text(
                        "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                        "⌛ Попробуйте чуть позже.</b>")
                    await self.error_wallet()
                    return False
            elif self.user_check_pass:
                if not status:
                    await self.dp.answer(
                        "❗ Извиняемся за доставленные неудобства, проверка временно недоступна.\n"
                        "⌛ Попробуйте чуть позже.", True)
                    await self.error_wallet()
                    return False
            elif not status:
                await self.error_wallet()
                return False

            return True
        else:
            if self.user_bill_pass:
                await self.dp.edit_text(
                    "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                    "⌛ Попробуйте чуть позже.</b>")
            await self.error_wallet()
            return False

    # Проверка баланса
    async def get_balance(self):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "funding-sources",
                "v2",
                "accounts",
            )

            save_balance = []
            for balance in response['accounts']:
                if balance['alias'] == "qw_wallet_usd":
                    save_balance.append(f"🇺🇸 Долларов: <code>{balance['balance']['amount']}$</code>")

                if balance['alias'] == "qw_wallet_rub":
                    save_balance.append(f"🇷🇺 Рублей: <code>{balance['balance']['amount']}₽</code>")

                if balance['alias'] == "qw_wallet_eur":
                    save_balance.append(f"🇪🇺 Евро: <code>{balance['balance']['amount']}€</code>")

                if balance['alias'] == "qw_wallet_kzt":
                    save_balance.append(f"🇰🇿 Тенге: <code>{balance['balance']['amount']}₸</code>")

            save_balance = "\n".join(save_balance)
            await self.dp.answer(f"<b>🥝 Баланс кошелька <code>{self.login}</code> составляет:</b>\n"
                                 f"{save_balance}")

    # Получение никнейма аккаунта
    async def get_nickname(self):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "qw-nicknames",
                "v1",
                "nickname",
            )

            if response['nickname'] is None:
                return False, "❗ На аккаунте отсутствует QIWI Никнейм. Установите его в настройках своего кошелька."
            else:
                return True, response['nickname']

        return False, ""

    # Проверка аккаунта (логпаса и п2п)
    async def check_account(self):
        status_history, response_history, code_history = await self.check_logpass()
        status_balance, response_balance, code_balance = await self._request(
            "funding-sources",
            "v2",
            "accounts"
        )

        if status_history and status_balance:
            if self.secret == "None":
                return True, "<b>🥝 QIWI кошелёк был успешно изменён ✅</b>"
            status_secret = await self.check_secret()
            if status_secret:
                return True, "<b>🥝 QIWI кошелёк был успешно изменён ✅</b>"
            else:
                return_message = "<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                     "<code>▶ Код ошибки: Неверный приватный ключ</code>\n" \
                                     "❕ Указывайте ПРИВАТНЫЙ КЛЮЧ, а не публичный. " \
                                     "Приватный ключ заканчивается на ="
        elif 400 in [code_history, code_balance]:
            return_message = f"<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Код ошибки: Номер телефона указан в неверном формате</code>"
        elif 401 in [code_history, code_balance]:
            return_message = f"<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Код ошибки: Неверный токен или истек срок действия токена API</code>"
        elif 403 in [code_history, code_balance]:
            return_message = f"<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Ошибка: Нет прав на данный запрос (недостаточно разрешений у токена API)</code>"
        elif code_history == "CERTIFICATE_VERIFY_FAILED":
            return_message = "<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Код ошибки: CERTIFICATE_VERIFY_FAILED certificate verify failed: self signed certificate in certificate chain</code>\n" \
                                 f"❗ Ваш сервер/дедик/устройство блокирует запросы к QIWI. Отключите антивирус или другие блокирующие ПО."
        else:
            return_message = "<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Код ошибки: {code_history}/{code_balance}</code>"

        return False, return_message

    # Проверка логпаса киви
    async def check_logpass(self):
        status, response, code = await self._request(
            "payment-history",
            "v2",
            "payments",
            {"rows": 1, "operation": "IN"},
        )

        if status and "data" in response:
            return True, response, code
        else:
            return False, None, code

    # Проверка п2п ключа
    async def check_secret(self):
        try:
            qiwi_p2p = QiwiP2P(self.secret)
            bill = qiwi_p2p.bill(amount=1, lifetime=1)
            qiwi_p2p.reject(bill_id=bill.bill_id)
            return True
        except Exception:
            return False

    # Создание платежа
    async def bill_pay(self, get_amount, get_way):
        response = await self.pre_checker()
        if response:
            receipt = str(int(time.time() * 100))

            if get_way == "Form":
                qiwi = QiwiP2P(self.secret)
                bill = qiwi.bill(bill_id=receipt, amount=get_amount, comment=receipt)
                send_requests = bill.pay_url

                return_message = f"<b>🆙 Пополнение баланса</b>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                                 f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                                 f"❗ У вас имеется 30 минут на оплату счета.\n" \
                                 f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"
            elif get_way == "Number":
                send_requests = f"https://qiwi.com/payment/form/99?extra%5B%27account%27%5D={self.login}&amountInteger=" \
                                f"{get_amount}&amountFraction=0&extra%5B%27comment%27%5D={receipt}&currency=" \
                                f"643&blocked%5B0%5D=sum&blocked%5B1%5D=comment&blocked%5B2%5D=account"

                return_message = f"<b>🆙 Пополнение баланса</b>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                                 f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                                 f"📞 QIWI кошелёк: <code>{self.login}</code>\n" \
                                 f"🏷 Комментарий: <code>{receipt}</code>\n" \
                                 f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🔄 Важно!!! После оплаты, нажмите на <code>Проверить оплату</code>"
            elif get_way == "Nickname":
                send_requests = f"https://qiwi.com/payment/form/99999?amountInteger={get_amount}&amountFraction=0&currency=643" \
                                f"&extra%5B%27comment%27%5D={receipt}&extra%5B%27account%27%5D={self.nickname}&blocked%5B0%5D=" \
                                f"comment&blocked%5B1%5D=account&blocked%5B2%5D=sum&0%5Bextra%5B%27accountType%27%5D%5D=nickname"

                return_message = f"<b>🆙 Пополнение баланса</b>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                                 f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                                 f"❗ Не забудьте указать <u>КОММЕНТАРИЙ</u> к платежу\n" \
                                 f"Ⓜ QIWI Никнейм: <code>{self.nickname}</code>\n" \
                                 f"🏷 Комментарий: <code>{receipt}</code>\n" \
                                 f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"

            return return_message, send_requests, receipt
        return False, False, False

    # Проверка платежа по форме
    async def check_form(self, receipt):
        qiwi_p2p = QiwiP2P(self.secret)
        get_pay = qiwi_p2p.check(bill_id=receipt)

        pay_status = get_pay.status  # Получение статуса платежа
        pay_amount = int(float(get_pay.amount))  # Получение суммы платежа в рублях

        return pay_status, pay_amount

    # Проверка платежа по переводу
    async def check_send(self, receipt):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "payment-history",
                "v2",
                "payments",
                {"rows": 30, "operation": "IN"},
            )

            pay_status = False
            pay_amount = 0

            for check_pay in response['data']:
                if str(receipt) == str(check_pay['comment']):
                    if str(check_pay['sum']['currency']) == "643":
                        pay_status = True
                        pay_amount = int(float(check_pay['sum']['amount']))
                    else:
                        return_message = 1
                    break

            return_message = 3 if pay_status else 2
            return return_message, pay_amount

        return 4, False

    # Запросы
    async def _request(self, action, version, get_way, params=None):
        url = self.base_url.format(action, version, self.login, get_way)

        rSession: RequestsSession = self.dp.bot['rSession']
        session = await rSession.get_session()

        try:
            response = await session.get(url, params=params, headers=self.headers, ssl=False)
            return True, json.loads((await response.read()).decode()), response.status
        except ClientConnectorCertificateError:
            return False, None, "CERTIFICATE_VERIFY_FAILED"
        except Exception:
            return False, None, response.status

tgbot >services>api_qiwi2.py:
# - *- coding: utf- 8 - *-
import asyncio
import json
import time

from aiohttp import ClientConnectorCertificateError
from async_class import AsyncClass
from pyqiwip2p import QiwiP2P

from tgbot.services.api_session import RequestsSession
from tgbot.services.api_sqlite import update_paymentx, get_paymentx, get_upaymentx, update_upaymentx
from tgbot.utils.misc_functions import send_admins


# Апи работы с QIWI
class QiwiAPI(AsyncClass):
    async def __ainit__(self, dp, login=None, token=None, secret=None, add_pass=False,
                        check_pass=False, user_bill_pass=False, user_check_pass=False):

        if login is not None:
            self.login = login
            self.token = token
            self.secret = secret
        else:

            #self.login = get_upaymentx(self.user_id)['qiwi_login']
            #self.token = get_upaymentx(self.user_id)['qiwi_token']
            #self.secret = get_upaymentx(self.user_id)['qiwi_secret']
            self.login = get_paymentx()['qiwi_login']
            self.token = get_paymentx()['qiwi_token']
            self.secret = get_paymentx()['qiwi_secret']


        self.base_url = "https://edge.qiwi.com/{}/{}/persons/{}/{}"
        self.headers = {"authorization": f"Bearer {self.token}"}
        self.nickname = get_paymentx()['qiwi_nickname']
        self.user_check_pass = user_check_pass
        self.user_bill_pass = user_bill_pass
        self.check_pass = check_pass
        self.add_pass = add_pass
        self.dp = dp
        

    # Рассылка админам о нерабочем киви
    @staticmethod
    async def error_wallet():
        await send_admins("<b>🥝 Qiwi кошелёк недоступен ❌</b>\n"
                          "❗ Как можно быстрее его замените ❗")

    # Обязательная проверка перед каждым запросом
    async def pre_checker(self):
        if self.login != "None":
            if self.add_pass:
                status, response = await self.check_account()
            else:
                status, response, code = await self.check_logpass()
            await asyncio.sleep(0.5)

            if self.add_pass:
                await self.dp.edit_text(response)
                if status:
                    update_upaymentx(qiwi_login=self.login, qiwi_token=self.token, qiwi_secret=self.secret)
                else:
                    return False
            elif self.check_pass:
                if status:
                    text_secret = "Отсутствует" if self.secret == "None" else self.secret
                    await self.dp.answer(f"<b>🥝 Qiwi кошелёк полностью функционирует ✅</b>\n"
                                         f"◾ Номер: <code>{self.login}</code>\n"
                                         f"◾ Токен: <code>{self.token}</code>\n"
                                         f"◾ Приватный ключ: <code>{text_secret}</code>")
                else:
                    await self.error_wallet()
                    return False
            elif self.user_bill_pass:
                if not status:
                    await self.dp.edit_text(
                        "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                        "⌛ Попробуйте чуть позже.</b>")
                    await self.error_wallet()
                    return False
            elif self.user_check_pass:
                if not status:
                    await self.dp.answer(
                        "❗ Извиняемся за доставленные неудобства, проверка временно недоступна.\n"
                        "⌛ Попробуйте чуть позже.", True)
                    await self.error_wallet()
                    return False
            elif not status:
                await self.error_wallet()
                return False

            return True
        else:
            if self.user_bill_pass:
                await self.dp.edit_text(
                    "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                    "⌛ Попробуйте чуть позже.</b>")
            await self.error_wallet()
            return False

    # Проверка баланса
    async def get_balance(self):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "funding-sources",
                "v2",
                "accounts",
            )

            save_balance = []
            for balance in response['accounts']:
                if balance['alias'] == "qw_wallet_usd":
                    save_balance.append(f"🇺🇸 Долларов: <code>{balance['balance']['amount']}$</code>")

                if balance['alias'] == "qw_wallet_rub":
                    save_balance.append(f"🇷🇺 Рублей: <code>{balance['balance']['amount']}₽</code>")

                if balance['alias'] == "qw_wallet_eur":
                    save_balance.append(f"🇪🇺 Евро: <code>{balance['balance']['amount']}€</code>")

                if balance['alias'] == "qw_wallet_kzt":
                    save_balance.append(f"🇰🇿 Тенге: <code>{balance['balance']['amount']}₸</code>")

            save_balance = "\n".join(save_balance)
            await self.dp.answer(f"<b>🥝 Баланс кошелька <code>{self.login}</code> составляет:</b>\n"
                                 f"{save_balance}")

    # Получение никнейма аккаунта
    async def get_nickname(self):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "qw-nicknames",
                "v1",
                "nickname",
            )

            if response['nickname'] is None:
                return False, "❗ На аккаунте отсутствует QIWI Никнейм. Установите его в настройках своего кошелька."
            else:
                return True, response['nickname']

        return False, ""

    # Проверка аккаунта (логпаса и п2п)
    async def check_account(self):
        status_history, response_history, code_history = await self.check_logpass()
        status_balance, response_balance, code_balance = await self._request(
            "funding-sources",
            "v2",
            "accounts"
        )

        if status_history and status_balance:
            if self.secret == "None":
                return True, "<b>🥝 QIWI кошелёк был успешно изменён ✅</b>"
            status_secret = await self.check_secret()
            if status_secret:
                return True, "<b>🥝 QIWI кошелёк был успешно изменён ✅</b>"
            else:
                return_message = "<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                     "<code>▶ Код ошибки: Неверный приватный ключ</code>\n" \
                                     "❕ Указывайте ПРИВАТНЫЙ КЛЮЧ, а не публичный. " \
                                     "Приватный ключ заканчивается на ="
        elif 400 in [code_history, code_balance]:
            return_message = f"<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Код ошибки: Номер телефона указан в неверном формате</code>"
        elif 401 in [code_history, code_balance]:
            return_message = f"<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Код ошибки: Неверный токен или истек срок действия токена API</code>"
        elif 403 in [code_history, code_balance]:
            return_message = f"<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Ошибка: Нет прав на данный запрос (недостаточно разрешений у токена API)</code>"
        elif code_history == "CERTIFICATE_VERIFY_FAILED":
            return_message = "<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Код ошибки: CERTIFICATE_VERIFY_FAILED certificate verify failed: self signed certificate in certificate chain</code>\n" \
                                 f"❗ Ваш сервер/дедик/устройство блокирует запросы к QIWI. Отключите антивирус или другие блокирующие ПО."
        else:
            return_message = "<b>🥝 Введённые QIWI данные не прошли проверку ❌</b>\n" \
                                 f"<code>▶ Код ошибки: {code_history}/{code_balance}</code>"

        return False, return_message

    # Проверка логпаса киви
    async def check_logpass(self):
        status, response, code = await self._request(
            "payment-history",
            "v2",
            "payments",
            {"rows": 1, "operation": "IN"},
        )

        if status and "data" in response:
            return True, response, code
        else:
            return False, None, code

    # Проверка п2п ключа
    async def check_secret(self):
        try:
            qiwi_p2p = QiwiP2P(self.secret)
            bill = qiwi_p2p.bill(amount=1, lifetime=1)
            qiwi_p2p.reject(bill_id=bill.bill_id)
            return True
        except Exception:
            return False

    # Создание платежа
    async def bill_pay(self, get_amount, get_way):
        response = await self.pre_checker()
        if response:
            receipt = str(int(time.time() * 100))

            if get_way == "Form":
                qiwi = QiwiP2P(self.secret)
                bill = qiwi.bill(bill_id=receipt, amount=get_amount, comment=receipt)
                send_requests = bill.pay_url

                return_message = f"<b>🆙 Пополнение баланса</b>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                                 f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                                 f"❗ У вас имеется 30 минут на оплату счета.\n" \
                                 f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"
            elif get_way == "Number":
                send_requests = f"https://qiwi.com/payment/form/99?extra%5B%27account%27%5D={self.login}&amountInteger=" \
                                f"{get_amount}&amountFraction=0&extra%5B%27comment%27%5D={receipt}&currency=" \
                                f"643&blocked%5B0%5D=sum&blocked%5B1%5D=comment&blocked%5B2%5D=account"

                return_message = f"<b>🆙 Пополнение баланса</b>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                                 f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                                 f"📞 QIWI кошелёк: <code>{self.login}</code>\n" \
                                 f"🏷 Комментарий: <code>{receipt}</code>\n" \
                                 f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"
            elif get_way == "Nickname":
                send_requests = f"https://qiwi.com/payment/form/99999?amountInteger={get_amount}&amountFraction=0&currency=643" \
                                f"&extra%5B%27comment%27%5D={receipt}&extra%5B%27account%27%5D={self.nickname}&blocked%5B0%5D=" \
                                f"comment&blocked%5B1%5D=account&blocked%5B2%5D=sum&0%5Bextra%5B%27accountType%27%5D%5D=nickname"

                return_message = f"<b>🆙 Пополнение баланса</b>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                                 f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                                 f"❗ Не забудьте указать <u>КОММЕНТАРИЙ</u> к платежу\n" \
                                 f"Ⓜ QIWI Никнейм: <code>{self.nickname}</code>\n" \
                                 f"🏷 Комментарий: <code>{receipt}</code>\n" \
                                 f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"

            return return_message, send_requests, receipt
        return False, False, False

    # Проверка платежа по форме
    async def check_form(self, receipt):
        qiwi_p2p = QiwiP2P(self.secret)
        get_pay = qiwi_p2p.check(bill_id=receipt)

        pay_status = get_pay.status  # Получение статуса платежа
        pay_amount = int(float(get_pay.amount))  # Получение суммы платежа в рублях

        return pay_status, pay_amount

    # Проверка платежа по переводу
    async def check_send(self, receipt):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "payment-history",
                "v2",
                "payments",
                {"rows": 30, "operation": "IN"},
            )

            pay_status = False
            pay_amount = 0

            for check_pay in response['data']:
                if str(receipt) == str(check_pay['comment']):
                    if str(check_pay['sum']['currency']) == "643":
                        pay_status = True
                        pay_amount = int(float(check_pay['sum']['amount']))
                    else:
                        return_message = 1
                    break

            return_message = 3 if pay_status else 2
            return return_message, pay_amount

        return 4, False

    # Запросы
    async def _request(self, action, version, get_way, params=None):
        url = self.base_url.format(action, version, self.login, get_way)

        rSession: RequestsSession = self.dp.bot['rSession']
        session = await rSession.get_session()

        try:
            response = await session.get(url, params=params, headers=self.headers, ssl=False)
            return True, json.loads((await response.read()).decode()), response.status
        except ClientConnectorCertificateError:
            return False, None, "CERTIFICATE_VERIFY_FAILED"
        except Exception:
            return False, None, response.status

tgbot >services>api_session.py:
# - *- coding: utf- 8 - *-
from typing import Optional

import aiohttp


# Асинхронная сессия для запросов
class AsyncSession:
    def __init__(self) -> None:
        self._session: Optional[aiohttp.ClientSession] = None

    # Вызов сессии
    async def get_session(self) -> aiohttp.ClientSession:
        if self._session is None:
            new_session = aiohttp.ClientSession()
            self._session = new_session

        return self._session

    # Закрытие сессии
    async def close(self) -> None:
        if self._session is None:
            return None

        await self._session.close()

# Асинхронная сессия для запросов
class RequestsSession:
    def __init__(self) -> None:
        self._session: Optional[aiohttp.ClientSession] = None

    # Вызов сессии
    async def get_session(self) -> aiohttp.ClientSession:
        if self._session is None:
            new_session = aiohttp.ClientSession()
            self._session = new_session

        return self._session

    # Закрытие сессии
    async def close(self) -> None:
        if self._session is None:
            return None

        await self._session.close()
tgbot >services>api_sqllite_advert.py:
# - *- coding: utf- 8 - *-
import math
import random
import sqlite3
import json
import datetime

from tgbot.data.config_adv import PATH_DATABASE
from tgbot.utils.const_functions import get_unix, get_date, clear_html


# Преобразование полученного списка в словарь
def dict_factory(cursor, row):
    return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}

####################################################################################################
##################################### ФОРМАТИРОВАНИЕ ЗАПРОСА #######################################
# Форматирование запроса без аргументов
def update_format(sql, parameters: dict):
    if "XXX" not in sql: sql += " XXX "

    values = ", ".join([
        f"{item} = ?" for item in parameters
    ])
    sql = sql.replace("XXX", values)

    return sql, list(parameters.values())


# Форматирование запроса с аргументами
def update_format_args(sql, parameters: dict):
    sql = f"{sql} WHERE "

    sql += " AND ".join([
        f"{item} = ?" for item in parameters
    ])

    return sql, list(parameters.values())

########################################### ЗАПРОСЫ НА ПРОДАВЦА ########################
########################################################################################
def create_seller_request(user_id, requesttxt):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_requests "
                    "(requester, datetime, state, requesttxt) "
                    "VALUES (?, ?, ?, ?)",
                    [user_id, get_unix(), 'created', requesttxt])
        con.commit()

# Получение всех запросов продавцов
def get_all_randtgaccounts():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts"
        return con.execute(sql).fetchall()

#Проыерка на дубли username
def check_dbfor_invited_username(username):
    print('Проверка на существование записи об инвайте username api_sqlite_advert.py  67')
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT count(*) FROM storage_tgparse "
        dbrow = []
        #count = 0
        dbrow = con.execute(
            f"{sql}WHERE state='invited' AND username = ?", [username]
        ).fetchone()[0]

        print(f'Проверяем статус invited {username} в БД: {dbrow}')
        return dbrow >= 1
        #return dbrow

# Удаление корзины
def remove_ordersx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_orders"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

# Удаление позиций корзины
def remove_orders_itemx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_orders_items"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

#Проыерка на дубли username
def check_dbfor_username(username):
    print('Проверка на существование записи username api_sqlite.py  67')
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT count(*) FROM storage_tgparse "
        #sql, parameters = update_format_args(sql, kwargs)
        #return con.execute(sql, parameters).fetchone()
        #sql, parameters = update_format(sql, kwargs)
        #parameters.append(user_id)
        dbrow = []
        #count = 0
        dbrow = con.execute(f"{sql}WHERE username = ?", [username]).fetchone()[0]
        #print(len(dbrow))
        print(dbrow)
        #count = len(dbrow)
        #print(str(dbrow['username']))
        #dbrow=dbrow.strip("(")
        #dbrow=dbrow.strip(")")
        #dbrow=dbrow.strip(",")
        #con.commit()
        print(f'Проверяем {username} в БД')
        return dbrow >= 1

# Удаление аккаунта ТГ
def remove_accountx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_tgaccounts"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

#Пользователи по статусам
def get_all_tgaccounts_states():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT source, groupname, group_id, state, count(username) FROM storage_tgparse GROUP BY source, groupname, group_id, state"
        return con.execute(sql).fetchall()

# Получение всех запросов продавцов
def get_tgaccount_statecounts(account_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        #sql = "SELECT state, invited24, last FROM storage_tgaccounts "
        sql = "SELECT invited24 FROM storage_tgaccounts "
        return con.execute(f"{sql}WHERE account_id = ?", [account_id]).fetchone()

# Получение всех запросов продавцов
def get_all_tgaccounts_phones_to_invite():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT phone, tg_api_id, tg_api_hash FROM storage_tgaccounts WHERE state='available' LIMIT 3"
        return con.execute(sql).fetchall()

# Получение всех запросов продавцов
def get_all_tgaccounts_to_invite():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts WHERE state='available'"
        return con.execute(sql).fetchall()

# Получение всех запросов продавцов
def get_all_avtgaccounts():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts WHERE state='available'"
        return con.execute(sql).fetchall()

# Получение всех запросов продавцов
def get_all_avtgaccountsend():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts WHERE state='available'"
        return con.execute(sql).fetchall()

# Получение всех покупок
def get_all_partnersx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_partners"
        tt = con.execute(sql).fetchall()
        return json.dumps(tt)

# Получение номеров по статусам
def get_all_tgaccounts_time_wb():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts WHERE state!='banned' ORDER BY date(waitfor24) ASC"
        return con.execute(sql).fetchall()

# Получение номеров по статусам
def get_all_tgaccounts_time():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts ORDER BY date(waitfor24) ASC"
        return con.execute(sql).fetchall()

# Получение номеров по статусам
def get_all_tgaccounts_phones_to_invite():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts"
        return con.execute(sql).fetchall()

# Получение номеров по статусам
def get_all_tgaccounts():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts"
        return con.execute(sql).fetchall()

# Получение всех запросов продавцов
def get_tgaccounts_statecounts(account_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        #sql = "SELECT state, invited24, last FROM storage_tgaccounts "
        sql = "SELECT invited24 FROM storage_tgaccounts "
        return con.execute(f"{sql}WHERE account_id = ?", [account_id]).fetchone()

# Добавление аккаунта ТГ в БД
def add_tgacc_todb(username, user_id, access_hash, name, source, groupname, group_id, tag, state='created'):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_tgparse "
                    "(username, user_id, access_hash, name, source, groupname, group_id, tag, state) "
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [username, user_id, access_hash, name, source, groupname, group_id, tag, state])
        print("addok")
        con.commit()

def add_post_to_plan(ct, user_id, send_message, mode, caption=''):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        if ct == 'text':
            ct, user_id, post_text, post_photo, post_video, post_animation, mode, caption  = ct, user_id, send_message, 0, 0, 0, mode, 0
        if ct == 'photo':
            ct, user_id, post_text, post_photo, post_video, post_animation, mode, caption   = ct, user_id, 0, send_message, 0, 0, mode, caption
        if ct == 'video':
            ct, user_id, post_text, post_photo, post_video, post_animation, mode, caption   = ct, user_id, 0, 0, send_message, 0, mode, caption
        if ct == 'animation':
            ct, user_id, post_text, post_photo, post_video, post_animation, mode, caption   = ct, user_id, 0, 0, 0, send_message, mode, caption

        con.execute("INSERT INTO storage_posts "
                    "(ct, user_id, post_text, post_photo, post_video, post_animation, mode, caption) "
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                    [ct, user_id, post_text, post_photo, post_video, post_animation, mode, caption])

        con.commit()

# Получение всех запросов продавцов
def get_lastpost():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        #sql = "SELECT state, invited24, last FROM storage_tgaccounts "
        sql = "SELECT MAX(post_id) as post_id FROM storage_posts GROUP BY user_id"
        return con.execute(sql).fetchone()[0]

# Получение пользователя
def get_postx(post_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_posts "
        #sql, parameters = update_format_args(sql, kwargs)
        return con.execute(f"{sql}WHERE post_id = ?", [post_id]).fetchone()
        #return con.execute(sql, parameters).fetchone()

# Получение всех запросов продавцов
def get_planed_postx(mode = "evening"):
    with sqlite3.connect(PATH_DATABASE) as con:
        print("-->")
        #con.row_factory = dict_factory
        #if mode == 'evening':
        #    inc = "mode = 'evening' "
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_posts "
        return con.execute(f"{sql}WHERE mode = ?", [mode]).fetchall()

#есть ли магазин у пользователя
def check_user_shop_exist(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT a.user_role, b.admin, b.name FROM storage_users a LEFT JOIN storage_shop b ON(a.user_id=b.admin)"
        shopadmin = con.execute(f"{sql}WHERE a.user_id = ?", [user_id]).fetchone()
        print(shopadmin)
        if (
            shopadmin['user_role'] == "ShopAdmin"
            and shopadmin['admin'] is not None
        ): return shopadmin['name']
        elif shopadmin['user_role'] == "Admin": return False
        #else: return shopadmin['admin']

#есть ли магазин у пользователя
def check_user_artist_exist(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT a.user_role, b.admin, b.name FROM storage_users a LEFT JOIN storage_artists b ON(a.user_id=b.admin)"
        shopadmin = con.execute(f"{sql}WHERE a.user_id = ?", [user_id]).fetchone()
        print(shopadmin)
        if (
            shopadmin['user_role'] == "ShopAdmin"
            and shopadmin['admin'] is not None
        ): return shopadmin['name']
        elif shopadmin['user_role'] == "Admin": return False
        #else: return shopadmin['admin']

# Добавление аккаунта ТГ в БД
def add_account_todb(xid, xhash, xphone, invited24, state='created'):
    with sqlite3.connect(PATH_DATABASE) as con:
        datenow = datetime.datetime.now()
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_tgaccounts "
                    "(tg_api_id, tg_api_hash, phone, invited24, date, state) "
                    "VALUES (?, ?, ?, ?, ?, ?)",
                    [xid, xhash, xphone, invited24, datenow, state])
        con.commit()
        #print(con.lastrowid)

# Получение всех запросов продавцов
def get_lasttgaccount():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        #sql = "SELECT state, invited24, last FROM storage_tgaccounts "
        sql = "SELECT MAX(account_id) as acc FROM storage_tgaccounts GROUP BY account_id"
        return con.execute(sql).fetchone()[0]

# Группы в ТГ
def groups_telegram():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT group_id, groupname, count(acc_id) as countacc FROM storage_tgparse WHERE groupname != '' AND source = 'groups' AND state = 'created' GROUP BY group_id ORDER BY group_id ASC"
        return con.execute(sql).fetchall()

# Пользователи группы для инвайта
def first_grouptosendbyid(groupid, start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = f"SELECT * FROM storage_tgparse WHERE sendstate = 'created' AND source = 'groups' AND group_id=? ORDER BY acc_id ASC LIMIT {start},{count}"
        return con.execute(sql, [groupid]).fetchall()

def firstgeo_tosend(state, start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = f"SELECT * FROM storage_tgparse WHERE sendstate = ? AND source = 'geoparse' ORDER BY acc_id ASC LIMIT {start},{count}"
        return con.execute(sql, [state]).fetchall()
        #return con.execute(sql).fetchall()

# Пользователи группы для инвайта
def first_groupsavtoinvite():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = f"SELECT group_id, groupname, COUNT(acc_id) as counta FROM storage_tgparse WHERE state = 'created' AND source = 'groups' ORDER BY counta DESC"
        return con.execute(sql).fetchall()

# Пользователи группы для инвайта
def first_idsgrouptoinvitebyid(groupid, start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = f"SELECT acc_id FROM storage_tgparse WHERE state = 'created' AND source = 'groups' AND group_id=? ORDER BY acc_id ASC LIMIT {start},{count}"
        return con.execute(sql, [groupid]).fetchall()

# Пользователи группы для инвайта
def first_grouptoinvitebyid(groupid, start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = f"SELECT * FROM storage_tgparse WHERE state = 'created' AND source = 'groups' AND group_id=? ORDER BY acc_id ASC LIMIT {start},{count}"
        return con.execute(sql, [groupid]).fetchall()


# Пользователи группы для инвайта
def first_grouptoreinvite(start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        sql = f"SELECT * FROM storage_tgparse WHERE state IN( 'created', 'invited') AND source = 'groups' AND group_id IN(1846537176, 1665002522, 1823230047, 1691713993, 1434376033, 1701254391, 1182435855, 1488989705, 1205441227, 1654568702, 1467842316, 1520545687, 1620128468, 1789219249, 1620128468, 1557904116, 1559445350, 1224708719, 1604938781, 1100353162, 1244748525) ORDER BY acc_id ASC" # ASC LIMIT {start},{count}
        return con.execute(sql).fetchall()

# Пользователи группы для инвайта
def first_grouptoreinvite2(start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        sql = f"SELECT * FROM storage_tgparse WHERE state IN( 'created', 'invited') AND source = 'groups' AND group_id IN(1846537176, 1665002522, 1823230047, 1691713993, 1434376033, 1701254391, 1182435855, 1488989705, 1205441227, 1654568702, 1467842316, 1520545687, 1620128468, 1789219249, 1620128468, 1557904116, 1559445350, 1224708719, 1604938781, 1100353162, 1244748525) ORDER BY acc_id ASC LIMIT {start},{count}"
        return con.execute(sql).fetchall()

# Пользователи группы для инвайта
def first_grouptoinvite(groupname, start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = f"SELECT * FROM storage_tgparse WHERE state = 'created' AND source = 'groups' AND groupname=? ORDER BY acc_id ASC LIMIT {start},{count}"
        return con.execute(sql, [groupname]).fetchall()

# Последние 10 покупок
def first_toinvite(state, start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = f"SELECT * FROM storage_tgparse WHERE state = ? AND source = 'groups' ORDER BY acc_id ASC LIMIT {start},{count}"
        return con.execute(sql, [state]).fetchall()

def firstgeo_toinvite(state, start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = f"SELECT * FROM storage_tgparse WHERE state = ? AND source = 'geoparse' ORDER BY acc_id ASC LIMIT {start},{count}"
        return con.execute(sql, [state]).fetchall()
        #return con.execute(sql).fetchall()

# Редактирование запроса
def update_tgparsex(acc_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_tgparse SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(acc_id)
        con.execute(f"{sql}WHERE acc_id = ?", parameters)
        con.commit()

# Редактирование запроса
def update_tgaccounts(account_id, pole):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        inc = ""
        if pole == 'available':
            inc = " state = 'available', invited24 = 0 "
        elif pole == 'banned':
            inc = " state = 'banned' "
        elif pole == 'invited24':
            inc = " invited24 = invited24 + 1, last = datetime('now') "
        elif pole == 'iter24':
            inc = " iter24 = iter24 + 1 "
        elif pole == 'sended24':
            inc = " sended24 = sended24 + 1 "
        elif pole == 'waitfor24':
            inc = " state = 'wait', waitfor24 = datetime('now', '+1 day') "
        sql = f"UPDATE storage_tgaccounts SET {inc}"
        #sql, parameters = update_format(sql, kwargs)
        #parameters.append(account_id)
        con.execute(f"{sql}WHERE account_id = ?", [account_id])
        con.commit()

#удаление аккаунта
def delete_tgacc(acc_id):
    print(f"Удаляем аккаунт{acc_id}")
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_tgaccounts "
        #sql, parameters = update_format_args(sql, kwargs)
        #sql, user_id = update_format(sql, user_id)
        con.execute(f"{sql}WHERE account_id = ?", [acc_id])
        con.commit()

# Получение всех запросов продавцов
def get_all_requestx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT DISTINCT requester as user_id FROM storage_requests ORDER BY datetime ASC"
        return con.execute(sql).fetchall()

# Удаление запроса
def delete_requests_userx(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_requests "
        #sql, parameters = update_format_args(sql, kwargs)
        #sql, user_id = update_format(sql, user_id)
        con.execute(f"{sql}WHERE requester = ?", [user_id])
        con.commit()

# Редактирование запроса
def update_requestx(user_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_requests SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(user_id)
        con.execute(f"{sql}WHERE user_id = ?", parameters)
        con.commit()


# Проверка принадлежности позиции в каталоге
def check_position_owner(user_id, position_id):
    print('Проверка принадлежности позиции api_sqlite.py  86')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT position_user_id FROM storage_position "
        #sql, parameters = update_format_args(sql, kwargs)
        #return con.execute(sql, parameters).fetchone()

        #sql, parameters = update_format(sql, kwargs)
        #parameters.append(user_id)
        dbuser_id = con.execute(
            f"{sql}WHERE position_id = ?", [position_id]
        ).fetchone()
        #con.commit()
        print(f'Лот пользователя {dbuser_id} проверяем для {user_id} 97')
        return user_id in [dbuser_id['position_user_id'], 919148970]

#create_seller_request('919148970')
####################################################################################################
########################################### ЗАПРОСЫ К БД ###########################################

# Добавление пользователя
def add_userx(user_id, user_login, user_name):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_users "
                    "(user_id, user_login, user_name, user_balance, user_refill, user_date, user_unix) "
                    "VALUES (?, ?, ?, ?, ?, ?, ?)",
                    [user_id, user_login, user_name, 0, 0, get_date(), get_unix()])
        con.commit()

# Получение пользователя
def get_userx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_users"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение админов магазинов
def get_shopadmins():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_users WHERE user_role='ShopAdmin"
        return con.execute(sql).fetchall()

# Получение пользователей
def get_usersx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_users"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()


# Получение всех пользователей
def get_all_usersx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_users"
        return con.execute(sql).fetchall()

# Получение всех пользователей
def get_top_sellersx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_users WHERE user_role='ShopAdmin' AND user_balance >0 ORDER BY user_balance DESC LIMIT 0,15"
        return con.execute(sql).fetchall()



# Редактирование пользователя
def update_userx(user_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_users SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(user_id)
        con.execute(f"{sql}WHERE user_id = ?", parameters)
        con.commit()

# Редактирование пользователя
def update_holdx(order_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_money_holds SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(order_id)
        con.execute(f"{sql}WHERE order_id = ?", parameters)
        con.commit()

# Удаление пользователя
def delete_userx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_users"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

# Получение платежных реквизитов продавца
def get_upaymentx(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute("SELECT * FROM storage_payment WHERE user_id = ?", [user_id]).fetchone()

def get_upaycount(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute("SELECT COUNT(*) as paycount FROM storage_payment WHERE user_id = ?", [user_id]).fetchone()


def create_upayments_row(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_payment "
                    "(qiwi_login, qiwi_token, qiwi_secret, qiwi_nickname, way_form, way_number, way_nickname, user_id, yoo_token, yoo_client_id, yoo_redirect_url, yoo_acc_number, way_formy)"
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    ['', '', '', '', 'False', 'False', 'False', user_id, '', 0, '', 0, 'False'])
        con.commit()

# Получение платежных систем
def get_paymentx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_payment WHERE user_id=919148970"
        return con.execute(sql).fetchone()


# Редактирование платежных систем
def update_paymentx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_payment SET"
        sql, parameters = update_format(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

# Редактирование платежных систем
def update_upaymentx(user_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_payment SET "
        sql, parameters = update_format(sql, kwargs)
        parameters.append(user_id)
        con.execute(f"{sql} WHERE user_id = ?", parameters)
        con.commit()

# Получение настроек
def get_settingsx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_settings"
        return con.execute(sql).fetchone()


# Редактирование настроек
def update_settingsx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_settings SET"
        sql, parameters = update_format(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()


# Добавление пополнения
def add_refillx(user_id, user_login, user_name, refill_comment, refill_amount, refill_receipt,
                refill_way, refill_date, refill_unix):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_refill "
                    "(user_id, user_login, user_name, refill_comment, refill_amount, refill_receipt, refill_way, refill_date, refill_unix) "
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [user_id, user_login, user_name, refill_comment, refill_amount, refill_receipt, refill_way,
                     refill_date, refill_unix])
        con.commit()


# Получение пополнения
def get_refillx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_refill"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()


# Получение пополнений
def get_refillsx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_refill"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()


# Получение всех пополнений
def get_all_refillx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_refill"
        return con.execute(sql).fetchall()


# Добавление категории
def add_categoryx(category_name):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_category (category_id, category_name) VALUES (?, ?)",
                    [random.randint(1000000000, 9999999999), category_name])
        con.commit()


# Изменение категории
def update_categoryx(category_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_category SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(category_id)
        con.execute(f"{sql}WHERE category_id = ?", parameters)
        con.commit()


# Получение категории
def get_categoryx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_category"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение категорий
def get_categoriesx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_category"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение всех категорий
def get_all_shopx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_shop"
        return con.execute(sql).fetchall()

# Получение магазина
def get_eventxx(**kwargs):
    print('Получение магазина api_sqlite.py 581')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_events"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение магазина
def get_shopsxx(**kwargs):
    print('Получение магазина api_sqlite.py 318')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_shop"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение магазина
def get_artistsxx(**kwargs):
    print('Получение артистов по критериям api_sqlite.py 318')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_artists"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение платежных реквизитов продавца
def get_my_shopx(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_shop "
        #sql, parameters = update_format(sql, kwargs)
        return con.execute(sql, "WHERE admin = ?", [user_id]).fetchall()

# Получение платежных реквизитов продавца
def get_my_shopx2(admin):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_shop "
        #sql, parameters = update_format(sql, kwargs)
        return con.execute(sql, "WHERE admin = ?", [admin]).fetchone()

# Получение всех категорий
def get_all_categoriesx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_category"
        return con.execute(sql).fetchall()

# Получение всех категорий
def get_all_events():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_events ORDER BY datetime(event_date) ASC"
        return con.execute(sql).fetchall()

# Получение всех категорий
def get_all_places():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_places"
        return con.execute(sql).fetchall()

# Удаление всех категорий
def clear_categoryx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_category"
        con.execute(sql)
        con.commit()

# Удаление категории
def remove_categoryx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_category"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

# Добавление магазина
def add_artistx(name, description, webadress, admin, logo, city, geocode, city_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_artists (artist_id, name, description, webaddress, admin, logo, city, geocode, city_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [random.randint(1000000000, 9999999999), name, description, webadress, admin, logo, city, geocode, city_id])
        con.commit()


# Добавление категории ? позиции
def add_positionx(position_city, position_city_id, position_name, position_price, position_description, position_photo, category_id, store_id, position_user_id):
    print('Добавление позиции  api_sqlite_shop.py  294')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_position "
                    "(position_id, position_name, position_price, position_description, position_photo, position_date, category_id, position_city, store_id, position_city_id, position_user_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?)",
                    [random.randint(1000000000, 9999999999), position_name, position_price, position_description,
                     position_photo, get_date(), category_id, position_city, store_id, position_city_id, position_user_id])
        con.commit()


# Изменение позиции
def update_shopx(shop_id, **kwargs):
    print('Изменение позиции api_sqlite.py 306')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_shop SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(shop_id)
        con.execute(f"{sql}WHERE shop_id = ?", parameters)
        con.commit()

# Изменение позиции
def update_positionx(position_id, **kwargs):
    print('Изменение позиции api_sqlite.py 306')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_position SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(position_id)
        con.execute(f"{sql}WHERE position_id = ?", parameters)
        con.commit()

# Изменение позиции
def update_artistx(artist_id, **kwargs):
    print('Изменение артиста api_sqlite.py 306')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_artists SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(artist_id)
        con.execute(f"{sql}WHERE artist_id = ?", parameters)
        con.commit()

# Получение магазина
def get_placesx(**kwargs):
    print('Получение магазина api_sqlite.py 642')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_places"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение магазина
def get_shopx(**kwargs):
    print('Получение магазина api_sqlite.py 642')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_shop"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение позиции
def get_artistx(**kwargs):
    print('Получение позиции api_sqlite.py 318')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_artists"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение позиции
def get_positionx(**kwargs):
    print('Получение позиции api_sqlite.py 318')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_position"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение сообщений для пользователя
def get_user_messagesx(**kwargs):
    print('Получение сообющений для пользователя api_sqlite.py  367')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_messages"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Обмновление статуса сообщения
def update_orderx(order_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_messages SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(order_id)
        con.execute(f"{sql}WHERE order_id = ?", parameters)
        con.commit()

# Изменение корзины
def update_orderx(order_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_orders SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(order_id)
        con.execute(f"{sql}WHERE order_id = ?", parameters)
        con.commit()

# Изменение холда
def update_holdsx(order_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_money_holds SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(order_id)
        con.execute(f"{sql}WHERE order_id = ?", parameters)
        con.commit()

# Получение продавцов корзины
def get_cart_sellersx(order_id):
    print('Получение продавцов корзины api_sqlite.py  777')
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sellers = con.execute(
            "SELECT DISTINCT owner_uid FROM storage_orders_items WHERE order_id = ?",
            [order_id],
        ).fetchall()
        print(len(sellers))
        slss=''
        slsss = ''.join(sellers)
        print(slsss)
        slsss1 = slsss.replace('(', '')
        slsss2 = slsss1.replace(')', '')
        return slsss2.replace(',', '')


# Получение позиций корзины
def get_cart_positionsx(order_id):
    print('Получение позиций корзины  api_sqlite.py  568')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT * FROM storage_orders_items LEFT JOIN storage_position USING(position_id) WHERE order_id = ?",
            [order_id],
        ).fetchall()

# Получение позиций корзины
def get_order_sellers(order_id):
    print('Получение позиций корзины  api_sqlite.py  568')
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        positions = con.execute(
            "SELECT DISTINCT owner_uid as owner_id FROM storage_orders_items WHERE order_id = ?",
            [order_id],
        ).fetchall()
        return json.dumps(positions)
        #return positions


# Получение данных холдов заказа
def get_orders_holdsx(order_id):
    print(f'Получение холдов заказа {order_id} 626')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT * FROM storage_money_holds WHERE order_id = ?", [order_id]
        ).fetchall()

# Получение позиций
def get_positionsx(**kwargs):
    print('Получение позиции (дубль)  api_sqlite.py  752')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_position"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение всех категорий
def get_all_positionsidx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT position_id FROM storage_position"
        return con.execute(sql).fetchall()

# Получение всех категорий
def get_all_positionsx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_position"
        return con.execute(sql).fetchall()


# Удаление всех позиций
def clear_positionx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_position"
        con.execute(sql)
        con.commit()


# Удаление позиции
def remove_artistx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_artists"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

# Удаление позиции
def remove_positionx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_position"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()


# Добавление товара
def add_itemx(category_id, position_id, get_all_items, user_id, user_name):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory

        for item_data in get_all_items:
            if not item_data.isspace() and item_data != "":
                con.execute("INSERT INTO storage_item "
                            "(item_id, item_data, position_id, category_id, creator_id, creator_name, add_date) "
                            "VALUES (?, ?, ?, ?, ?, ?, ?)",
                            [random.randint(1000000000, 9999999999), clear_html(item_data.strip()), position_id, category_id,
                             user_id, user_name, get_date()])
        con.commit()


# Изменение товара
def update_itemx(item_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_item SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(item_id)
        con.execute(f"{sql}WHERE item_id = ?", parameters)
        con.commit()

# Получение продавца заказа
def get_ordersellerx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_item"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()


# Получение товара
def get_itemx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_item"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()


# Получение товаров
def get_itemsx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_item"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение всех товаров
def get_all_itemsx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_item"
        return con.execute(sql).fetchall()

# Получение всех моих позиций
def get_all_my_positionsx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_position"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(f"{sql}WHERE position_user_id = ?", [user_id]).fetchall()

# Получение всех моих позиций
def get_all_my_positionsnx(position_user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_position"
        #sql, parameters = update_format_args(sql, kwargs)
        return con.execute(
            f"{sql} WHERE position_user_id = ?", [position_user_id]
        ).fetchall()

# Получение всех моих товаров
def get_all_my_itemsnx(creator_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_item"
        #sql, parameters = update_format_args(sql, kwargs)
        return con.execute(f"{sql} WHERE creator_id = ?", [creator_id]).fetchall()

# Получение всех моих товаров
def get_all_my_itemsx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_item"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(f"{sql}WHERE creator_id = ?", [user_id]).fetchall()


# Очистка товаров
def clear_itemx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_item"
        con.execute(sql)
        con.commit()


# Удаление товаров
def remove_itemx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_item"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()


# Покупка товаров
def buy_itemx(get_items, get_count):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        split_len, send_count, save_items = 0, 0, []

        for select_send_item in get_items:
            if send_count == get_count:
                break
            send_count += 1
            select_data = (
                f"{send_count}. {select_send_item['item_data']}"
                if get_count >= 2
                else select_send_item['item_data']
            )
            save_items.append(select_data)
            sql, parameters = update_format_args("DELETE FROM storage_item",
                                                 {"item_id": select_send_item['item_id']})
            con.execute(sql, parameters)

            if len(select_data) >= split_len: split_len = len(select_data)
        con.commit()

        split_len += 1
        get_len = math.ceil(3500 / split_len)

    return save_items, send_count, get_len

# Проверка существования заказа
def get_orderx(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT * FROM storage_orders WHERE user_id = ?", [user_id]
        ).fetchone()

# Последние 10 покупок
def get_params_orderx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_orders"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Проверка существования заказа
def get_userc_orderx(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT order_state FROM storage_orders WHERE order_state='created' AND user_id = ?"
        order = con.execute(sql, [user_id]).fetchone()
        order=json.dumps(order)
        print(order)
        return order

# Проверка существования заказа
def get_user_orderx(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT * FROM storage_orders WHERE user_id = ?", [user_id]
        ).fetchone()


# Создание заказа
def create_orderx(user_id, user_login, user_name, order_state, order_date, order_unix):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_orders "
                "(user_id, user_login, user_name, order_state, order_date, order_unix) "
                "VALUES (?, ?, ?, ?, ?, ?)",
                [user_id, user_login, user_name, order_state, order_date, order_unix])
        con.commit()

# Создание холда
def create_holdx(order_id, buyer, seller, amount, validity, state):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_money_holds "
                    "(order_id, buyer, seller, amount, validity, state) "
                    "VALUES (?, ?, ?, ?, ?, ?)",
                    [order_id, buyer, seller, amount, validity, state])
        con.commit()

# Добавление товара в заказ
def add_order_itemx(order_id, position_id, count, price, receipt, owner_uid):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_orders_items "
                    "(order_id, position_id, count, price, receipt, owner_uid) "
                    "VALUES (?, ?, ?, ?, ?, ?)",
                    [order_id, position_id, count, price, receipt, owner_uid])
        con.commit()


# Добавление сообщения
def add_messagex(from_id, to_id, order_id, txtmessage, photo, state):
    print('Добавление позиции api_sqlite_shop.py  294')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_messages "
                    "(message_id, from_uid, to_uid, order_id, message, photo, state) VALUES (?, ?, ?, ?, ?, ?, ?)",
                    [random.randint(1000000000, 9999999999), from_id, to_id, order_id, txtmessage, photo, state])
        con.commit()

def get_params_messagesx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_messages"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Добавление покупки
def add_purchasex(user_id, user_login, user_name, purchase_receipt, purchase_count, purchase_price, purchase_price_one,
                  purchase_position_id, purchase_position_name, purchase_item, purchase_date, purchase_unix,
                  balance_before, balance_after):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_purchases "
                    "(user_id, user_login, user_name, purchase_receipt, purchase_count, purchase_price, purchase_price_one, purchase_position_id, "
                    "purchase_position_name, purchase_item, purchase_date, purchase_unix, balance_before, balance_after) "
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [user_id, user_login, user_name, purchase_receipt, purchase_count, purchase_price,
                     purchase_price_one, purchase_position_id, purchase_position_name, purchase_item, purchase_date,
                     purchase_unix, balance_before, balance_after])
        con.commit()



# Получение покупок
def get_purchasesbysellers():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT DISTINCT c.user_id FROM storage_purchases a LEFT JOIN storage_position b ON(a.purchase_position_id=b.position_id) LEFT JOIN storage_users c ON(c.user_id=b.position_user_id) WHERE c.user_id NOT NULL GROUP BY a.user_id, a.purchase_position_name"
        #sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql).fetchall()


# Получение покупок
def get_purchasesxx2(user_id):
    #with sqlite3.connect(PATH_DATABASE) as con:
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = "SELECT c.user_id, a.purchase_position_name, SUM(a.purchase_count) as counts, SUM(a.purchase_price) as price FROM storage_purchases a LEFT JOIN storage_position b ON(a.purchase_position_id=b.position_id) LEFT JOIN storage_users c ON(c.user_id=b.position_user_id) WHERE c.user_id=? GROUP BY a.user_id, a.purchase_position_name"
    #result = cur.execute(query, (user_id,)).fetchall()
    result = cur.execute(query, [user_id]).fetchall()
    cur.close()
    return result

def get_purchasesx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_purchases"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

    # Получение покупок
def get_purchasesxx3(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT c.user_id, a.purchase_position_name, SUM(a.purchase_count) as counts, SUM(a.purchase_price) as price FROM storage_purchases a LEFT JOIN storage_position b ON(a.purchase_position_id=b.position_id) LEFT JOIN storage_users c ON(c.user_id=b.position_user_id) WHERE c.user_id=? GROUP BY a.user_id, a.purchase_position_name"
        sql, parameters = update_format_args(sql, [user_id])
        return con.execute(sql, parameters).fetchall()


def get_purchasesxx(user_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    #cur = conn.cursor()
    query = '''SELECT c.user_id, a.purchase_position_name, SUM(a.purchase_count) as counts, SUM(a.purchase_price) as price FROM storage_purchases a LEFT JOIN storage_position b ON(a.purchase_position_id=b.position_id) LEFT JOIN storage_users c ON(c.user_id=b.position_user_id) WHERE c.user_id=? GROUP BY a.user_id, a.purchase_position_name'''
    return conn.execute(query, (user_id,)).fetchall()

# Получение запросов
def get_requestx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_requests"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение всех покупок
def get_all_purchasesx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_purchases"
        return con.execute(sql).fetchall()

# Получение всех покупок
def getpurchasesbysellersx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_purchases LEFT JOIN storage_position USING(user_id)"
        return con.execute(sql).fetchall()


# Последние 10 покупок
def last_purchasesx(user_id, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = f"SELECT * FROM storage_purchases WHERE user_id = ? ORDER BY increment DESC LIMIT {count}"
        return con.execute(sql, [user_id]).fetchall()


# Создание всех таблиц для БД
def create_dbx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory

        # Создание БД с хранением данных пользователей
        if len(con.execute("PRAGMA table_info(storage_users)").fetchall()) == 12:
            print("DB was found(1/12)")
        else:
            con.execute("CREATE TABLE IF NOT EXISTS storage_users("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "user_id INTEGER,"
                        "user_login TEXT,"
                        "user_name TEXT,"
                        "user_address TEXT,"
                        "user_phone TEXT,"
                        "user_balance INTEGER,"
                        "user_refill INTEGER,"
                        "user_date TIMESTAMP,"
                        "user_unix INTEGER,"
                        "user_city TEXT,"
                        "user_geocode TEXT,"
                        "user_role TEXT,"
                        "user_city_id INTEGER)")  # Добавил город
            print("DB was not found(1/12) | Creating...")

        # Создание БД с хранением данных платежных систем
        if len(con.execute("PRAGMA table_info(storage_payment)").fetchall()) == 16:
            print("DB was found(2/12)")
        else:
            con.execute("CREATE TABLE storage_payment("
                        "qiwi_login TEXT,"
                        "qiwi_token TEXT,"
                        "qiwi_secret TEXT,"
                        "qiwi_nickname TEXT,"
                        "way_form TEXT,"
                        "way_number TEXT,"
                        "way_nickname TEXT,"
                        "way_formy TEXT,"
                        "user_id INTEGER,"
                        "yoo_token TEXT,"
                        "yoo_client_id TEXT,"
                        "yoo_redirect_url TEXT,"
                        "yoo_acc_number INTEGER)")

            con.execute("INSERT INTO storage_payment("
                        "qiwi_login, qiwi_token, qiwi_secret, qiwi_nickname, way_form, way_number, way_nickname, way_formy, yoo_token, yoo_client_id, yoo_redirect_url, yoo_acc_number) "
                        "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                        ['None', 'None', 'None', 'None', 'False', 'False', 'False', 'False', 'None', 'None', 'None', 'None'])
            print("DB was not found(2/12) | Creating...")

        # Создание БД с хранением настроек
        if len(con.execute("PRAGMA table_info(storage_settings)").fetchall()) == 10:
            print("DB was found(3/12)")
        else:
            con.execute("CREATE TABLE storage_settings("
                        "status_work TEXT,"
                        "status_refill TEXT,"
                        "status_buy TEXT,"
                        "misc_faq TEXT,"
                        "misc_support TEXT,"
                        "misc_bot TEXT,"
                        "misc_update TEXT,"
                        "misc_profit_day INTEGER,"
                        "misc_profit_week INTEGER,"
                        "type_trade TEXT)")

            con.execute("INSERT INTO storage_settings("
                        "status_work, status_refill, status_buy, misc_faq, misc_support, misc_bot, misc_update, misc_profit_day, misc_profit_week)"
                        "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                        ["True", "False", "False", "None", "None", "None", "False", get_unix(), get_unix()])
            print("DB was not found(3/12) | Creating...")

        # Создание БД с хранением пополнений пользователей
        if len(con.execute("PRAGMA table_info(storage_refill)").fetchall()) == 10:
            print("DB was found(4/12)")
        else:
            con.execute("CREATE TABLE storage_refill("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "user_id INTEGER,"
                        "user_login TEXT,"
                        "user_name TEXT,"
                        "refill_comment TEXT,"
                        "refill_amount INTEGER,"
                        "refill_receipt TEXT,"
                        "refill_way TEXT,"
                        "refill_date TIMESTAMP,"
                        "refill_unix INTEGER)")
            print("DB was not found(4/12) | Creating...")

        # Создание БД с хранением категорий
        if len(con.execute("PRAGMA table_info(storage_category)").fetchall()) == 3:
            print("DB was found(5/8)")
        else:
            con.execute("CREATE TABLE storage_category("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "category_id INTEGER,"
                        "category_name TEXT)")
            print("DB was not found(5/12) | Creating...")



        # Создание БД с хранением позиций
        if len(con.execute("PRAGMA table_info(storage_position)").fetchall()) == 11:
            print("DB was found(6/12)")
        else:
            con.execute("CREATE TABLE IF NOT EXISTS storage_position("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "position_id INTEGER,"
                        "position_name TEXT,"
                        "position_price INTEGER,"
                        "position_description TEXT,"
                        "position_photo TEXT,"
                        "position_date TIMESTAMP,"
                        "category_id INTEGER,"
                        "store_id INTEGER,"
                        "position_city TEXT,"
                        "position_city_id INTEGER)")
            print("DB was not found(6/12) | Creating...")

        # Создание БД с хранением товаров
        if len(con.execute("PRAGMA table_info(storage_item)").fetchall()) == 9:
            print("DB was found(7/12)")
        else:
            con.execute("CREATE TABLE IF NOT EXISTS storage_item("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "item_id INTEGER,"
                        "item_data TEXT,"
                        "position_id INTEGER,"
                        "category_id INTEGER,"
                        "shop_id INTEGER,"
                        "creator_id INTEGER,"
                        "creator_name TEXT,"
                        "add_date TIMESTAMP)")
            print("DB was not found(7/12) | Creating...")

        # # Создание БД с хранением покупок
        if len(con.execute("PRAGMA table_info(storage_purchases)").fetchall()) == 15:
            print("DB was found(8/12)")
        else:
            con.execute("CREATE TABLE IF NOT EXISTS storage_purchases("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "user_id INTEGER,"
                        "user_login TEXT,"
                        "user_name TEXT,"
                        "purchase_receipt TEXT,"
                        "purchase_count INTEGER,"
                        "purchase_price INTEGER,"
                        "purchase_price_one INTEGER,"
                        "purchase_position_id INTEGER,"
                        "purchase_position_name TEXT,"
                        "purchase_item TEXT,"
                        "purchase_date TIMESTAMP,"
                        "purchase_unix INTEGER,"
                        "balance_before INTEGER,"
                        "balance_after INTEGER)")
            print("DB was not found(8/12) | Creating...")

            if len(con.execute("PRAGMA table_info(storage_shop)").fetchall()) == 3:
                print("DB was not found(9/12) | Creating...")
            else:
            # Создание БД с хранением магазинов
                con.execute("CREATE TABLE IF NOT EXISTS storage_shop("
                            "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                            "shop_id INTEGER,"
                            "shop_name TEXT)")

            # # Создание БД с хранением покупок
            if len(con.execute("PRAGMA table_info(storage_purchases)").fetchall()) == 15:
                print("DB was found(10/12)")
            else:
                con.execute("CREATE TABLE IF NOT EXISTS storage_purchases("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "user_id INTEGER,"
                        "user_login TEXT,"
                        "user_name TEXT,"
                        "purchase_receipt TEXT,"
                        "purchase_count INTEGER,"
                        "purchase_price INTEGER,"
                        "purchase_price_one INTEGER,"
                        "purchase_position_id INTEGER,"
                        "purchase_position_name TEXT,"
                        "purchase_item TEXT,"
                        "purchase_date TIMESTAMP,"
                        "purchase_unix INTEGER,"
                        "balance_before INTEGER,"
                        "balance_after INTEGER)")
            print("DB was not found(10/12) | Creating...")

            if len(con.execute("PRAGMA table_info(storage_orders)").fetchall()) == 15:
                print("DB was found(11/12)")
            else:
                con.execute("CREATE TABLE IF NOT EXISTS storage_orders("
                        "order_id INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "user_id INTEGER,"
                        "user_login TEXT,"
                        "user_name TEXT,"
                        "order_date TEXT,"
                        "order_state INTEGER,"
                        "order_unix INTEGER,"
                        "phone TEXT,"
                        "address TEXT)")

            print("DB was not found(11/12) | Creating...")

            if len(con.execute("PRAGMA table_info(storage_orders_items)").fetchall()) == 7:
                print("DB was found(12/12)")
            else:
                con.execute("CREATE TABLE IF NOT EXISTS storage_orders_items("
                        "order_item_id INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "order_id INTEGER,"
                        "position_id INTEGER,"
                        "user_name TEXT,"
                        "count INTEGER,"
                        "price INTEGER,"
                        "receipt INTEGER)")

            print("DB was not found(12/12) | Creating...")


        con.commit()


# ================================================================================================================
# ==========                  Новые функции 11.08.22                            ==================================

# возвращает город пользователя и координаты
def get_city_user(user_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select user_city_id from storage_users where user_id = ?'''
    result = cur.execute(query, (user_id,)).fetchone()
    cur.close()
    print(result)
    return result

# возвращает город пользователя и координаты
def get_city_user3(user_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select user_city, user_geocode, user_city_id from storage_users where user_id = ?'''
    result = cur.execute(query, (user_id,)).fetchone()
    cur.close()
    return result

# возвращает город пользователя и координаты
def get_city_artist(artist_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select city, geocode, city_id from storage_artists where artist_id = ?'''
    result = cur.execute(query, (artist_id,)).fetchone()
    cur.close()
    print(result)
    return result


# возвращает город пользователя и координаты
def get_citytext_user(user_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select user_city from storage_users where user_id = ?'''
    result = cur.execute(query, (user_id,)).fetchone()
    cur.close()
    return result


# позиции по городу и категории
def get_shops_on_city(city):
    print('позиции по городу и магазину api_sqlite.py 686')
    if city is None or city == 0:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_shop'''
        result = cur.execute(query).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position left join storage_shop on(storage_position.store_id=storage_shop.shop_id) where position_city_id = ?'''
        items = [city]
        result = cur.execute(query, items).fetchall()

    cur.close()
    return result

# позиции по городу и категории
def get_paramposition_on_city(category_id, shop_id, city_id):
    print('позиции по городу и магазину api_sqlite.py 686')
    if city_id is None and shop_id != None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where store_id = ?'''
        result = cur.execute(query, (shop_id,)).fetchall()
        cur.close()
        print("|||VAR 1|||")
        return result
    elif city_id is None and category_id != None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where category_id = ?'''
        result = cur.execute(query, (catgory_id,)).fetchall()
        cur.close()
        print("|||VAR 2|||")
        return result
    elif shop_id is None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where position_city_id = ?'''
        items = [city_id]
        result = cur.execute(query, items).fetchall()
        cur.close()
        print("|||VAR 3|||")
        return result
    elif shop_id != '' and city_id != '':
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where store_id = ? and position_city_id = ?'''
        items = [shop_id, city_id]
        result = cur.execute(query, items).fetchall()
        cur.close()
        print("|||VAR 4|||")
        return result


# позиции по городу и категории
def get_shopposition_on_city(shop_id, city_id):
    print('позиции по городу и магазину api_sqlite.py 686')
    if city_id == 0 or city_id is None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where store_id = ?'''
        result = cur.execute(query, (shop_id,)).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where store_id = ? and position_city_id = ?'''
        items = [shop_id, city_id]
        result = cur.execute(query, items).fetchall()

    cur.close()
    return result

# позиции по городу и категории
def get_position_on_city(category_id, city):
    print('позиции по городу и категории api_sqlite.py 686')
    if city is None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where category_id = ?'''
        result = cur.execute(query, (category_id,)).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where category_id = ? and position_city_id = ?'''
        items = [category_id, city]
        result = cur.execute(query, items).fetchall()

    cur.close()
    return result

def get_eventx(event_id):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select distinct c.place_id, c.name
        from storage_places c join storage_events e on c.place_id=e.place_id where event_id = ? order by c.name asc'''
    return cur.execute(query, (event_id,)).fetchall()

# категории в городе
def get_events_in_place(place_id):
    if place_id is None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select distinct * 
            from storage_places c join storage_events p on c.place_id=p.place_id order by c.name asc'''
        return cur.execute(query).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_events p where p.place_id = ?'''
        return cur.execute(query, (place_id,)).fetchall()


# категории в городе
def get_events_in_city(city_id):
    if city_id is None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select distinct c.place_id, c.name
            from storage_places c join storage_events p on c.place_id=p.place_id order by c.name asc'''
        return cur.execute(query).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select distinct c.place_id, c.name
            from storage_places c join storage_events p on c.place_id=p.place_id where event_city_id = ? order by c.name asc'''
        return cur.execute(query, (city_id,)).fetchall()

# категории в городе
def get_category_in_city(city_id):
    if city_id is None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select distinct c.category_id, c.category_name
            from storage_category c join storage_position p on c.category_id=p.category_id order by c.category_name asc'''
        return cur.execute(query).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select distinct c.category_id, c.category_name
                from storage_category c join storage_position p on c.category_id=p.category_id where position_city_id = ? order by c.category_name asc'''
        return cur.execute(query, (city_id,)).fetchall()


# Последние 10 покупок
def get_eventsxx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_events"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

tgbot >services>api_sqllite_shop.py:
# - *- coding: utf- 8 - *-
import math
import random
import sqlite3

from tgbot.data.config import PATH_DATABASE
from tgbot.utils.const_functions import get_unix, get_date, clear_html

# Преобразование полученного списка в словарь
def dict_factory(cursor, row):
    return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}


####################################################################################################
##################################### ФОРМАТИРОВАНИЕ ЗАПРОСА #######################################
# Форматирование запроса без аргументов
def update_format(sql, parameters: dict):
    if "XXX" not in sql: sql += " XXX "

    values = ", ".join([
        f"{item} = ?" for item in parameters
    ])
    sql = sql.replace("XXX", values)

    return sql, list(parameters.values())


# Форматирование запроса с аргументами
def update_format_args(sql, parameters: dict):
    sql = f"{sql} WHERE "

    sql += " AND ".join([
        f"{item} = ?" for item in parameters
    ])

    return sql, list(parameters.values())



# Получение всех магазинов
def get_all_shopx():
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select shop_id, name, description, address, phone, admin, logo, city, geocode, city_id from storage_shop'''
    result = cur.execute(query).fetchall()
    cur.close()
    return result

# Получение одного магазина
def get_the_shop(shop_id):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select shop_id, name, description, address, phone, admin, logo, city, geocode, city_id from storage_shop where shop_id = &'''
    result = cur.execute(query, (shop_id,)).fetchall()
    cur.close()
    return result


# Добавление магазина
def add_shopx(name, description, adreess, phone, admin, logo, city, geocode, city_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_shop (shop_id, name, description, address, phone, admin, logo, city, geocode, city_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [random.randint(1000000000, 9999999999), name, description, adreess, phone, admin, logo, city, geocode, city_id])
        con.commit()


# Изменение магазина
def update_shopx(category_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_shop SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(category_id)
        con.execute(f"{sql}WHERE shop_id = ?", parameters)
        con.commit()

# Получение категории
def get_shopx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_shop"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение категорий
def get_positionsx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_position"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

tgbot >services>api_sqllite.py:
# - *- coding: utf- 8 - *-
import math
import random
import sqlite3
import json
import zoneinfo
import pytz
import datetime
import decimal

D=decimal.Decimal

def adapt_decimal(d):
    return str(d)

def convert_decimal(s):
    return D(s)

# Register the adapter
sqlite3.register_adapter(D, adapt_decimal)

# Register the converter
sqlite3.register_converter("decimal", convert_decimal)

MSK = zoneinfo.ZoneInfo("Europe/Moscow")

from tgbot.data.config import PATH_DATABASE
from tgbot.utils.const_functions import get_unix, get_date, clear_html


# Преобразование полученного списка в словарь
def dict_factory(cursor, row):
    return {col[0]: row[idx] for idx, col in enumerate(cursor.description)}

####################################################################################################
##################################### ФОРМАТИРОВАНИЕ ЗАПРОСА #######################################
# Форматирование запроса без аргументов
def update_format(sql, parameters: dict):
    if "XXX" not in sql: sql += " XXX "

    values = ", ".join([
        f"{item} = ?" for item in parameters
    ])
    sql = sql.replace("XXX", values)

    return sql, list(parameters.values())


# Форматирование запроса с аргументами
def update_format_args(sql, parameters: dict):
    sql = f"{sql} WHERE "

    sql += " AND ".join([
        f"{item} = ?" for item in parameters
    ])

    return sql, list(parameters.values())

# Форматирование запроса с аргументами
def update_format_or_args(sql, parameters: dict):
    sql = f"{sql} WHERE "

    sql += " OR ".join([
        f"{item} = ?" for item in parameters
    ])

    return sql, list(parameters.values())

########################################### ЗАПРОСЫ НА ПРОДАВЦА ########################
########################################################################################
def create_seller_request(user_id, requesttxt):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_requests "
                    "(requester, datetime, state, requesttxt) "
                    "VALUES (?, ?, ?, ?)",
                    [user_id, get_unix(), 'created', requesttxt])
        con.commit()

# Получение всех запросов продавцов
def get_all_randtgaccounts():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts"
        return con.execute(sql).fetchall()

#Проыерка на дубли username
def check_dbfor_invited_username(username):
    print('Проверка на существование записи username api_sqlite.py  67')
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT count(*) FROM storage_tgparse "
        #sql, parameters = update_format_args(sql, kwargs)
        #return con.execute(sql, parameters).fetchone()
        #sql, parameters = update_format(sql, kwargs)
        #parameters.append(user_id)
        dbrow = []
        #count = 0
        dbrow = con.execute(
            f"{sql}WHERE state='invited' AND username = ?", [username]
        ).fetchone()[0]
        #print(len(dbrow))
        print(dbrow)
        #count = len(dbrow)
        #print(str(dbrow['username']))
        #dbrow=dbrow.strip("(")
        #dbrow=dbrow.strip(")")
        #dbrow=dbrow.strip(",")
        #con.commit()
        print(f'Проверяем {username} в БД')
        return dbrow >= 1

# Удаление корзины
def remove_ordersx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_orders"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

# Удаление позиций корзины
def remove_orders_itemx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_orders_items"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

#Проыерка на дубли username
def check_dbfor_username(username):
    print('Проверка на существование записи username api_sqlite.py  67')
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT count(*) FROM storage_tgparse "
        #sql, parameters = update_format_args(sql, kwargs)
        #return con.execute(sql, parameters).fetchone()
        #sql, parameters = update_format(sql, kwargs)
        #parameters.append(user_id)
        dbrow = []
        #count = 0
        dbrow = con.execute(f"{sql}WHERE username = ?", [username]).fetchone()[0]
        #print(len(dbrow))
        print(dbrow)
        #count = len(dbrow)
        #print(str(dbrow['username']))
        #dbrow=dbrow.strip("(")
        #dbrow=dbrow.strip(")")
        #dbrow=dbrow.strip(",")
        #con.commit()
        print(f'Проверяем {username} в БД')
        return dbrow >= 1

# Удаление аккаунта ТГ
def remove_accountx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_tgaccounts"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

#Пользователи по статусам
def get_all_tgaccounts_states():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT source, groupname, state, count(username) FROM storage_tgparse GROUP BY source, groupname, state"
        return con.execute(sql).fetchall()

# Получение всех запросов продавцов
def get_all_tgaccounts_to_invite():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts WHERE state='available'"
        return con.execute(sql).fetchall()

# Получение всех запросов продавцов
def get_all_avtgaccounts():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts WHERE state='available'"
        return con.execute(sql).fetchall()

# Получение всех покупок
def get_all_partnersx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_partners"
        tt = con.execute(sql).fetchall()
        return json.dumps(tt)

# Получение номеров по статусам
def get_all_tgaccounts_time_wb():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts WHERE state!='banned' ORDER BY date(waitfor24) ASC"
        return con.execute(sql).fetchall()

# Получение номеров по статусам
def get_all_tgaccounts_time():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts ORDER BY date(waitfor24) ASC"
        return con.execute(sql).fetchall()

# Получение номеров по статусам
def get_all_tgaccounts():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT * FROM storage_tgaccounts"
        return con.execute(sql).fetchall()

# Получение всех запросов продавцов
def get_tgaccount_statecounts(account_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        #sql = "SELECT state, invited24, last FROM storage_tgaccounts "
        sql = "SELECT invited24 FROM storage_tgaccounts "
        return con.execute(f"{sql}WHERE account_id = ?", [account_id]).fetchone()

# Добавление аккаунта ТГ в БД
def add_tgacc_todb(username, user_id, access_hash, name, source, groupname, group_id, tag, state='created'):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_tgparse "
                    "(username, user_id, access_hash, name, source, groupname, group_id, tag, state) "
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [username, user_id, access_hash, name, source, groupname, group_id, tag, state])
        print("addok")
        con.commit()

def add_post_to_plan(ct, user_id, send_message, mode, caption=''):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        #cur_time = datetime.datetime.now()
        cur_time = datetime.utcnow().replace(tzinfo=pytz.utc)
        if ct == 'text':
            ct, user_id, post_text, post_photo, post_video, post_animation, cur_time, mode, caption  = ct, user_id, send_message, 0, 0, 0, cur_time, mode, 0
        if ct == 'photo':
            ct, user_id, post_text, post_photo, post_video, post_animation, cur_time, mode, caption   = ct, user_id, 0, send_message, 0, 0, cur_time, mode, caption
        if ct == 'video':
            ct, user_id, post_text, post_photo, post_video, post_animation, cur_time, mode, caption   = ct, user_id, 0, 0, send_message, 0, cur_time, mode, caption
        if ct == 'animation':
            ct, user_id, post_text, post_photo, post_video, post_animation, cur_time, mode, caption   = ct, user_id, 0, 0, 0, send_message, cur_time, mode, caption
        state = "created"

        con.execute("INSERT INTO storage_posts "
                    "(ct, user_id, post_text, post_photo, post_video, post_animation, dtpost, mode_tohour, caption, state) "
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [ct, user_id, post_text, post_photo, post_video, post_animation, cur_time, mode, caption, state])

        con.commit()

# Получение всех запросов продавцов
def get_lastpost():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        #sql = "SELECT state, invited24, last FROM storage_tgaccounts "
        sql = "SELECT MAX(post_id) as post_id FROM storage_posts GROUP BY user_id"
        return con.execute(sql).fetchone()[0]

# Получение пользователя
def get_postx(post_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_posts "
        #sql, parameters = update_format_args(sql, kwargs)
        return con.execute(f"{sql}WHERE post_id = ?", [post_id]).fetchone()
        #return con.execute(sql, parameters).fetchone()

# Получение всех запросов продавцов
def get_3tohour_postx():
    with sqlite3.connect(PATH_DATABASE) as con:
        print("-->")
        sql = "SELECT * FROM storage_posts WHERE mode_remind=1 AND strftime('%s', dtpost) < strftime('%s', 'now') LIMIT 3"
        return con.execute(sql).fetchall()
        #posts = con.execute("SELECT * FROM storage_posts WHERE state = 'created' AND dtpost < datetime('now')").fetchall()
        #return posts

# Получение всех запросов продавцов
def get_tohour_postx():
    with sqlite3.connect(PATH_DATABASE) as con:
        print("-->")
        sql = "SELECT * FROM storage_posts "
        return con.execute(
            f"{sql}WHERE state='created' AND strftime('%s', dtpost) < strftime('%s', 'now')"
        ).fetchall()

# Получение всех запросов продавцов
def update_tohour_postx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.execute("UPDATE storage_posts SET state = 'sended' WHERE dtpost < datetime('now')")
        con.commit()

# Получение всех запросов продавцов
def update_3tohour_postx(post_ids):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.execute("UPDATE storage_posts SET remind_iter = remind_iter+1 WHERE post_id in(?)", [])
        con.commit()

# Получение всех запросов продавцов
def get_sellers_news_postx(tag = "selnews"):
    with sqlite3.connect(PATH_DATABASE) as con:
        print("-->")
        sql = "SELECT * FROM storage_posts "
        return con.execute(
            f"{sql}WHERE state = 'created' AND tag = ?", [tag]
        ).fetchall()


# Получение всех запросов продавцов
def get_planed_postx(mode_evening = "evening"):
    with sqlite3.connect(PATH_DATABASE) as con:
        print("-->")
        sql = "SELECT * FROM storage_posts "
        return con.execute(
            f"{sql}WHERE state = 'created' AND mode_evening = ?",
            [mode_evening],
        ).fetchall()



def get_planed_eventsx():
    with sqlite3.connect(PATH_DATABASE) as con:
        print("-->")
        sql = "SELECT event_photo, event_name || ' | ' ||event_description|| ' | ' || address as xxx FROM storage_events LEFT JOIN storage_places USING(place_id)"
        #return con.execute(sql + "WHERE strftime('%s', event_date) > strftime('%s', 'now')").fetchall()
        return con.execute(sql).fetchall()

# Редактирование запроса
def update_post(post_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_posts SET "
        sql, parameters = update_format(sql, kwargs)
        parameters.append(post_id)
        con.execute(f"{sql}WHERE post_id = ?", parameters)
        con.commit()

# Редактирование запроса
def update_event(event_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_events SET "
        sql, parameters = update_format(sql, kwargs)
        parameters.append(event_id)
        con.execute(f"{sql}WHERE event_id = ?", parameters)
        con.commit()

#есть ли магазин у пользователя
def check_user_shop_exist(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT a.user_role, b.admin, b.name FROM storage_users a LEFT JOIN storage_shop b ON(a.user_id=b.admin)"
        shopadmin = con.execute(f"{sql}WHERE a.user_id = ?", [user_id]).fetchone()
        #print(shopadmin)
        if (
            shopadmin['user_role'] == "ShopAdmin"
            and shopadmin['admin'] is not None
        ): return shopadmin['name']
        elif shopadmin['user_role'] == "Admin": return False
        #else: return shopadmin['admin']

#есть ли магазин у пользователя
def check_user_artist_exist(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT a.user_role, b.admin, b.name FROM storage_users a LEFT JOIN storage_artists b ON(a.user_id=b.admin)"
        shopadmin = con.execute(f"{sql}WHERE a.user_id = ?", [user_id]).fetchone()
        print(shopadmin)
        if (
            shopadmin['user_role'] == "ShopAdmin"
            and shopadmin['admin'] is not None
        ): return shopadmin['name']
        elif shopadmin['user_role'] == "Admin": return False
        #else: return shopadmin['admin']

#есть ли магазин у пользователя
def check_user_events_exist(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT a.user_id, b.event_name, b.event_user_id FROM storage_users a LEFT JOIN storage_events b ON(a.user_id=b.event_user_id)"
        users_event = con.execute(f"{sql}WHERE a.user_id = ?", [user_id]).fetchone()
        print(users_event)
        #if shopadmin['user_role'] == "ShopAdmin" and not (shopadmin['admin'] is None): return shopadmin['name']
        #elif shopadmin['user_role'] == "Admin": return False
        #else: return shopadmin['admin']
        return users_event


# Добавление аккаунта ТГ в БД
def add_account_todb(xid, xhash, xphone, invited24, state='created'):
    with sqlite3.connect(PATH_DATABASE) as con:
        datenow = datetime.datetime.now()
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_tgaccounts "
                    "(tg_api_id, tg_api_hash, phone, invited24, date, state) "
                    "VALUES (?, ?, ?, ?, ?, ?)",
                    [xid, xhash, xphone, invited24, datenow, state])
        con.commit()
        #print(con.lastrowid)

# Получение всех запросов продавцов
def get_lasttgaccount():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        #sql = "SELECT state, invited24, last FROM storage_tgaccounts "
        sql = "SELECT MAX(account_id) as acc FROM storage_tgaccounts GROUP BY account_id"
        return con.execute(sql).fetchone()[0]

# Группы в ТГ
def groups_telegram():
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT group_id, groupname, count(acc_id) as countacc FROM storage_tgparse WHERE groupname != '' AND source = 'groups' AND state = 'created' GROUP BY group_id ORDER BY group_id ASC"
        return con.execute(sql).fetchall()

# Пользователи группы для инвайта
def first_grouptoinvitebyid(groupid, start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = f"SELECT * FROM storage_tgparse WHERE state = 'created' AND source = 'groups' AND group_id=? ORDER BY acc_id ASC LIMIT {start},{count}"
        return con.execute(sql, [groupid]).fetchall()

# Пользователи группы для инвайта
def first_grouptoinvite(groupname, start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = f"SELECT * FROM storage_tgparse WHERE state = 'created' AND source = 'groups' AND groupname=? ORDER BY acc_id ASC LIMIT {start},{count}"
        return con.execute(sql, [groupname]).fetchall()

# Последние 10 покупок
def first_toinvite(state, start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = f"SELECT * FROM storage_tgparse WHERE state = ? AND source = 'groups' ORDER BY acc_id ASC LIMIT {start},{count}"
        return con.execute(sql, [state]).fetchall()



def firstgeo_toinvite(state, start, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = f"SELECT * FROM storage_tgparse WHERE state = ? AND source = 'geoparse' ORDER BY acc_id ASC LIMIT {start},{count}"
        return con.execute(sql, [state]).fetchall()
        #return con.execute(sql).fetchall()

# Редактирование запроса
def update_tgparsex(acc_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_tgparse SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(acc_id)
        con.execute(f"{sql}WHERE acc_id = ?", parameters)
        con.commit()

# Редактирование запроса
def update_tgaccounts(account_id, pole):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        inc = ""
        if pole == 'available':
            inc = " state = 'available', invited24 = 0 "
        elif pole == 'banned':
            inc = " state = 'banned' "
        elif pole == 'invited24':
            inc = " invited24 = invited24 + 1, last = datetime('now') "
        elif pole == 'iter24':
            inc = " iter24 = iter24 + 1 "
        elif pole == 'waitfor24':
            inc = " state = 'wait', waitfor24 = datetime('now', '+1 day') "
        sql = f"UPDATE storage_tgaccounts SET {inc}"
        #sql, parameters = update_format(sql, kwargs)
        #parameters.append(account_id)
        con.execute(f"{sql}WHERE account_id = ?", [account_id])
        con.commit()

#удаление аккаунта
def delete_tgacc(acc_id):
    print(f"Удаляем аккаунт{acc_id}")
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_tgaccounts "
        #sql, parameters = update_format_args(sql, kwargs)
        #sql, user_id = update_format(sql, user_id)
        con.execute(f"{sql}WHERE account_id = ?", [acc_id])
        con.commit()

# Получение всех запросов продавцов
def get_delivery_seller_options(order_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_orders_users_items "
        return con.execute(f"{sql}WHERE order_id = ?", [order_id]).fetchone()

# Получение всех запросов продавцов
def get_users_by_citiesx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT user_city, user_city_id, count(user_id) as countu FROM storage_users WHERE user_city_id IS NULL GROUP BY user_city_id ORDER BY countu DESC"
        return con.execute(sql).fetchall()

def get_users_by_cities():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT user_city, user_city_id, count(user_id) as countu FROM storage_users GROUP BY user_city_id ORDER BY countu DESC"
        return con.execute(sql).fetchall()

def get_category_count(category_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = f"SELECT COUNT(position_id) as countp FROM storage_position WHERE category_id={category_id}"
        return con.execute(sql).fetchone()

# Получение всех запросов продавцов
def get_all_requestx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT DISTINCT requester as user_id FROM storage_requests ORDER BY datetime ASC"
        return con.execute(sql).fetchall()

# Удаление запроса
def delete_requests_userx(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_requests "
        #sql, parameters = update_format_args(sql, kwargs)
        #sql, user_id = update_format(sql, user_id)
        con.execute(f"{sql}WHERE requester = ?", [user_id])
        con.commit()


# Редактирование запроса
def update_requestx(user_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_requests SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(user_id)
        con.execute(f"{sql}WHERE user_id = ?", parameters)
        con.commit()


# Проверка принадлежности позиции в каталоге
def check_position_owner(user_id, position_id):
    print('Проверка принадлежности позиции api_sqlite.py  86')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT position_user_id FROM storage_position "
        #sql, parameters = update_format_args(sql, kwargs)
        #return con.execute(sql, parameters).fetchone()

        #sql, parameters = update_format(sql, kwargs)
        #parameters.append(user_id)
        dbuser_id = con.execute(
            f"{sql}WHERE position_id = ?", [position_id]
        ).fetchone()
        #con.commit()
        print(f'Лот пользователя {dbuser_id} проверяем для {user_id} 97')
        return user_id in [dbuser_id['position_user_id'], 919148970]

#create_seller_request('919148970')
####################################################################################################
########################################### ЗАПРОСЫ К БД ###########################################

# Добавление пользователя
def add_userx(user_id, user_login, user_name, user_lang, user_role):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_users "
                    "(user_id, user_login, user_name, user_lang, user_role, user_balance, user_refill, user_date, user_unix) "
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [user_id, user_login, user_name, user_lang, user_role, 0, 0, get_date(), get_unix()])
        con.commit()


# Получение платежных реквизитов продавца
def get_user_language(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute("SELECT * FROM storage_users WHERE user_id = ?", [user_id]).fetchone()

# Получение платежных реквизитов продавца
def get_user_lang(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute("SELECT user_lang FROM storage_users WHERE user_id = ?", [user_id]).fetchone()

# Добавление пользователя
def add_userxo(user_id, user_login, user_name):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_users "
                    "(user_id, user_login, user_name, user_balance, user_refill, user_date, user_unix) "
                    "VALUES (?, ?, ?, ?, ?, ?, ?)",
                    [user_id, user_login, user_name, 0, 0, get_date(), get_unix()])
        con.commit()

# Получение пользователя
def get_userxn(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_users WHERE user_city_id IS NULL"
        #sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql).fetchall()

# Получение пользователя
def get_userxxx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT user_id FROM storage_users"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение пользователя
def get_userxx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_users"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение пользователя
def get_userx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_users"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()


# Получение админов магазинов
def get_shopadmins(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT user_id FROM storage_users WHERE user_role='ShopAdmin'"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение пользователей
def get_usersx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_users"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение всех пользователей
def get_all_usersx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_users"
        return con.execute(sql).fetchall()

# Получение всех пользователей
def get_all_usersxx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_users WHERE user_city_id IS NOT NULL"
        return con.execute(sql).fetchall()

# Получение всех пользователей
def get_top_sellersx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_users WHERE user_role='ShopAdmin' AND user_balance >0 ORDER BY user_balance DESC LIMIT 0,15"
        return con.execute(sql).fetchall()



# Редактирование пользователя
def update_userx(user_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_users SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(user_id)
        con.execute(f"{sql}WHERE user_id = ?", parameters)
        con.commit()

# Редактирование пользователя
def update_holdx(order_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_money_holds SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(order_id)
        con.execute(f"{sql}WHERE order_id = ?", parameters)
        con.commit()

# Удаление пользователя
def delete_userx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_users"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

# Получение платежных реквизитов продавца
def get_tron_profile(user_id, type_net):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        parameters = [user_id, type_net]
        return con.execute("SELECT tron_wallet, type_net, tron_secret_key FROM storage_payment WHERE user_id = ? AND type_net =?", parameters).fetchone()

# Получение платежных реквизитов продавца
def get_upaymentx(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute("SELECT * FROM storage_payment WHERE user_id = ?", [user_id]).fetchone()

def get_upaycount(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute("SELECT COUNT(*) as paycount FROM storage_payment WHERE user_id = ?", [user_id]).fetchone()


# Редактирование платежных систем
def update_tron_profile(user_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_payment SET "
        sql, parameters = update_format(sql, kwargs)
        parameters.append(user_id)
        con.execute(f"{sql} WHERE user_id = ?", parameters)
        con.commit()

#Получение адреса трон плошадки
def get_system_tron_address():
    with sqlite3.connect(PATH_DATABASE) as con:
        print(user_id)
        con.row_factory = dict_factory
        sql = "SELECT tron_address FROM storage_crypto_payment WHERE private_key='Admin' and type_net='USDT'"
        return con.execute(sql).fetchone()

#Получение адреса трон плошадки
def get_system_crypto_address(type_net):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT tron_address FROM storage_crypto_payment WHERE private_key='Admin' and type_net=?"
        return con.execute(sql, [type_net]).fetchone()

#Получение адреса трон
def get_tron_address(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        print(user_id)
        con.row_factory = dict_factory
        sql = "SELECT tron_address FROM storage_crypto_payment WHERE user_id=?"
        return con.execute(sql, [user_id]).fetchone()

#Получение адреса трон
def get_crypto_address(user_id, crypto_coin):
    with sqlite3.connect(PATH_DATABASE) as con:
        print(user_id)
        con.row_factory = dict_factory
        sql = "SELECT tron_address FROM storage_crypto_payment WHERE user_id=? AND type_net=?"
        return con.execute(sql, [user_id, crypto_coin]).fetchone()

def create_crypto_payment_row(user_id, tron_address, crypto_net):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_crypto_payment "
                    "(user_id, tron_address, type_net)"
                    "VALUES (?, ?, ?)",
                    [user_id, tron_address, crypto_net])
        con.commit()

# Редактирование платежных систем
def update_crypto_address(user_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_crypto_payment SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(user_id)
        con.execute(sql + "WHERE user_id = ?", parameters)
        con.commit()


def create_upayments_row(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_payment "
                    "(qiwi_login, qiwi_token, qiwi_secret, qiwi_nickname, way_form, way_number, way_nickname, user_id, yoo_token, yoo_client_id, yoo_redirect_url, yoo_acc_number, way_formy)"
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    ['', '', '', '', 'False', 'False', 'False', user_id, '', 0, '', 0, 'False'])
        con.commit()

# Получение платежных систем
def get_paymentx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_payment WHERE user_id=919148970"
        return con.execute(sql).fetchone()


# Редактирование платежных систем
def update_paymentx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_payment SET"
        sql, parameters = update_format(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

# Редактирование платежных систем
def update_upaymentx(user_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_payment SET "
        sql, parameters = update_format(sql, kwargs)
        parameters.append(user_id)
        con.execute(f"{sql} WHERE user_id = ?", parameters)
        con.commit()

# Получение настроек
def get_settingsx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_settings"
        return con.execute(sql).fetchone()


# Редактирование настроек
def update_settingsx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_settings SET"
        sql, parameters = update_format(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()


# Добавление пополнения
def add_refillx(user_id, user_login, user_name, refill_comment, refill_amount, refill_receipt,
                refill_way, refill_date, refill_unix):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_refill "
                    "(user_id, user_login, user_name, refill_comment, refill_amount, refill_receipt, refill_way, refill_date, refill_unix) "
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [user_id, user_login, user_name, refill_comment, refill_amount, refill_receipt, refill_way,
                     refill_date, refill_unix])
        con.commit()

# Добавление пополнения
def add_prepay(pay_user_id, type_net, coinprice, pay_amount, priceincoin, receipt):
    with sqlite3.connect(PATH_DATABASE) as con:
        a = D(coinprice)
        b = D(pay_amount)
        c = D(priceincoin)
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_prepay "
                    "(pay_user_id, type_net, coinprice, pay_amount, priceincoin, receipt) "
                    "VALUES (?, ?, ?, ?, ?, ?)",
                    [(pay_user_id, type_net, a, b, c, receipt)])
        con.commit()

# Получение препополнения
def get_refillx2(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_prepay"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение пополнения
def get_refillx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_refill"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()


# Получение пополнений
def get_refillsx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_refill"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()


# Получение всех пополнений
def get_all_refillx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_refill"
        return con.execute(sql).fetchall()


# Добавление категории
def add_categoryx(category_name):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_category (category_id, category_name) VALUES (?, ?)",
                    [random.randint(1000000000, 9999999999), category_name])
        con.commit()


# Изменение категории
def update_categoryx(category_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_category SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(category_id)
        con.execute(f"{sql}WHERE category_id = ?", parameters)
        con.commit()


# Получение категории
def get_category_people(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM cls_categories"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение категории
def get_categoryx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_category"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение категорий
def get_categoriesx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_category"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение всех категорий
def get_all_shopx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_shop"
        return con.execute(sql).fetchall()

# Получение магазина
def get_eventxx(**kwargs):
    print('Получение магазина api_sqlite.py 581')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_events"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение магазина
def get_promocodex(**kwargs):
    print('Получение магазина api_sqlite.py 581')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_promocode"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение магазина
def get_shopsxy():
    print('Получение магазина api_sqlite.py 844')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_shop"
        return con.execute(sql).fetchall()

# Получение магазина
def get_shopsxx(**kwargs):
    print('Получение магазина api_sqlite.py 318')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_shop"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение магазина
def get_artistsxx(**kwargs):
    print('Получение артистов по критериям api_sqlite.py 318')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_artists"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение платежных реквизитов продавца
def get_my_shopx(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_shop "
        #sql, parameters = update_format(sql, kwargs)
        return con.execute(sql, "WHERE admin = ?", [user_id]).fetchall()

# Получение платежных реквизитов продавца
def get_my_shopx2(admin):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_shop "
        #sql, parameters = update_format(sql, kwargs)
        return con.execute(sql, "WHERE admin = ?", [admin]).fetchone()

# Получение всех категорий
def get_all_categoriespx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM cls_categories"
        return con.execute(sql).fetchall()

# Получение всех категорий
def get_all_categoriesx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_category"
        return con.execute(sql).fetchall()

# Получение всех категорий
def get_all_events():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_events a LEFT JOIN storage_places b USING(place_id) ORDER BY datetime(event_date) ASC"
        return con.execute(sql).fetchall()

# Получение всех категорий
def get_all_places():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_places"
        return con.execute(sql).fetchall()

# Удаление всех категорий
def clear_categoryx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_category"
        con.execute(sql)
        con.commit()

# Удаление категории
def remove_categoryx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_category"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

# Добавление магазина
def add_artistx(name, description, webadress, admin, logo, city, geocode, city_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_artists (artist_id, name, description, webaddress, admin, logo, city, geocode, city_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [random.randint(1000000000, 9999999999), name, description, webadress, admin, logo, city, geocode, city_id])
        con.commit()

# Добавление магазина
def add_eventx(name, description, webadress, event_user_id, logo, city, geocode, city_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_events (event_id, event_name, event_description, webaddress, event_user_id, event_photo, event_city, geocode, event_city_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [random.randint(1000000000, 9999999999), name, description, webadress, event_user_id, logo, city, geocode, city_id])
        con.commit()


# Добавление категории ? позиции
def add_positionx(position_city, position_city_id, position_name, position_price, position_type, position_rest, position_description, position_photo, category_id, store_id, position_user_id, position_source):
    print('Добавление позиции  api_sqlite_shop.py  294')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_position "
                    "(position_id, position_name, position_price, position_type, position_rest, position_description, position_photo, position_date, category_id, position_city, store_id, position_city_id, position_user_id, source) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [random.randint(1000000000, 9999999999), position_name, position_price, position_type, position_rest, position_description,
                     position_photo, get_date(), category_id, position_city, store_id, position_city_id, position_user_id, position_source])
        con.commit()


# Изменение позиции
def update_shopx(shop_id, **kwargs):
    print('Изменение позиции api_sqlite.py 306')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_shop SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(shop_id)
        con.execute(f"{sql}WHERE shop_id = ?", parameters)
        con.commit()

# Изменение позиции
def update_positionx(position_id, **kwargs):
    print('Изменение позиции api_sqlite.py 306')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_position SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(position_id)
        con.execute(f"{sql}WHERE position_id = ?", parameters)
        con.commit()

# Изменение позиции
def update_artistx(artist_id, **kwargs):
    print('Изменение артиста api_sqlite.py 306')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_artists SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(artist_id)
        con.execute(f"{sql}WHERE artist_id = ?", parameters)
        con.commit()

# Получение магазина
def get_placesx(**kwargs):
    print('Получение магазина api_sqlite.py 642')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_places"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение магазина
def get_shopx(**kwargs):
    print('Получение магазина api_sqlite.py 642')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_shop"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение позиции
def get_artistx(**kwargs):
    print('Получение позиции api_sqlite.py 318')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_artists"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение позиции
def get_positionx(**kwargs):
    print('Получение позиции api_sqlite.py 318')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_position"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()

# Получение сообщений для пользователя
def get_user_messagesx(**kwargs):
    print('Получение сообющений для пользователя api_sqlite.py  367')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_messages"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Обмновление статуса сообщения
def update_orderx(order_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_orders SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(order_id)
        con.execute(f"{sql}WHERE order_id = ?", parameters)
        con.commit()

# Изменение корзины
def update_orderx(order_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_orders SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(order_id)
        con.execute(f"{sql}WHERE order_id = ?", parameters)
        con.commit()

# Изменение холда
def update_holdsx(order_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_money_holds SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(order_id)
        con.execute(f"{sql}WHERE order_id = ?", parameters)
        con.commit()

# Получение продавцов корзины
def get_cart_sellersx(order_id):
    print('Получение продавцов корзины api_sqlite.py  777')
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sellers = con.execute(
            "SELECT DISTINCT owner_uid FROM storage_orders_items WHERE order_id = ?",
            [order_id],
        ).fetchall()
        print(len(sellers))
        slss=''
        slsss = ''.join(sellers)
        print(slsss)
        slsss1 = slsss.replace('(', '')
        slsss2 = slsss1.replace(')', '')
        return slsss2.replace(',', '')


# Получение позиций корзины
def get_cart_positionsx(order_id):
    print('Получение позиций корзины  api_sqlite.py  568')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT * FROM storage_orders_items LEFT JOIN storage_position USING(position_id) WHERE order_id = ?",
            [order_id],
        ).fetchall()

# Получение позиций корзины
def get_order_sellers(order_id):
    print('Получение позиций корзины  api_sqlite.py  568')
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        positions = con.execute(
            "SELECT DISTINCT owner_uid as owner_id FROM storage_orders_items WHERE order_id = ?",
            [order_id],
        ).fetchall()
        return json.dumps(positions)
        #return positions


# Получение данных холдов заказа
def get_orders_holdsx(order_id):
    print(f'Получение холдов заказа {order_id} 626')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT * FROM storage_money_holds WHERE order_id = ?", [order_id]
        ).fetchall()

# Получение позиций
def get_positionsx(**kwargs):
    print('Получение позиций (дубль)  api_sqlite.py  1002')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_position"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение всех моих позиций
def get_positionsorder(category_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(f"SELECT * FROM storage_position WHERE сategory_id = ? ORDER BY position_name ASC", [category_id]).fetchall()

# Получение всех категорий
def get_all_positionsidx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT position_id FROM storage_position"
        return con.execute(sql).fetchall()

# Получение всех категорий
def get_all_positionsx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_position"
        return con.execute(sql).fetchall()


# Удаление всех позиций
def clear_positionx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_position"
        con.execute(sql)
        con.commit()

# Удаление позиции
def remove_shopx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_shop"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()


# Удаление позиции
def remove_artistx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_artists"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()

# Удаление позиции
def remove_positionx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_position"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()


# Добавление товара
def add_itemx(category_id, position_id, get_all_items, user_id, user_name):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory

        for item_data in get_all_items:
            if not item_data.isspace() and item_data != "":
                con.execute("INSERT INTO storage_item "
                            "(item_id, item_data, position_id, category_id, creator_id, creator_name, add_date) "
                            "VALUES (?, ?, ?, ?, ?, ?, ?)",
                            [random.randint(1000000000, 9999999999), clear_html(item_data.strip()), position_id, category_id,
                             user_id, user_name, get_date()])
        con.commit()


# Изменение товара
def update_itemx(item_id, **kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "UPDATE storage_item SET"
        sql, parameters = update_format(sql, kwargs)
        parameters.append(item_id)
        con.execute(f"{sql}WHERE item_id = ?", parameters)
        con.commit()

# Получение продавца заказа
def get_ordersellerx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_item"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()


# Получение товара
def get_itemx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_item"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchone()


# Получение товаров
def get_itemsx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_item"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение всех товаров
def get_all_itemsx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_item"
        return con.execute(sql).fetchall()

# Получение всех моих позиций
def get_all_my_positionsx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_position"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(f"{sql}WHERE position_user_id = ?", [user_id]).fetchall()

# Получение всех моих позиций
def get_all_my_positionsnx(position_user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_position"
        #sql, parameters = update_format_args(sql, kwargs)
        return con.execute(
            f"{sql} WHERE position_user_id = ?", [position_user_id]
        ).fetchall()

# Получение всех моих товаров
def get_all_my_itemsnx(creator_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_item"
        #sql, parameters = update_format_args(sql, kwargs)
        return con.execute(f"{sql} WHERE creator_id = ?", [creator_id]).fetchall()

# Получение всех моих товаров
def get_all_my_itemsx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_item"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(f"{sql}WHERE creator_id = ?", [user_id]).fetchall()


# Очистка товаров
def clear_itemx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_item"
        con.execute(sql)
        con.commit()


# Удаление товаров
def remove_itemx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "DELETE FROM storage_item"
        sql, parameters = update_format_args(sql, kwargs)
        con.execute(sql, parameters)
        con.commit()


# Покупка товаров
def buy_itemx(get_items, get_count):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        split_len, send_count, save_items = 0, 0, []

        for select_send_item in get_items:
            if send_count == get_count:
                break
            send_count += 1
            select_data = (
                f"{send_count}. {select_send_item['item_data']}"
                if get_count >= 2
                else select_send_item['item_data']
            )
            save_items.append(select_data)
            sql, parameters = update_format_args("DELETE FROM storage_item",
                                                 {"item_id": select_send_item['item_id']})
            con.execute(sql, parameters)

            if len(select_data) >= split_len: split_len = len(select_data)
        con.commit()

        split_len += 1
        get_len = math.ceil(3500 / split_len)

    return save_items, send_count, get_len

# Проверка существования заказа
def get_orderx(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT * FROM storage_orders WHERE user_id = ?", [user_id]
        ).fetchone()

# Проверка существования заказа
def get_orderxo(order_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute("SELECT * FROM storage_orders WHERE order_id = ?", [order_id]).fetchone()

# Последние 10 покупок
def get_alladmin_orderx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT DISTINCT b.order_id, b.order_state FROM storage_orders b"
        #sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql).fetchall()

# Последние 10 покупок
def get_order_items(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_orders_items"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Последние 10 покупок
def get_seller_orderx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT DISTINCT a.order_id, a.owner_uid, b.order_state, count(DISTINCT a.owner_uid) as selbyo FROM storage_orders_items a LEFT JOIN storage_orders b USING(order_id) GROUP BY a.order_id"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Последние 10 покупок
def get_params_orderxx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_orders LEFT JOIN storage_orders_items USING(order_id)"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Последние 10 покупок
def get_params_orderx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_orders"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()


# Проверка существования заказа
def get_userc_orderx(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        #con.row_factory = dict_factory
        sql = "SELECT order_state FROM storage_orders WHERE order_state='created' AND user_id = ?"
        order = con.execute(sql, [user_id]).fetchone()
        order=json.dumps(order)
        print(order)
        return order

# Проверка существования заказа
def get_user_orderx(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT * FROM storage_orders WHERE user_id = ?", [user_id]
        ).fetchone()


# Создание заказа
def create_orderx(user_id, user_login, user_name, order_state, order_date, order_unix):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_orders "
                    "(user_id, user_login, user_name, order_state, order_date, order_unix) "
                    "VALUES (?, ?, ?, ?, ?, ?)",
                    [user_id, user_login, user_name, order_state, order_date, order_unix])
        con.commit()

# Создание холда
def create_holdx(order_id, buyer, seller, amount, validity, state):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_money_holds "
                    "(order_id, buyer, seller, amount, validity, state) "
                    "VALUES (?, ?, ?, ?, ?, ?)",
                    [order_id, buyer, seller, amount, validity, state])
        con.commit()

# Добавление товара в заказ
def add_order_itemx(user_id, order_id, position_id, count, price, receipt, owner_uid):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_orders_items "
                    "(user_id, order_id, position_id, count, price, receipt, owner_uid) "
                    "VALUES (?, ?, ?, ?, ?, ?, ?)",
                    [user_id, order_id, position_id, count, price, receipt, owner_uid])
        con.commit()


# Добавление сообщения
def add_messagex(from_id, to_id, order_id, txtmessage, photo, state):
    print('Добавление позиции api_sqlite_shop.py  294')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_messages "
                    "(message_id, from_uid, to_uid, order_id, message, photo, state) VALUES (?, ?, ?, ?, ?, ?, ?)",
                    [random.randint(1000000000, 9999999999), from_id, to_id, order_id, txtmessage, photo, state])
        con.commit()

def get_params_messagesx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_messages"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Добавление покупки
def add_purchasex(user_id, user_login, user_name, purchase_receipt, purchase_count, purchase_price, purchase_price_one,
                  purchase_position_id, purchase_position_name, purchase_item, purchase_date, purchase_unix,
                  balance_before, balance_after):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        con.execute("INSERT INTO storage_purchases "
                    "(user_id, user_login, user_name, purchase_receipt, purchase_count, purchase_price, purchase_price_one, purchase_position_id, "
                    "purchase_position_name, purchase_item, purchase_date, purchase_unix, balance_before, balance_after) "
                    "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    [user_id, user_login, user_name, purchase_receipt, purchase_count, purchase_price,
                     purchase_price_one, purchase_position_id, purchase_position_name, purchase_item, purchase_date,
                     purchase_unix, balance_before, balance_after])
        con.commit()



# Получение покупок
def get_purchasesbysellers():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT DISTINCT c.user_id FROM storage_purchases a LEFT JOIN storage_position b ON(a.purchase_position_id=b.position_id) LEFT JOIN storage_users c ON(c.user_id=b.position_user_id) WHERE c.user_id NOT NULL GROUP BY a.user_id, a.purchase_position_name"
        #sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql).fetchall()


# Получение покупок
def get_purchasesxx2(user_id):
    #with sqlite3.connect(PATH_DATABASE) as con:
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = "SELECT c.user_id, a.purchase_position_name, SUM(a.purchase_count) as counts, SUM(a.purchase_price) as price FROM storage_purchases a LEFT JOIN storage_position b ON(a.purchase_position_id=b.position_id) LEFT JOIN storage_users c ON(c.user_id=b.position_user_id) WHERE c.user_id=? GROUP BY a.user_id, a.purchase_position_name"
    #result = cur.execute(query, (user_id,)).fetchall()
    result = cur.execute(query, [user_id]).fetchall()
    cur.close()
    return result

def get_purchasesx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_purchases"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

    # Получение покупок
def get_purchasesxx3(user_id):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        #cur = conn.cursor()
        sql = "SELECT c.user_id, a.purchase_position_name, SUM(a.purchase_count) as counts, SUM(a.purchase_price) as price FROM storage_purchases a LEFT JOIN storage_position b ON(a.purchase_position_id=b.position_id) LEFT JOIN storage_users c ON(c.user_id=b.position_user_id) WHERE c.user_id=? GROUP BY a.user_id, a.purchase_position_name"
        sql, parameters = update_format_args(sql, [user_id])
        return con.execute(sql, parameters).fetchall()


def get_purchasesxx(user_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    #cur = conn.cursor()
    query = '''SELECT c.user_id, a.purchase_position_name, SUM(a.purchase_count) as counts, SUM(a.purchase_price) as price FROM storage_purchases a LEFT JOIN storage_position b ON(a.purchase_position_id=b.position_id) LEFT JOIN storage_users c ON(c.user_id=b.position_user_id) WHERE c.user_id=? GROUP BY a.user_id, a.purchase_position_name'''
    return conn.execute(query, (user_id,)).fetchall()

# Получение запросов
def get_requestx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_requests"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Получение всех покупок
def get_all_purchasesx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_purchases"
        return con.execute(sql).fetchall()

# Получение всех покупок
def getpurchasesbysellersx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_purchases LEFT JOIN storage_position USING(user_id)"
        return con.execute(sql).fetchall()


# Последние 10 покупок
def last_purchasesx(user_id, count):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = f"SELECT * FROM storage_purchases WHERE user_id = ? ORDER BY increment DESC LIMIT {count}"
        return con.execute(sql, [user_id]).fetchall()


# Создание всех таблиц для БД
def create_dbx():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory

        # Создание БД с хранением данных пользователей
        if len(con.execute("PRAGMA table_info(storage_users)").fetchall()) == 12:
            print("DB was found(1/12)")
        else:
            con.execute("CREATE TABLE IF NOT EXISTS storage_users("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "user_id INTEGER,"
                        "user_login TEXT,"
                        "user_name TEXT,"
                        "user_address TEXT,"
                        "user_phone TEXT,"
                        "user_balance INTEGER,"
                        "user_refill INTEGER,"
                        "user_date TIMESTAMP,"
                        "user_unix INTEGER,"
                        "user_city TEXT,"
                        "user_geocode TEXT,"
                        "user_role TEXT,"
                        "user_city_id INTEGER)")  # Добавил город
            print("DB was not found(1/12) | Creating...")

        # Создание БД с хранением данных платежных систем
        if len(con.execute("PRAGMA table_info(storage_payment)").fetchall()) == 18:
            print("DB was found(2/12)")
        else:
            con.execute("CREATE TABLE IF NOT EXISTS storage_payment("
                        "qiwi_login TEXT,"
                        "qiwi_token TEXT,"
                        "qiwi_secret TEXT,"
                        "qiwi_nickname TEXT,"
                        "way_form TEXT,"
                        "way_number TEXT,"
                        "way_nickname TEXT,"
                        "way_formy TEXT,"
                        "user_id INTEGER,"
                        "yoo_token TEXT,"
                        "yoo_client_id TEXT,"
                        "yoo_redirect_url TEXT,"
                        "yoo_acc_number INTEGER,"
                        "coinbase_key TEXT,"
                        "coinbase_secret TEXT,"
                        "way_coinbase TEXT,"
                        "way_freecredi TEXT)")

            con.execute("INSERT INTO storage_payment("
                        "qiwi_login, qiwi_token, qiwi_secret, qiwi_nickname, way_form, way_number, way_nickname, way_formy, yoo_token, yoo_client_id, yoo_redirect_url, yoo_acc_number) "
                        "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                        ['None', 'None', 'None', 'None', 'False', 'False', 'False', 'False', 'None', 'None', 'None', 'None'])
            print("DB was not found(2/12) | Creating...")

        # Создание БД с хранением настроек
        if len(con.execute("PRAGMA table_info(storage_settings)").fetchall()) == 10:
            print("DB was found(3/12)")
        else:
            con.execute("CREATE TABLE storage_settings("
                        "status_work TEXT,"
                        "status_refill TEXT,"
                        "status_buy TEXT,"
                        "misc_faq TEXT,"
                        "misc_support TEXT,"
                        "misc_bot TEXT,"
                        "misc_update TEXT,"
                        "misc_profit_day INTEGER,"
                        "misc_profit_week INTEGER,"
                        "type_trade TEXT)")

            con.execute("INSERT INTO storage_settings("
                        "status_work, status_refill, status_buy, misc_faq, misc_support, misc_bot, misc_update, misc_profit_day, misc_profit_week)"
                        "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                        ["True", "False", "False", "None", "None", "None", "False", get_unix(), get_unix()])
            print("DB was not found(3/12) | Creating...")

        # Создание БД с хранением пополнений пользователей
        if len(con.execute("PRAGMA table_info(storage_refill)").fetchall()) == 10:
            print("DB was found(4/12)")
        else:
            con.execute("CREATE TABLE storage_refill("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "user_id INTEGER,"
                        "user_login TEXT,"
                        "user_name TEXT,"
                        "refill_comment TEXT,"
                        "refill_amount INTEGER,"
                        "refill_receipt TEXT,"
                        "refill_way TEXT,"
                        "refill_date TIMESTAMP,"
                        "refill_unix INTEGER)")
            print("DB was not found(4/12) | Creating...")

        # Создание БД с хранением категорий
        if len(con.execute("PRAGMA table_info(storage_category)").fetchall()) == 5:
            print("DB was found(5/8)")
        else:
            con.execute("CREATE TABLE storage_category("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "level INTEGER,"
                        "parent_id INTEGER,"
                        "category_id INTEGER,"
                        "category_name TEXT)")
            print("DB was not found(5/12) | Creating...")


        # Создание БД с хранением позиций
        if len(con.execute("PRAGMA table_info(storage_position)").fetchall()) == 11:
            print("DB was found(6/12)")
        else:
            con.execute("CREATE TABLE IF NOT EXISTS storage_position("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "position_id INTEGER,"
                        "position_name TEXT,"
                        "position_price INTEGER,"
                        "position_description TEXT,"
                        "position_photo TEXT,"
                        "position_date TIMESTAMP,"
                        "category_id INTEGER,"
                        "store_id INTEGER,"
                        "position_city TEXT,"
                        "position_city_id INTEGER)")
            print("DB was not found(6/12) | Creating...")

        # Создание БД с хранением товаров
        if len(con.execute("PRAGMA table_info(storage_item)").fetchall()) == 9:
            print("DB was found(7/12)")
        else:
            con.execute("CREATE TABLE IF NOT EXISTS storage_item("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "item_id INTEGER,"
                        "item_data TEXT,"
                        "position_id INTEGER,"
                        "category_id INTEGER,"
                        "shop_id INTEGER,"
                        "creator_id INTEGER,"
                        "creator_name TEXT,"
                        "add_date TIMESTAMP)")
            print("DB was not found(7/12) | Creating...")

        # # Создание БД с хранением покупок
        if len(con.execute("PRAGMA table_info(storage_purchases)").fetchall()) == 15:
            print("DB was found(8/12)")
        else:
            con.execute("CREATE TABLE IF NOT EXISTS storage_purchases("
                        "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                        "user_id INTEGER,"
                        "user_login TEXT,"
                        "user_name TEXT,"
                        "purchase_receipt TEXT,"
                        "purchase_count INTEGER,"
                        "purchase_price INTEGER,"
                        "purchase_price_one INTEGER,"
                        "purchase_position_id INTEGER,"
                        "purchase_position_name TEXT,"
                        "purchase_item TEXT,"
                        "purchase_date TIMESTAMP,"
                        "purchase_unix INTEGER,"
                        "balance_before INTEGER,"
                        "balance_after INTEGER)")
            print("DB was not found(8/12) | Creating...")

            if len(con.execute("PRAGMA table_info(storage_shop)").fetchall()) == 3:
                print("DB was not found(9/12) | Creating...")
            else:
                # Создание БД с хранением магазинов
                con.execute("CREATE TABLE IF NOT EXISTS storage_shop("
                            "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                            "shop_id INTEGER,"
                            "shop_name TEXT)")

            # # Создание БД с хранением покупок
            if len(con.execute("PRAGMA table_info(storage_purchases)").fetchall()) == 15:
                print("DB was found(10/12)")
            else:
                con.execute("CREATE TABLE IF NOT EXISTS storage_purchases("
                            "increment INTEGER PRIMARY KEY AUTOINCREMENT,"
                            "user_id INTEGER,"
                            "user_login TEXT,"
                            "user_name TEXT,"
                            "purchase_receipt TEXT,"
                            "purchase_count INTEGER,"
                            "purchase_price INTEGER,"
                            "purchase_price_one INTEGER,"
                            "purchase_position_id INTEGER,"
                            "purchase_position_name TEXT,"
                            "purchase_item TEXT,"
                            "purchase_date TIMESTAMP,"
                            "purchase_unix INTEGER,"
                            "balance_before INTEGER,"
                            "balance_after INTEGER)")
            print("DB was not found(10/12) | Creating...")

            if len(con.execute("PRAGMA table_info(storage_orders)").fetchall()) == 15:
                print("DB was found(11/12)")
            else:
                con.execute("CREATE TABLE IF NOT EXISTS storage_orders("
                            "order_id INTEGER PRIMARY KEY AUTOINCREMENT,"
                            "user_id INTEGER,"
                            "user_login TEXT,"
                            "user_name TEXT,"
                            "order_date TEXT,"
                            "order_state INTEGER,"
                            "order_unix INTEGER,"
                            "phone TEXT,"
                            "address TEXT)")

            print("DB was not found(11/12) | Creating...")

            if len(con.execute("PRAGMA table_info(storage_orders_items)").fetchall()) == 7:
                print("DB was found(12/12)")
            else:
                con.execute("CREATE TABLE IF NOT EXISTS storage_orders_items("
                            "order_item_id INTEGER PRIMARY KEY AUTOINCREMENT,"
                            "order_id INTEGER,"
                            "position_id INTEGER,"
                            "user_name TEXT,"
                            "count INTEGER,"
                            "price INTEGER,"
                            "receipt INTEGER)")

            print("DB was not found(12/12) | Creating...")


        con.commit()


# ================================================================================================================
# ==========                  Новые функции 11.08.22                            ==================================

# возвращает город пользователя и координаты
def get_city_user(user_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select user_city_id from storage_users where user_id = ?'''
    result = cur.execute(query, (user_id,)).fetchone()
    cur.close()
    print(result)
    return result

# возвращает город пользователя и координаты
def get_user_city(user_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select user_city, user_city_id from storage_users where user_id = ?'''
    result = cur.execute(query, (user_id,)).fetchone()
    cur.close()
    print(result)
    return result

# возвращает город пользователя и координаты
def get_parent_cat(category_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select parent_id from cls_categories where category_id = ?'''
    result = cur.execute(query, (category_id,)).fetchone()
    cur.close()
    return result

# возвращает город пользователя и координаты
def get_parent_catc(category_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select parent_id from storage_category where category_id = ?'''
    result = cur.execute(query, (category_id,)).fetchone()
    cur.close()
    return result

# возвращает город пользователя и координаты
def get_city_user3(user_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select user_city, user_geocode, user_city_id from storage_users where user_id = ?'''
    result = cur.execute(query, (user_id,)).fetchone()
    cur.close()
    return result

# возвращает город пользователя и координаты
def get_city_artist(artist_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select city, geocode, city_id from storage_artists where artist_id = ?'''
    result = cur.execute(query, (artist_id,)).fetchone()
    cur.close()
    print(result)
    return result


# возвращает город пользователя и координаты
def get_citytext_user(user_id):
    print('возвращает город пользователя и координаты api_sqlite.py 675')
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select user_city from storage_users where user_id = ?'''
    result = cur.execute(query, (user_id,)).fetchone()
    cur.close()
    return result


# позиции по городу и категории
def get_shops_on_city(city):
    print('позиции по городу и магазину api_sqlite.py 686')
    if city is None or city == 0:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_shop'''
        result = cur.execute(query).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position left join storage_shop on(storage_position.store_id=storage_shop.shop_id) where position_city_id = ?'''
        items = [city]
        result = cur.execute(query, items).fetchall()

    cur.close()
    return result

# позиции по городу и категории
def get_paramposition_on_city(category_id, shop_id, city_id):
    print('позиции по городу и магазину api_sqlite.py 686')
    if city_id is None and shop_id != None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where store_id = ?'''
        result = cur.execute(query, (shop_id,)).fetchall()
        cur.close()
        print("|||VAR 1|||")
        return result
    elif city_id is None and category_id != None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where category_id = ?'''
        result = cur.execute(query, (catgory_id,)).fetchall()
        cur.close()
        print("|||VAR 2|||")
        return result
    elif shop_id is None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where position_city_id = ?'''
        items = [city_id]
        result = cur.execute(query, items).fetchall()
        cur.close()
        print("|||VAR 3|||")
        return result
    elif shop_id != '' and city_id != '':
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where store_id = ? and position_city_id = ?'''
        items = [shop_id, city_id]
        result = cur.execute(query, items).fetchall()
        cur.close()
        print("|||VAR 4|||")
        return result


# позиции по городу и категории
def get_shopposition_on_city(shop_id, city_id):
    print('позиции по городу и магазину api_sqlite.py 686')
    if city_id == 0 or city_id is None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where store_id = ?'''
        result = cur.execute(query, (shop_id,)).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where store_id = ? and position_city_id = ?'''
        items = [shop_id, city_id]
        result = cur.execute(query, items).fetchall()

    cur.close()
    return result

# позиции по городу и категории
def get_position_in_city1(city):
    print('позиции по городу и магазину api_sqlite.py 686')
    if city is None or city == 0:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_shop'''
        result = cur.execute(query).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position left join storage_shop on(storage_position.store_id=storage_shop.shop_id) where position_city_id = ?'''
        items = [city]
        result = cur.execute(query, items).fetchall()

    cur.close()
    return result

def get_cources_in_cityx(category_id, position_city_id, flagallc=1, position_type=1):
    print('Получение позиций api_sqlite.py 1749')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT DISTINCT position_id, position_name FROM storage_position WHERE flagallc=1 OR position_type=1 OR source=? AND category_id=? AND position_city_id=?",
            ["people", category_id, position_city_id],
        ).fetchall()

def get_people_positions_in_cityx(category_id, position_city_id, flagallc=1, position_type=1):
    print('Получение позиций api_sqlite.py 1749')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT DISTINCT position_id, position_name FROM storage_position WHERE flagallc=1 OR position_type=1 OR source=? AND category_id=? AND position_city_id=?",
            ["people", category_id, position_city_id],
        ).fetchall()

def get_positions_in_cityx(category_id, position_city_id, flagallc=1, position_type=1):
    print('Получение позиций api_sqlite.py 1749')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT DISTINCT position_id, position_name, position_city_id FROM storage_position WHERE category_id=? AND position_city_id=?",
            [category_id, position_city_id],
        ).fetchall()
#flagallc=1 OR position_type=1 OR
def get_events_in_cityx(event_city_id, flagallc=1, position_type=1):
    print('Получение позиций api_sqlite.py 1749')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT DISTINCT event_id, event_name FROM storage_events WHERE flagallc=1 OR event_type=1 OR event_city_id=?",
            [event_city_id],
        ).fetchall()


def get_places_in_cityx(place_city_id, flagallc=1, position_type=1):
    print('Получение позиций api_sqlite.py 1749')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        return con.execute(
            "SELECT DISTINCT place_id, name, city_id FROM storage_places WHERE city_id=?",
            [place_city_id],
        ).fetchall()


# Получение всех категорий
def get_all_events():
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_events a LEFT JOIN storage_places b USING(place_id) ORDER BY datetime(event_date) ASC"
        return con.execute(sql).fetchall()

# позиции по городу и категории
def get_position_on_city(category_id, city):
    print('позиции по городу и категории api_sqlite.py 686')
    if city is None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where category_id = ?'''
        result = cur.execute(query, (category_id,)).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_position where category_id = ? and position_city_id = ?'''
        items = [category_id, city]
        result = cur.execute(query, items).fetchall()

    cur.close()
    return result

def get_eventx(event_id):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select distinct c.place_id, c.name
        from storage_places c join storage_events e on c.place_id=e.place_id where event_id = ? order by c.name asc'''
    return cur.execute(query, (event_id,)).fetchall()

# категории в городе
def get_events_in_place(place_id):
    if place_id is None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select distinct * 
            from storage_places c join storage_events p on c.place_id=p.place_id order by c.name asc'''
        return cur.execute(query).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select * from storage_events p where p.place_id = ?'''
        return cur.execute(query, (place_id,)).fetchall()


# категории в городе
def get_events_in_city(city_id):
    if city_id is None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select distinct c.place_id, c.name
            from storage_places c join storage_events p on c.place_id=p.place_id order by c.name asc'''
        return cur.execute(query).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select distinct c.place_id, c.name
            from storage_places c join storage_events p on c.place_id=p.place_id where event_city_id = ? order by c.name asc'''
        return cur.execute(query, (city_id,)).fetchall()

# категории в городе
def get_category_in_city(city_id):
    if city_id is None:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select distinct c.category_id, c.category_name
            from storage_category c join storage_position p on c.category_id=p.category_id order by c.category_name asc'''
        return cur.execute(query).fetchall()
    else:
        conn = sqlite3.connect(PATH_DATABASE)
        cur = conn.cursor()
        query = '''select distinct c.category_id, c.category_name
                from storage_category c join storage_position p on c.category_id=p.category_id where position_city_id = ? order by c.category_name asc'''
        return cur.execute(query, (city_id,)).fetchall()

def get_category_in_citypx(**kwargs):
    print('Получение категорий api_sqlite.py 1816')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT DISTINCT category_id, level, parent_id, category FROM cls_categories"
        sql, parameters = update_format_or_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

def get_curcategory_in_citypx(**kwargs):
    print('Получение категорий курсов api_sqlite.py 2831')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT DISTINCT category_id, level, parent_id, category FROM cls_curcategories"
        sql, parameters = update_format_or_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

def get_category_in_cityx(**kwargs):
    print('Получение категорий api_sqlite.py 1816')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT DISTINCT c.category_id, c.level, c.parent_id, c.category_name FROM storage_category c LEFT JOIN storage_position p ON c.category_id=p.category_id"
        sql, parameters = update_format_or_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

def get_shop_in_cityx(**kwargs):
    print('Получение категорий api_sqlite.py 1833')
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT DISTINCT c.shop_id, c.name FROM storage_shop c LEFT JOIN storage_position p ON c.shop_id=p.store_id"
        sql, parameters = update_format_or_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

# Последние 10 покупок
def get_eventsxx(**kwargs):
    with sqlite3.connect(PATH_DATABASE) as con:
        con.row_factory = dict_factory
        sql = "SELECT * FROM storage_events"
        sql, parameters = update_format_args(sql, kwargs)
        return con.execute(sql, parameters).fetchall()

tgbot >services>api_tron.py:
import time
import pytz
import requests
import json
from async_class import AsyncClass
from tronpy import Tron
from tronpy.keys import PrivateKey
from tgbot.utils.misc_functions import get_or_create_tron_account

class PaymentInfo:
    def __init__(self):
        self.data = [('status', ''), ('details', '')]

    def __repr__(self):
        return str(self.data)

class TronAPI(AsyncClass):
    client = None
    wallet = None
    tron_address = 'TYDpVsaSz2MuXYq4BhL3jgsJo7c1exNgQ9'
    private_key = None
    type_net = None

    async def __ainit__(self): #, user_id, type_net
        self.tron_address="TYDpVsaSz2MuXYq4BhL3jgsJo7c1exNgQ9"
        #self.tron_address = tron_address
        '''self.client = Tron(network='nile')
        self.type_net = type_net
        profile, check = await get_or_create_tron_account(wallet_user=user_id, wallet_net=type_net)
        if check:
            self.tron_address = profile['tron_address']
            self.type_net = profile['type_net']
            self.private_key = profile['private_key']
        else:
            self.tron_address = await self.client.generate_address(priv_key=PrivateKey(
                bytes.fromhex(profile['private_key']))
            )'''
        #print(self.tron_address)

    #@staticmethod
    async def get_address(self):
        #return self.wallet['tron_address']
        return self.tron_address

    # Создание платежа
    async def bill_pay(self, get_amount, get_way, get_coin):
        receipt = str(int(time.time() * 100))

        if get_way == "Tron":
            return_message = f"<b>🆙 Пополнение баланса {get_coin}</b>\n" \
                             f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                             f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                             f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                             f"❗ У вас имеется 30 минут на оплату счета.\n" \
                             f"❗ Адрес: <code> TYDpVsaSz2MuXYq4BhL3jgsJo7c1exNgQ9 </code>.\n" \
                             f"💰 Сумма пополнения: <code>{get_amount} </code>\n" \
                             f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                             f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"


            return return_message, receipt
        return False, False

    def get_balance(self):
        wallet = self.get_address()
        if self.type_net == 'TRX':
            try:
                return self.client.get_account_balance(wallet)
            except tronpy.exceptions.AddressNotFound:
                return 'AccountNotFound'
        elif self.type_net == 'USDT':
            r = requests.get('https://nileapi.tronscan.org/api/account/tokens'
                             f'?address={wallet}'
                             '&start=0'
                             '&limit=20'
                             '&token='
                             '&hidden=0'
                             '&show=0'
                             '&sortType=0')
            if r.status_code == 200:
                for token in r.json()['data']:
                    if token['tokenAbbr'].lower() == 'usdt':
                        print(token)
                        return token['quantity']
                else:
                    return float(0)

    def get_trans_by_wallet(self, type_net):
        #payload = {}
        #req = requests.get("https://api-pub.bitfinex.com/v2/ticker/tTRXUSD")
        #cresponse = requests.get(url, payload)
        #print(cresponse)
        #response = json.loads(cresponse.text)
        #wallet = self.get_address()
        wallet = 'TYDpVsaSz2MuXYq4BhL3jgsJo7c1exNgQ9'
        payload = {}
        if type_net == 'TRX':
            url = f"https://nileapi.tronscan.org/api/transaction?sort=-timestamp&count=true&limit=20&start=0&address={wallet}"
            cresponse = requests.get(url, payload)
            print(cresponse)
            response = json.loads(cresponse.text)
            #if cresponse.status_code == 200:
            return response
            #else:
            #    return {}
        elif type_net == 'USDT':
            url = f"https://nileapi.tronscan.org/api/token_trc20/transfers?sort=-timestamp&count=true&limit=20&start=0&relatedAddress={wallet}"
            cresponse = requests.get(url, payload) #, payload
            #print(cresponse)
            response = json.loads(cresponse.text)
            #if cresponse.status_code == 200:
            return response
            #else:
            #    return {}


    def check_payment(paysum, user_id, local_worker, net, starttime=time.time(), payment=PaymentInfo().data):
        payment[1] = (False, 'WaitPay')
        total = local_worker.get_trans_by_wallet()['total']
        while True:
            if int(time.time()) - starttime >= 1800:
                payment[user_id] = (False, 'timeend')
                return
            trans = local_worker.get_trans_by_wallet()
            if net == 'TRX':
                if trans['total'] == total:
                    time.sleep(10)
                elif trans['data'][0]['toAddress'] == local_worker.get_address():
                    if int(trans['data'][0]['amount']) / 1000000 >= paysum:
                        print('Payment complete!')
                        payment[user_id] = (True, 'allpay')
                        return
                    elif int(trans['data'][0]['amount']) / 1000000 < paysum:
                        paysum_new = paysum - int(trans['data'][0]['amount']) / 1000000
                        payment[user_id] = (False, f'notall:{paysum_new}')
                        time.sleep(1)
                        check_payment(paysum_new, user_id, local_worker, net, starttime=starttime)
                        return
            else:
                if trans['total'] == total:
                    time.sleep(10)
                elif trans['token_transfers'][0]['to_address'] == local_worker.get_address():
                    if int(trans['token_transfers'][0]['quant']) / 1000000 >= paysum:
                        payment[user_id] = (True, 'allpay')
                        return
                    elif int(trans['token_transfers'][0]['quant']) / 1000000 < paysum:
                        paysum_new = paysum - int(trans['token_transfers'][0]['quant']) / 1000000
                        payment[user_id] = (False, f'notall:{paysum_new}')
                        time.sleep(1)
                        check_payment(paysum_new, user_id, local_worker, net, starttime=starttime)
                        return

tgbot >services>api_yoo.py:
# - *- coding: utf- 8 - *-
import asyncio
import json
import time

from aiohttp import ClientConnectorCertificateError
from async_class import AsyncClass
from yoomoney import Client
from yoomoney import Quickpay


from tgbot.services.api_session import RequestsSession
from tgbot.services.api_sqlite import update_paymentx, get_upaymentx, get_paymentx, update_upaymentx
from tgbot.utils.misc_functions import send_admins


# Апи работы с YooMoney
class YooAPI(AsyncClass):
    async def __ainit__(self, suid, acc_number=None, token=None, client_id=None, redirect_url=None, **kwargs):
        print(suid['chat']['id'])
        self.suser_id = 919148970 #suid['chat']['id'] or
        self.token = get_upaymentx(self.suser_id)['yoo_token']
        self.client_id = get_upaymentx(self.suser_id)['yoo_client_id']
        self.acc_number = get_upaymentx(self.suser_id)['yoo_acc_number']
        self.redirect_url = get_upaymentx(self.suser_id)['yoo_redirect_url']

    # Рассылка админам о нерабочем киви
    @staticmethod
    async def error_wallet():
        await send_admins("<b> Yoo кошелёк недоступен ❌</b>\n"
                          "❗ Как можно быстрее его замените ❗")

    #Обновление данных
    async def update_yoo(self):
        update_upaymentx(user_id=self.suser_id, yoo_acc_number=self.acc_number, yoo_token=self.token, yoo_client_id=self.client_id, yoo_redirect_url=self.redirect_url)


    # Обязательная проверка перед каждым запросом
    async def pre_checker(self):
        if self.acc_number != "None":
            if self.add_pass:
                status, response = await self.check_account()
            else:
                status, response, code = await self.check_logpass()
            await asyncio.sleep(0.5)

            if self.add_pass:
                await self.dp.edit_text(response)
                if status:
                    update_upaymentx(user_id=self.suser_id, qiwi_login=self.login, qiwi_token=self.token, qiwi_secret=self.secret)
                else:
                    return False
            elif self.check_pass:
                if status:
                    text_secret = "Отсутствует" if self.secret == "None" else self.secret
                    await self.dp.answer(f"<b>🥝 Qiwi кошелёк полностью функционирует ✅</b>\n"
                                         f"◾ Номер: <code>{self.login}</code>\n"
                                         f"◾ Токен: <code>{self.token}</code>\n"
                                         f"◾ Приватный ключ: <code>{text_secret}</code>")
                else:
                    await self.error_wallet()
                    return False
            elif self.user_bill_pass:
                if not status:
                    await self.dp.edit_text(
                        "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                        "⌛ Попробуйте чуть позже.</b>")
                    await self.error_wallet()
                    return False
            elif self.user_check_pass:
                if not status:
                    await self.dp.answer(
                        "❗ Извиняемся за доставленные неудобства, проверка временно недоступна.\n"
                        "⌛ Попробуйте чуть позже.", True)
                    await self.error_wallet()
                    return False
            elif not status:
                await self.error_wallet()
                return False

            return True
        else:
            if self.user_bill_pass:
                await self.dp.edit_text(
                    "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                    "⌛ Попробуйте чуть позже.</b>")
            await self.error_wallet()
            return False

    # Проверка баланса
    async def get_balance(self):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "funding-sources",
                "v2",
                "accounts",
            )

            save_balance = []
            for balance in response['accounts']:
                if balance['alias'] == "qw_wallet_usd":
                    save_balance.append(f"🇺🇸 Долларов: <code>{balance['balance']['amount']}$</code>")

                if balance['alias'] == "qw_wallet_rub":
                    save_balance.append(f"🇷🇺 Рублей: <code>{balance['balance']['amount']}₽</code>")

                if balance['alias'] == "qw_wallet_eur":
                    save_balance.append(f"🇪🇺 Евро: <code>{balance['balance']['amount']}€</code>")

                if balance['alias'] == "qw_wallet_kzt":
                    save_balance.append(f"🇰🇿 Тенге: <code>{balance['balance']['amount']}₸</code>")

            save_balance = "\n".join(save_balance)
            await self.dp.answer(f"<b>🥝 Баланс кошелька <code>{self.login}</code> составляет:</b>\n"
                                 f"{save_balance}")

    # Проверка п2п ключа
    async def check_secret(self):
        try:
            qiwi_p2p = QiwiP2P(self.secret)
            bill = qiwi_p2p.bill(amount=1, lifetime=1)
            qiwi_p2p.reject(bill_id=bill.bill_id)
            return True
        except Exception:
            return False

    # Создание платежа
    async def bill_pay(self, get_amount, get_way, lang):
        print(self, get_amount, get_way, lang)

        receipt = str(int(time.time() * 100))
        print(receipt)

        if get_way == "ForYm":
            quickpay = Quickpay(
            receiver=self.acc_number, #'410011512189686', 
            quickpay_form="shop",
            targets="Pay for goods in bot",
            paymentType="SB",
            sum=get_amount,
            label=receipt,
            )

            print(quickpay.base_url)

            send_requests = quickpay.base_url

            print(quickpay.redirected_url)

            if lang == "ru":
                return_message = f"<b>🆙 Пополнение баланса Yoomoney</b>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                                 f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                                 f"❗ У вас имеется 30 минут на оплату счета.\n" \
                                 f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"

            if lang == "en":
                return_message = f"<b>🆙 Put money to your account by Yoomoney</b>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🥝 To fill balance, push button beside. \n" \
                                 f"<code>Go to payment</code> and create this one.\n" \
                                 f"❗ You  have 30 minutes for paying operation.\n" \
                                 f"💰 Ammount to pay: <code>{get_amount}₽</code>\n" \
                                 f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                                 f"🔄 After payout, press on <code>Check payment</code>"

            return return_message, send_requests, receipt
        return False, False, False

    # Проверка платежа по форме
    async def check_formy(self, receipt):

        print(self.token)

        client = Client(self.token)
        history = client.operation_history(label=receipt)

        for operation in history.operations:

            pay_status = operation.status  # Получение статуса платежа
            pay_amount = int(float(operation.amount))  # Получение суммы платежа в рублях

        return pay_status, pay_amount

    # Проверка платежа по переводу
    async def check_send(self, receipt):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "payment-history",
                "v2",
                "payments",
                {"rows": 30, "operation": "IN"},
            )

            pay_status = False
            pay_amount = 0

            for check_pay in response['data']:
                if str(receipt) == str(check_pay['comment']):
                    if str(check_pay['sum']['currency']) == "643":
                        pay_status = True
                        pay_amount = int(float(check_pay['sum']['amount']))
                    else:
                        return_message = 1
                    break

            return_message = 3 if pay_status else 2
            return return_message, pay_amount

        return 4, False

    # Запросы
'''    async def _request(self, action, version, get_way, params=None):
        url = self.base_url.format(action, version, self.login, get_way)

        rSession: RequestsSession = self.dp.bot['rSession']
        session = await rSession.get_session()

        try:
            response = await session.get(url, params=params, headers=self.headers, ssl=False)
            return True, json.loads((await response.read()).decode()), response.status
        except ClientConnectorCertificateError:
            return False, None, "CERTIFICATE_VERIFY_FAILED"
        except:
            return False, None, response.status'''

tgbot >services>api_yop2.py:
# - *- coding: utf- 8 - *-
import asyncio
import json
import time

from aiohttp import ClientConnectorCertificateError
from async_class import AsyncClass
from yoomoney import Client
from yoomoney import Quickpay


from tgbot.services.api_session import RequestsSession
from tgbot.services.api_sqlite import update_paymentx, get_upaymentx, get_paymentx, update_upaymentx
from tgbot.utils.misc_functions import send_admins


# Апи работы с YooMoney
class YooAPI(AsyncClass):
    async def __ainit__(self, acc_number=None, token=None, client_id=None, redirect_url=None):
        #suser_id=None,
        '''if suser_id is not None:
            self.suser_id = suser_id
            self.token = get_upaymentx(self.suser_id)['yoo_token']
            self.client_id = get_upaymentx(self.suser_id)['yoo_client_id']
            self.acc_number = get_upaymentx(self.suser_id)['yoo_acc_number']
            self.redirect_url = get_upaymentx(self.suser_id)['yoo_redirect_url']
            #self.token = token
            #self.client_id = client_id
            #self.acc_number = acc_number
            #self.redirect_url = redirect_url
        else:'''
            #self.login = get_upaymentx(self.user_id)['qiwi_login']
            #self.token = get_upaymentx(self.user_id)['qiwi_token']
            #self.secret = get_upaymentx(self.user_id)['qiwi_secret']
            #self.login = get_paymentx()['qiwi_login']
        self.suser_id = 919148970
        self.token = get_upaymentx(self.suser_id)['yoo_token']
        self.client_id = get_upaymentx(self.suser_id)['yoo_client_id']
        self.acc_number = get_upaymentx(self.suser_id)['yoo_acc_number']
        self.redirect_url = get_upaymentx(self.suser_id)['yoo_redirect_url']

        #self.base_url = "https://yoomoney.ru/api/"
        #self.headers = {"authorization": f"Bearer {self.token}"}
        #self.client_id = get_paymentx()['yoo_client_id']
        #self.user_check_pass = user_check_pass
        #self.user_bill_pass = user_bill_pass
        #self.check_pass = check_pass
        #self.add_pass = add_pass
        #self.dp = dp

    # Рассылка админам о нерабочем киви
    @staticmethod
    async def error_wallet():
        await send_admins("<b> Yoo кошелёк недоступен ❌</b>\n"
                          "❗ Как можно быстрее его замените ❗")

    #Обновление данных
    async def update_yoo(self):
        update_upaymentx(user_id=self.suser_id, yoo_acc_number=self.acc_number, yoo_token=self.token, yoo_client_id=self.client_id, yoo_redirect_url=self.redirect_url)


    # Обязательная проверка перед каждым запросом
    async def pre_checker(self):
        if self.acc_number != "None":
            if self.add_pass:
                status, response = await self.check_account()
            else:
                status, response, code = await self.check_logpass()
            await asyncio.sleep(0.5)

            if self.add_pass:
                await self.dp.edit_text(response)
                if status:
                    update_upaymentx(user_id=self.suser_id, qiwi_login=self.login, qiwi_token=self.token, qiwi_secret=self.secret)
                else:
                    return False
            elif self.check_pass:
                if status:
                    text_secret = "Отсутствует" if self.secret == "None" else self.secret
                    await self.dp.answer(f"<b>🥝 Qiwi кошелёк полностью функционирует ✅</b>\n"
                                         f"◾ Номер: <code>{self.login}</code>\n"
                                         f"◾ Токен: <code>{self.token}</code>\n"
                                         f"◾ Приватный ключ: <code>{text_secret}</code>")
                else:
                    await self.error_wallet()
                    return False
            elif self.user_bill_pass:
                if not status:
                    await self.dp.edit_text(
                        "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                        "⌛ Попробуйте чуть позже.</b>")
                    await self.error_wallet()
                    return False
            elif self.user_check_pass:
                if not status:
                    await self.dp.answer(
                        "❗ Извиняемся за доставленные неудобства, проверка временно недоступна.\n"
                        "⌛ Попробуйте чуть позже.", True)
                    await self.error_wallet()
                    return False
            elif not status:
                await self.error_wallet()
                return False

            return True
        else:
            if self.user_bill_pass:
                await self.dp.edit_text(
                    "<b>❗ Извиняемся за доставленные неудобства, пополнение временно недоступно.\n"
                    "⌛ Попробуйте чуть позже.</b>")
            await self.error_wallet()
            return False

    # Проверка баланса
    async def get_balance(self):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "funding-sources",
                "v2",
                "accounts",
            )

            save_balance = []
            for balance in response['accounts']:
                if balance['alias'] == "qw_wallet_usd":
                    save_balance.append(f"🇺🇸 Долларов: <code>{balance['balance']['amount']}$</code>")

                if balance['alias'] == "qw_wallet_rub":
                    save_balance.append(f"🇷🇺 Рублей: <code>{balance['balance']['amount']}₽</code>")

                if balance['alias'] == "qw_wallet_eur":
                    save_balance.append(f"🇪🇺 Евро: <code>{balance['balance']['amount']}€</code>")

                if balance['alias'] == "qw_wallet_kzt":
                    save_balance.append(f"🇰🇿 Тенге: <code>{balance['balance']['amount']}₸</code>")

            save_balance = "\n".join(save_balance)
            await self.dp.answer(f"<b>🥝 Баланс кошелька <code>{self.login}</code> составляет:</b>\n"
                                 f"{save_balance}")

    # Проверка п2п ключа
    async def check_secret(self):
        try:
            qiwi_p2p = QiwiP2P(self.secret)
            bill = qiwi_p2p.bill(amount=1, lifetime=1)
            qiwi_p2p.reject(bill_id=bill.bill_id)
            return True
        except Exception:
            return False

    # Создание платежа
    async def bill_pay(self, get_amount, get_way):
        #print(self, get_amount, get_way)

        receipt = str(int(time.time() * 100))
        print(receipt)

        if get_way == "ForYm":
            quickpay = Quickpay(
            receiver=self.acc_number, #'410011512189686', 
            quickpay_form="shop",
            targets="Pay for goods in bot",
            paymentType="SB",
            sum=get_amount,
            label=receipt,
            )

            print(quickpay.base_url)

            send_requests = quickpay.base_url

            print(quickpay.redirected_url)

            return_message = f"<b>🆙 Пополнение баланса Yoomoney</b>\n" \
                             f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                             f"🥝 Для пополнения баланса, нажмите на кнопку ниже \n" \
                             f"<code>Перейти к оплате</code> и оплатите выставленный вам счёт\n" \
                             f"❗ У вас имеется 30 минут на оплату счета.\n" \
                             f"💰 Сумма пополнения: <code>{get_amount}₽</code>\n" \
                             f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                             f"🔄 После оплаты, нажмите на <code>Проверить оплату</code>"

            return return_message, send_requests, receipt
        return False, False, False

    # Проверка платежа по форме
    async def check_formy(self, receipt):

        print(self.token)

        client = Client(self.token)
        history = client.operation_history(label=receipt)

        for operation in history.operations:

            pay_status = operation.status  # Получение статуса платежа
            pay_amount = int(float(operation.amount))  # Получение суммы платежа в рублях

        return pay_status, pay_amount

    # Проверка платежа по переводу
    async def check_send(self, receipt):
        response = await self.pre_checker()
        if response:
            status, response, code = await self._request(
                "payment-history",
                "v2",
                "payments",
                {"rows": 30, "operation": "IN"},
            )

            pay_status = False
            pay_amount = 0

            for check_pay in response['data']:
                if str(receipt) == str(check_pay['comment']):
                    if str(check_pay['sum']['currency']) == "643":
                        pay_status = True
                        pay_amount = int(float(check_pay['sum']['amount']))
                    else:
                        return_message = 1
                    break

            return_message = 3 if pay_status else 2
            return return_message, pay_amount

        return 4, False

    # Запросы
'''    async def _request(self, action, version, get_way, params=None):
        url = self.base_url.format(action, version, self.login, get_way)

        rSession: RequestsSession = self.dp.bot['rSession']
        session = await rSession.get_session()

        try:
            response = await session.get(url, params=params, headers=self.headers, ssl=False)
            return True, json.loads((await response.read()).decode()), response.status
        except ClientConnectorCertificateError:
            return False, None, "CERTIFICATE_VERIFY_FAILED"
        except:
            return False, None, response.status'''

tgbot >services>dbconnect.py:

tgbot >services>lang_function.py:
import sqlite3


from tgbot.data.config import PATH_DATABASE

# проверка записи локации
def is_lang(user_id):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select user_lang from storage_users where user_id = ?'''
    result = cur.execute(query, (user_id,)).fetchone()
    return result[0] is not None
tgbot >services>location_function.py:
import sqlite3

from geopy.geocoders import Nominatim
from tgbot.data.config import PATH_DATABASE


# проверка записи локации
def is_location(user_id):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = '''select user_city from storage_users where user_id = ?'''
    result = cur.execute(query, (user_id,)).fetchone()
    return result[0] is not None

# Nominatim geo 2 address
def search_address(lat, long):
    geolocator = Nominatim(user_agent="TGGoodsinbot")
    location = geolocator.reverse(f'{lat}, {long}')
    return location.address

def add_address(address, user_id):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = 'update storage_users set user_address = ? where user_id = ?'
    #row = f'{lat}, {long}'
    items = [address, user_id]
    cur.execute(query, items)
    conn.commit()


# поиск города в радиусе 0.5' вокруг пользователя
def search_city(lat, long):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    lat_min = lat - 0.5
    lat_max = lat + 0.5
    long_min = long - 0.5
    long_max = long + 0.5
    query = '''select city, id FROM data_cities where co_1 > ? and co_1 < ? and  co_2 > ? and co_2 < ?'''
    items = [lat_min, lat_max, long_min, long_max]
    cur.execute(query, items)
    result = cur.fetchone()
    conn.commit()
    return False if result is None else result

# добавляет геокод в бд
def add_geocode(lat, long, user_id):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = 'update storage_users set user_geocode = ? where user_id = ?'
    row = f'{lat}, {long}'
    items = [row, user_id]
    cur.execute(query, items)
    conn.commit()

# добавляет город в бд
def add_city(city_id, city_name, user_id):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = 'update storage_users set user_city_id = ?, user_city = ? where user_id = ?'
    items = [city_id, city_name, user_id]
    cur.execute(query, items)
    conn.commit()

# город по айди и записывет координаты города в профиль пользователя
def get_city(city_id, user_id):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = 'select city, co_1, co_2, id from data_cities where id = ?'
    result = cur.execute(query, (city_id,)).fetchone()
    conn.commit()
    #conn2 = sqlite3.connect(PATH_DATABASE)
    cur2 = conn.cursor()
    row = f'{result[1]}, {result[2]}'
    items = [row, user_id]
    print(items)
    query = 'update storage_users set user_geocode = ? where user_id = ?'
    cur2.execute(query, items)
    conn.commit()
    return result

def set_geocode(user_id, geocode):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    row = f'{result[1]}, {result[2]}'
    items = [row, user_id]
    print(items)
    query = 'update storage_users set user_geocode = ? where user_id = ?'
    cur.execute(query, items)
    conn.commit()


# ==============================================================================================================
# =========================  функции для локации позиции (магазина)   =========================================

# добавляет город в позиции
def update_position_city(city, city_id, user_id):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = 'update storage_position set position_city = ?, position_city_id = ? where position_id = ?'
    items = [city, city_id, user_id]
    cur.execute(query, items)
    conn.commit()

# добавляет город в позиции
def update_artist_city(city, city_id, artist_id):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = 'update storage_artists set city = ?, city_id = ? where artist_id = ?'
    items = [city, city_id, artist_id]
    cur.execute(query, items)
    conn.commit()


# город по айди
def get_city_info(id):
    conn = sqlite3.connect(PATH_DATABASE)
    cur = conn.cursor()
    query = 'select city, co_1, co_2  from data_cities where id = ?'
    return cur.execute(query, (id,)).fetchone()


# город пользователя по айди
# def get_user_city(user_id):
#     conn = sqlite3.connect(PATH_DATABASE)
#     cur = conn.cursor()
#     query = '''select user_city from storage_users where user_id = ?'''
#     result = cur.execute(query, (user_id,)).fetchone()

tgbot >services>location_stat.py:
from aiogram.dispatcher.filters.state import State, StatesGroup


class geo_choice(StatesGroup):
    location= State()
tgbot >services>mes.py:
import asyncio

from aiogram import Bot, types

#API_TOKEN = '5361635126:AAF9sQ8__qoITGGlUVBhsev-nz15NJj_QN0'
API_TOKEN = '5337905343:AAFnZEexDdOAhn16AEw1zofEzVrPPEag89Q'
CHANNEL_ID = -1001683374540
#CHANNEL_ID = 5337905343

bot = Bot(token=API_TOKEN, parse_mode=types.ParseMode.HTML)

async def send_message(channel_id: int, text: str):
    await bot.send_message(channel_id, text)


async def main():
    await send_message(CHANNEL_ID, '<b>Hello!</b>')


if __name__ == '__main__':
    asyncio.run(main())

tgbot >services>model_events.py:
from sqlalchemy import Column
from sqlalchemy import ForeignKey
from sqlalchemy import Integer
from sqlalchemy import String
from sqlalchemy.orm import declarative_base
from sqlalchemy.orm import relationship

Base = declarative_base()

class User(Base):
    __tablename__ = "user_account"

    id = Column(Integer, primary_key=True)
    name = Column(String(30))
    fullname = Column(String)

    addresses = relationship(
        "Address", back_populates="user", cascade="all, delete-orphan"
    )

    def __repr__(self):
        return f"User(id={self.id!r}, name={self.name!r}, fullname={self.fullname!r})"



class Artist(Base):
    __tablename__ = "storage_artists"

    increment = Column(Integer, primary_key=True)
    artist_id = Column(Integer)
    name = Column(String(50))
    description = Column(String)
    webaddress = Column(String)
    admin = Column(Integer)
    logo = Column(String)
    paymdir = Column(String)
    city = Column(String)
    geocode = Column(String)
    city_id = Column(Integer)

    addresses = relationship(
        "Address", back_populates="user", cascade="all, delete-orphan"
    )

    def __repr__(self):
        return f"Artist(id={self.id!r}, name={self.name!r}, admin={self.admin!r})"

class Address(Base):
    __tablename__ = "address"

    id = Column(Integer, primary_key=True)
    email_address = Column(String, nullable=False)
    user_id = Column(Integer, ForeignKey("user_account.id"), nullable=False)

    user = relationship("User", back_populates="addresses")

    def __repr__(self):
        return f"Address(id={self.id!r}, email_address={self.email_address!r})"

tgbot >services>regular.py:
# - *- coding: utf- 8 - *-
import asyncio
import os
from datetime import datetime
#import requests

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from aiogram import Bot, types


from tgbot.utils.misc_functions import get_position_of_day

#API_TOKEN = '5402212470:AAGFv7hY2bYGeaCOi_77cZJlOd31crtXK9k'
#API_TOKEN = '5502549363:AAH2d3qoCiA8pQ8EDpT4CZ9rxD55eh2lmHo'
#API_TOKEN = '5328800059:AAEv2GffGt2jJREnStKPYxkUdR1rqJ6-YuQ'
API_TOKEN = '5337905343:AAFnZEexDdOAhn16AEw1zofEzVrPPEag89Q'
#API_TOKEN = '5337905343:AAFnZEexDdOAhn16AEw1zofEzVrPPEag89Q'
CHANNEL_ID = -1001683374540
#CHANNEL_ID = 5328800059
#CHANNEL_ID =  5337905343
#CHANNEL_ID = 5402212470

bot = Bot(token=API_TOKEN, parse_mode=types.ParseMode.HTML)

def tick():
    print(f'Tick! The time is: {datetime.now()}')
#get_message, get_image = get_position_of_day()


def send_photo_telegram(file_id):
    files = {'photo': open({file_id}, 'rb')}
    token = "5337905343:AAFnZEexDdOAhn16AEw1zofEzVrPPEag89Q"
    chat_id = "-1001683374540" # если у вас группа то будет так chat_id = "-1009999999"
    r = requests.post(
        f"https://api.telegram.org/bot{token}/sendPhoto?chat_id={chat_id}",
        files=files,
    )
    if r.status_code != 200:
        raise Exception("post_text error")


async def send_message_start():
    position, image = get_position_of_day()
    #await send_message(CHANNEL_ID, '<b>tttt</b>')
    #get_position = get_positionx(position_id=4875164059)
    print(image)
    #await send_photo_telegram(image)
    #await send_photo(CHANNEL_ID, photo='file_id_' + image)
    await send_photo(CHANNEL_ID, photo=image, caption=position)
    #await send_message(CHANNEL_ID, position)
    #await send_photo(chat_id=CHANNEL_ID, photo=image, caption=position, parse_mode=ParseMode.MARKDOWN)
    #if len(image) >= 5:
    #    photo = types.InputMediaPhoto(image)
    #    await send_photo(CHANNEL_ID, photo, position)
    #else:
        

    #await send_message(CHANNEL_ID, position)
    #await send_message(CHANNEL_ID, '<div> ||| </div>')


async def send_message(channel_id: int, text: str):
    await bot.send_message(channel_id, text)

if __name__ == '__main__':
    scheduler = AsyncIOScheduler()
    scheduler.add_job(tick, 'interval', seconds=3)
    scheduler.add_job(send_message_start, 'interval', seconds=5)
    #scheduler.add_job(send_message_start, 'interval', next_run_time=datetime.now())
    
    scheduler.start()
    print('Press Ctrl+{0} to exit'.format('Break' if os.name == 'nt' else 'C'))
    # Execution will block here until Ctrl+C (Ctrl+Break on Windows) is pressed.
    try:
        asyncio.get_event_loop().run_forever()
    except (KeyboardInterrupt, SystemExit):
        pass
tgbot >services>tick.py:
# - *- coding: utf- 8 - *-
import asyncio
import os
from datetime import datetime

from apscheduler.schedulers.asyncio import AsyncIOScheduler

def tick():
    print(f'Tick! The time is: {datetime.now()}')

if __name__ == '__main__':
    scheduler = AsyncIOScheduler()
    scheduler.add_job(tick, 'interval', seconds=3)
    scheduler.start()
    print('Press Ctrl+{0} to exit'.format('Break' if os.name == 'nt' else 'C'))
    # Execution will block here until Ctrl+C (Ctrl+Break on Windows) is pressed.
    try:
        asyncio.get_event_loop().run_forever()
    except (KeyboardInterrupt, SystemExit):
        pass
tgbot >utilis
__init__.py:

tgbot >utilis>const_functions.py:
# - *- coding: utf- 8 - *-
import time
from datetime import datetime


# Очистка текста от HTML тэгов
def clear_html(get_text):
    if "<" in get_text: get_text = get_text.replace("<", "*")
    if ">" in get_text: get_text = get_text.replace(">", "*")

    return get_text


# Получение текущего unix времени
def get_unix():
    return int(time.time())


# Получение текущей даты
def get_date():
    this_date = datetime.now().replace(microsecond=0)
    this_date = this_date.strftime("%d.%m.%Y %H:%M:%S")

    return this_date


# Разбив списка по количеству переданных значений
def split_messages(get_list, count):
    return [get_list[i:i + count] for i in range(0, len(get_list), count)]


# Очистка мусорных символов из списка
def clear_list(get_list: list):
    while "" in get_list:
        get_list.remove("")

    while " " in get_list:
        get_list.remove(" ")

    while "," in get_list:
        get_list.remove(",")

    while "\r" in get_list:
        get_list.remove("\r")

    return get_list


# Удаление отступов у текста
def ded(get_text: str):
    if get_text is not None:
        split_text = get_text.split("\n")
        if split_text[0] == "": split_text.pop(0)
        if split_text[-1] == "": split_text.pop(-1)
        save_text = []

        for text in split_text:
            while text.startswith(" "):
                text = text[1:]

            save_text.append(text)
        get_text = "\n".join(save_text)

    return get_text



# Конвертация дней
def convert_day(day):
    day = int(day)
    days = ['день', 'дня', 'дней']

    if day % 10 == 1 and day % 100 != 11:
        count = 0
    elif 2 <= day % 10 <= 4 and (day % 100 < 10 or day % 100 >= 20):
        count = 1
    else:
        count = 2

    return f"{day} {days[count]}"

tgbot >utilis>misc_functions.py:
# - *- coding: utf- 8 - *-
import asyncio
import aiohttp
import json
import random
from datetime import datetime, timedelta
import time

import sys
import hashlib
import base58

import requests
import subprocess

import aiogram
from aiogram import Dispatcher
from aiogram import executor, exceptions
from aiogram import Bot, types
#from aiogram.types import Message
#from aiogram.utils import exceptions, executor
#from aiogram.methods import SendMessage, SendPhoto, SendVideo, SendAnimation
import tronpy
from aiogram.utils.deep_linking import get_start_link, decode_payload
from bs4 import BeautifulSoup
from babel import Locale
from tgbot.data.config import get_admins, BOT_DESCRIPTION, I18N_DOMAIN, LOCALES_DIR
#from tgbot.middlewares.i18n import I18nMiddleware
#from aiogram.contrib.middlewares.i18n import I18nMiddleware
from tgbot.middlewares.i18n import I18nMiddleware
#from tgbot.data.config import get_admins, BOT_VERSION, BOT_DESCRIPTION
from tgbot.keyboards.reply_z_all import menu_frep
from tgbot.services.api_session import AsyncSession
from tgbot.loader import bot
from tgbot.services.api_sqlite import get_settingsx, update_settingsx, get_userx, get_all_positionsx, \
    update_positionx, get_all_categoriesx, get_all_purchasesx, get_all_refillx, get_all_usersx, get_all_itemsx, \
    get_itemsx, get_positionx, get_categoryx, get_all_positionsidx, get_requestx, get_user_orderx, get_cart_positionsx, \
    get_orderx, get_purchasesx, get_purchasesxx, get_shopx, get_artistx, get_planed_postx, get_planed_eventsx, get_tohour_postx,\
    update_tohour_postx, get_users_by_cities, get_users_by_citiesx, get_delivery_seller_options, get_params_orderx, get_orderxo, \
    get_userxxx, get_upaymentx, get_userxx, get_userxn, get_user_lang, add_refillx

from tgbot.utils.const_functions import get_unix, convert_day, get_date, ded

#bot = Bot(token=BOT_TOKEN, parse_mode=types.ParseMode.HTML)
i18n = I18nMiddleware(I18N_DOMAIN, LOCALES_DIR)

print(i18n)
_ = i18n.gettext



async def fetch_token(user_login, password):
    async with aiohttp.ClientSession() as session:
        url = f"http://46.23.98.123:8081/login?login={user_login}&password={password}"

        async with session.get(url) as resp:
            token = await resp.text()

            #return token
    #await send_user(919148970, msg, markup="default")


# Уведомление и проверка обновления при запуске бота
async def on_startup_notify(dp: Dispatcher):
    if len(get_admins()) >= 1:
        await send_admins(f"<b>✅ Бот был успешно запущен</b>\n"
                          f"➖➖➖➖➖➖➖➖➖➖\n"
                          f"{BOT_DESCRIPTION}\n"
                          f"➖➖➖➖➖➖➖➖➖➖\n"
                          f"<code>❗ Данное сообщение видят только администраторы бота.</code>",
                          markup="default")
        await check_update()

#уведомление пользователю
async def user_notify(dp: Dispatcher, user_id, msg):
    print(f'Уведомление для пользователя!' + msg)
    await send_user(user_id, msg, markup="default")

# Рассылка сообщения пользователю
async def send_user(user_id, message, markup=None):
    try:
        await bot.send_message(user_id, message, reply_markup=markup, disable_web_page_preview=True)
    except Exception:
        pass


# Рассылка сообщения всем администраторам
async def send_admins(message, markup=None, not_me=0):
    for admin in get_admins():
        if markup == "default":
            lang=get_userx(user_id=admin)['user_lang']
            if lang is None:
                lang = "ru"
            print(lang)
            markup = menu_frep(admin, lang)

        try:
            if str(admin) != str(not_me):
                await bot.send_message(admin, message, reply_markup=markup, disable_web_page_preview=True)
        except Exception:
            pass

# Автоматическая очистка ежедневной статистики после 00:00
async def update_profit_day():
    await send_admins(get_statisctics())
    update_settingsx(misc_profit_day=get_unix())

# Автоматическая очистка еженедельной статистики в понедельник 00:01
async def update_profit_week():
    update_settingsx(misc_profit_week=get_unix())


def catch_transactions(address):
    print("start to catch transactions")
    address = 'TQanL97TYygHiycDZ1up8XNqt1mHcGJ4Nv'
    start_time = datetime.now()
    end_time = start_time + timedelta(minutes=20)
    while datetime.now() < end_time:
        x=+1
        print("minutes in catching" + x)
        transactions = tron.get_account_transactions(address)
        confirmed_transactions = [tx for tx in transactions if tx.get('ret', [{}])[0].get('contractRet') == 'SUCCESS']
        # Your code here
        print(confirmed_transactions)
        asyncio.sleep(60)


async def catch_transactions20m(address_from, address_to):
    print("start to catch transactions")
    start_time = datetime.now()
    end_time = start_time + timedelta(minutes=20)
    print(start_time, end_time)
    st = get_unix()
    am = ""
    #while datetime.now() < end_time:
    while True:
        #print(end_time)
        #send_user(dp, user_id, "Ожидаем транзакцию")
        await check_trx_now(address_from, st, address_to)
        await asyncio.sleep(60)
        #return am
        #print(am)
        #if trx_amount:
        #    return trx_amount

async def check_btc_now(address_from, st, address_to):
    print("BTC_NOW!!!")
    #address_to = 'TQanL97TYygHiycDZ1up8XNqt1mHcGJ4Nv'
    #url = f"https://api.trongrid.io/v1/accounts/{address_to}/transactions/trc20"
    url = f'https://api.bscscan.com/api?module=account&action=tokentx&address={address_to}&page=1&offset=5&startblock=0&endblock=999999999&sort=asc&apikey=MRGP3KDXP7K9BP8Q4E3I2Y1FYVMAE961VV'
    #url = f'https://blockchain.info/rawaddr/{address_to}'
    #url = f"https://api.trongrid.io/v1/accounts/{address_to}/transactions" #?only_confirmed=true&only_to=true"
    response = requests.get(url) #, headers={"TRON-PRO-API-KEY": "5c4c149e-83d1-4926-8d73-78dac1ab2d38"})
    #url = f"https://api.trongrid.io/v1/accounts/{address_to}/transactions"
    #headers = {"accept": "application/json"}
    #transactions = requests.get(url, headers=headers)
    #get_user = get_userx(user_id)
    #transactions2 = json.loads(transactions)
    json_data = json.loads(response.text)
    try:
        txs = json_data['result']
        for transaction in txs:
            st = st
            bts = int(transaction['timeStamp'])
            dts = bts - st
            print(f"Transaction Hash: {transaction['blockHash']}")
            print(f"Transaction Value: {transaction['value']}")
            #amount = float(transaction['value'])*0.000000000000000001
            amount = float(transaction['value'])
            if transaction["from"] == address_from and transaction["to"] == address_to: # and dts < 0:
                #print(st, bts, dts)
                return float(amount), bts
            else:
                print(st, bts, dts, transaction['timeStamp'], transaction['value'])
                return float(amount), bts

    except json.JSONDecodeError:
        print("Empty response")


async def check_trx_address(address):
    print("CHECK_TRX_NOW!!!")
    #address_to = 'TQanL97TYygHiycDZ1up8XNqt1mHcGJ4Nv'
    url = f"https://api.trongrid.io/wallet/validateaddress"
    #url = f"https://api.trongrid.io/v1/accounts/{address_to}/transactions" #?only_confirmed=true&only_to=true"
    req = requests.get(url, headers={"TRON-PRO-API-KEY": "5c4c149e-83d1-4926-8d73-78dac1ab2d38"})
    #url = f"https://api.trongrid.io/v1/accounts/{address_to}/transactions"
    #headers = {"accept": "application/json"}
    #transactions = requests.get(url, headers=headers)
    #get_user = get_userx(user_id)
    result = json.loads(req.text)


async def check_trx_now(address_from, st, address_to):
    print("TRX_NOW!!!")
    #address_to = 'TQanL97TYygHiycDZ1up8XNqt1mHcGJ4Nv'
    url = f"https://api.trongrid.io/v1/accounts/{address_to}/transactions/trc20"
    #url = f"https://api.trongrid.io/v1/accounts/{address_to}/transactions" #?only_confirmed=true&only_to=true"
    transactions = requests.get(url, headers={"TRON-PRO-API-KEY": "5c4c149e-83d1-4926-8d73-78dac1ab2d38"})
    #url = f"https://api.trongrid.io/v1/accounts/{address_to}/transactions"
    #headers = {"accept": "application/json"}
    #transactions = requests.get(url, headers=headers)
    #get_user = get_userx(user_id)
    transactions2 = json.loads(transactions.text)
    amount = 0
    total = 0
    for transaction in transactions2['data']:
        #print(transaction)
        amount = transaction['value']
        #total += int(amount)
        st = st
        #bts = int(str(transaction['block_timestamp'])[:10])
        bts = int(transaction['block_timestamp']/1000)
        dts = bts - st
        if transaction["from"] == address_from and transaction["to"] == address_to: # and dts < 0:
            #print(st, bts, dts)
            return int(amount), bts
        else:
            print(st, bts, dts, transaction['transaction_id'], transaction['value']) #st, bts, dts,

        '''blockTS = transaction['block_timestamp']
        td = st - blockTS
        state = transaction['ret'][0]['contractRet']
        if "amount" in transaction['raw_data']['contract'][0]['parameter']['value']:
            amount = transaction['raw_data']['contract'][0]['parameter']['value']['amount']
            total += amount
            #if transaction["raw_data"]["contract"][0]["parameter"]["value"]["to_address"] == address_to: print("Адресат наш")
            #if transaction["raw_data"]["contract"][0]["parameter"]["value"]["owner_address"] == address_from: print("Отправитель наш")
            #add_refillx(get_user['user_id'], get_user['user_login'], get_user['user_name'], receipt,
            #            amount, receipt, get_way, get_date(), get_unix())
            if transaction["raw_data"]["contract"][0]["parameter"]["value"]["to_address"] == address_to and transaction["raw_data"]["contract"][0]["parameter"]["value"]["owner_address"] == address_from: # and td > 0
                print("ПОПОЛНЯЕМ АККАУНТ НА:" + str(amount))
                return amount #, state, blockTS
            print(blockTS, td, amount, state, total)'''
    return 0, bts

async def post_every_eighteen():
    print("||||")
    posts = get_planed_postx(mode="evening")
    #print(posts)
    for post in posts:
        asyncio.create_task(functions_advertising_make_bg(post))

async def post_evening_events():
    print("||||)")
    events = get_planed_eventsx()
    for event in events:
         asyncio.create_task(functions_advertising_events_bg(event))

async def post_half_eight():
    print("||||_")
    posts = get_planed_postx(mode_evening="evening")
    print(posts)
    for post in posts:
         asyncio.create_task(functions_advertising_make_bg(post))
         #time.sleep(60)

async def reinvite_sellers_by_city():
    print("*CITIES CITIZENS MESSAGING*")
    cities = get_users_by_cities()
    posttype = "photo"
    #get_users = get_userxx(user_city_id=34)
    #print(get_users)
    #posttype = "photo"
    #message = "(((999)))"
    test = "no"

    for city in cities:
        print(city)
        if city['user_city_id'] is None:
            #message = "Выберите пожалуйста Ваш город в боте."
            message = f"Выберите пожалуйста Ваш город в боте.\n" \
                      f"Мы сможем предложить Вам товары \n" \
                      f"от продавцов в Вашем городе."
            message = f"Выберите пожалуйста Ваш город в боте.\n" \
                      f"Мы поздравляем Вас с праздником защиткика Отечества!\n" \
                      f"Хорошего дня!."
            get_users = get_userxn()
            print(get_users)
            print(message)
        elif city['user_city_id'] != 0:
            message = str(city['user_city']) + ", привет. Я Telegram Goods In Bot из Telegram."
            #'Продавайте товары в своем городе или по всей России!'
            print(message)
            cityr = city['user_city_id']
            #get_users = get_all_usersx()
            #if cityr is not None:
            print(cityr)
            get_users = get_userxx(user_city_id=cityr)

        #test = "yes"
        #get_users = get_userxx(user_city_id=int(cityr))
        #get_users = get_all_usersxx()
        receive_users, block_users, how_users = 0, 0, 0
        for user in get_users:
            #print(user)
            if user['user_city_id'] is None: photo = "img/gbmes.png"
            else:
                photo = f"img/msg0002{user['user_city_id']}.png"
                print(photo)
            #photo = "img/msg34.png"
            #image = InputFile(f"img/msg{city['user_city_id']}.png")
            image = open(photo, 'rb')
            #message = str(user['user_city']) + ", продавцы товаров, добро пожаловать!"
            #elif user['user_city_id']:
            #    message = "Выберите пожалуйста свой город в профиле, наш бот Вам предложит товары в Вашем городе."
            try:
                if test == "yes": user['user_id'] = 919148970
                if posttype == "text":
                    await bot.send_message(user['user_id'], message, disable_web_page_preview=True)
                elif posttype == "photo":
                    await bot.send_photo(
                        chat_id=user['user_id'],
                        photo=image,
                        caption=message) #post[9] if post[9] else None)
                elif post[1] == "video":
                    await bot.send_video(
                        chat_id=user['user_id'],
                        video=post[5],
                        caption=post[9] or None,
                    )
                elif post[1] == "animation":
                    await bot.send_animation(
                        chat_id=user['user_id'],
                        animation=message,
                        caption=post[9] or None,
                    )

                receive_users += 1

            except Exception:
                block_users += 1

            how_users += 1

            if how_users % 10 == 0:
                await send_admins(f"<b>📢 Рассылка началась... ({how_users}/{len(get_users)})</b>")

            await asyncio.sleep(0.05)

        #await update_post(post[0], state = "sended")
        await send_admins(
            f"<b>📢 Рассылка была завершена ✅</b>\n"
            f"👤 Пользователей получило сообщение: <code>{receive_users} ✅</code>\n"
            f"👤 Пользователей не получило сообщение: <code>{block_users} ❌</code>"
        )

async def post_every_half_hour():
    print("||||")
    posts = get_planed_postx(mode="halfhour")
    #print(posts)
    for post in posts:
         asyncio.create_task(functions_advertising_make_bg(post))
         #time.sleep(60)

async def sellers_news():
    print("||||")
    posts = get_sellers_news_postx(tag = "selnews")
    #updposts = update_tohour_postx()
    #print(posts)
    for post in posts:
        asyncio.create_task(functions_advertising_make_bg(post))

async def posts3_every_hour():
    print("||||")
    posts = get_3tohour_postx()
    #updposts = update_tohour_postx()
    #print(posts)
    for post in posts:
        asyncio.create_task(functions_advertising_make_bg(post))

async def post_every_hour():
    print("||||")
    posts = get_tohour_postx()
    updposts = update_tohour_postx()
    #print(posts)
    for post in posts:
         asyncio.create_task(functions_advertising_make_bg(post))

async def get_or_create_tron_account(wallet_user, wallet_net):
# Получение платежных реквизитов продавца
    tron_profile =  get_tron_profile(wallet_user, wallet_net)
    #print(get_tron_profile['tron_wallet'], get_tron_profile['private_key'], get_tron_profile['type_net'])
    if len(tron_profile['tron_wallet']) > 1:
        check = True
        return tron_profile, check
    else:
        check = False
        return tron_profile, check

async def functions_advertising_make_bg(post, markup=None):
    receive_users, block_users, how_users = 0, 0, 0
    get_users = get_all_usersx()
    #get_users = get_userx(user_id=919148970)
    test = "no"
    #print(get_usersx)
    print(post)
    #dt_create = datetime.datetime.strptime(post[7], '%Y-%m-%d %H:%M:%S')
    #utime = time.mktime(cur_time.timetuple())
    #print(utime)
    #dtpost_create = time.mktime(dt_create.timetuple())
    #print(dtpost_create)

    if markup == "default":
        markup = menu_frep(admin)
    #get_users = "919148970"

    for user in get_users:
        try:
            if test == "yes": user['user_id'] = 919148970
            if post[1] == "text":
                await bot.send_message(user['user_id'], post[3], disable_web_page_preview=True)
                #await bot.send_message(user['user_id'], post[2], reply_markup = markup, disable_web_page_preview=True)
            elif post[1] == "photo":
                await bot.send_photo(
                    chat_id=user['user_id'],
                    photo=post[4],
                    caption=post[13] or None,
                )
            elif post[1] == "video":
                #print("|_>>>>")
                await bot.send_video(
                    chat_id=user['user_id'],
                    video=post[5],
                    caption=post[9] or None,
                )
            elif post[1] == "animation":
                #print("|_>>>>>")
                await bot.send_animation(
                    chat_id=user['user_id'],
                    animation=message,
                    caption=post[9] or None,
                )

            receive_users += 1
        except Exception:
            block_users += 1

        how_users += 1

        if how_users % 10 == 0:
            await send_admins(f"<b>📢 Рассылка началась... ({how_users}/{len(get_users)})</b>")

        await asyncio.sleep(0.05)

    await update_post(post[0], state = "sended")
    await send_admins(
        f"<b>📢 Рассылка была завершена ✅</b>\n"
        f"👤 Пользователей получило сообщение: <code>{receive_users} ✅</code>\n"
        f"👤 Пользователей не получило сообщение: <code>{block_users} ❌</code>"
    )


async def functions_advertising_events_bg(event, markup=None):
    receive_users, block_users, how_users = 0, 0, 0
    get_users = get_all_usersx()
    #print(":::")
    #get_users = get_userxx(user_city_id = post[10])
    #get_users = get_userx(user_id=919148970)
    test = "no"
    #print(get_usersx)
    print(event)

    if markup == "default":
        markup = menu_frep(admin)
        #get_users = "919148970"

    '''ev_command = event[1] if event[1] else None
    ev_desc = event[2] if event[2] else None
    ev_place = event[3] if event[3] else None
    ev_address = event[4] if event[4] else None

    caption = f" Коллектив: {ev_command}  \n"
    f"<b>🔶 Описание: 🔶</b> {ev_desc} \n"\
    f"<b>🔶 Место: 🔶</b> {ev_place} \n"\
    f"<b>🔶 Адресс: 🔶</b> {ev_address} \n"'''

    #dtevent_time = datetime.datetime.strptime(event[6], '%Y-%m-%d %H:%M:%S')

    for user in get_users:
        try:
            if test == "yes": user['user_id'] = 919148970
            if event[0] == "":
                await bot.send_message(user['user_id'], event[1], disable_web_page_preview=True)
                #await bot.send_message(user['user_id'], post[2], reply_markup = markup, disable_web_page_preview=True)
            else:
                await bot.send_photo(
                    chat_id=user['user_id'],
                    photo=event[0],
                    caption=event[1])   #event[4] if event[4] else None) #.send_photo.file_id, if event[2] else None
            receive_users += 1
        except Exception:
            block_users += 1

        how_users += 1

        if how_users % 10 == 0:
            await send_admins(f"<b>📢 Рассылка началась... ({how_users}/{len(get_users)})</b>")

        await asyncio.sleep(0.05)

    await send_admins(
        f"<b>📢 Рассылка была завершена ✅</b>\n"
        f"👤 Пользователей получило сообщение: <code>{receive_users} ✅</code>\n"
        f"👤 Пользователей не получило сообщение: <code>{block_users} ❌</code>"
    )
    #update_post(event[0], state = 'sended')

# Автоматическая проверка обновления каждые 24 часа
async def check_update():
    update_link = ""

# Получение faq
def get_faq(user_id, send_message):
    get_user = get_userx(user_id=user_id)

    if "{user_id}" in send_message:
        send_message = send_message.replace(
            "{user_id}", f"<b>{get_user['user_id']}</b>")
    if "{username}" in send_message:
        send_message = send_message.replace(
            "{username}", f"<b>{get_user['user_login']}</b>")
    if "{firstname}" in send_message:
        send_message = send_message.replace(
            "{firstname}", f"<b>{get_user['user_name']}</b>")

    return send_message


# Загрузка текста на текстовый хостинг
async def upload_text(dp, get_text):
    session = await (dp.bot['rSession']).get_session()

    spare_pass = False
    await asyncio.sleep(0.5)

    try:
        response = await session.post("http://pastie.org/pastes/create",
                                      data={"language": "plaintext", "content": get_text})

        get_link = response.url
        if "create" in str(get_link):
            spare_pass = True
    except Exception:
        spare_pass = True

    if spare_pass:
        response = await session.post("https://www.friendpaste.com",
                                      json={"language": "text", "title": "", "snippet": get_text})

        get_link = json.loads((await response.read()).decode())['url']

    return get_link


# Проверка на перенесение БД из старого бота, в нового или указание токена нового бота
async def check_bot_data():
    get_login = get_settingsx()['misc_bot']
    get_bot = await bot.get_me()

    if get_login not in [get_bot.username, "None"]:
        get_positions = get_all_positionsx()

        for position in get_positions:
            update_positionx(position['position_id'], position_photo="")

    update_settingsx(misc_bot=get_bot.username)

#Конвертация адреса из HEX в 58
def hex_to_address(hexaddr):
    checksum = hashlib.sha256(hashlib.sha256(bytes.fromhex(hexaddr)).digest()).digest()[0:4].hex()
    addrchecksum = hexaddr + checksum
    base58addr = base58.b58encode(bytes.fromhex(addrchecksum)).decode('utf-8')
    return base58addr

#Конвертация адреса из 58 в HEX
def address_to_hex(base58addr):
    addrchecksum = base58.b58decode(base58addr).hex()
    address = addrchecksum[0:42]
    checksum = hashlib.sha256(hashlib.sha256(bytes.fromhex(address)).digest()).digest()[0:4].hex()
    if checksum != addrchecksum[42:]:
        raise ValueError("Invalid checksum")
    return address

# Получить информацию о позиции для админа
def get_position_of_day():
    print('Получить информацию о случайной позиции для админа misc_functions.py 127')
    print(len(get_all_positionsx()))
    pos_id = random.choice(get_all_positionsidx())
    print(pos_id['position_id'])
    # pos_id=random.choice(get_all_positionsidx())
    get_items = get_itemsx(position_id=pos_id['position_id'])
    get_position = get_positionx(position_id=pos_id['position_id'])
    get_category = get_categoryx(category_id=get_position['category_id'])

    text_description = "<code>Отсутствует ❌</code>"
    photo_text = "<code>Отсутствует ❌</code>"
    get_photo = None

    if len(get_position['position_photo']) >= 5:
        photo_text = "<code>Присутствует ✅</code>"
        get_photo = get_position['position_photo']

    if get_position['position_description'] != "0":
        text_description = f"\n{get_position['position_description']}"

    get_message = f"<b>📁 Позиция: <code>{get_position['position_name']}</code></b>\n" \
                  f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                  f"🏙 Город: <code>{get_position['position_city']}</code>\n" \
                  f"🗃 Категория: <code>{get_category['category_name']}</code>\n" \
                  f"💰 Стоимость: <code>{get_position['position_price']}₽</code>\n" \
                  f"📦 Остаток: <code>{len(get_items)}шт</code>\n" \
                  f"📸 Изображение: {photo_text}\n" \
                  f"📜 Описание: {text_description}"

    return get_message, get_photo


# Получить информацию о позиции для админа
def get_artist_admin(artist_id):
    print('Получить информацию об артисте для админа misc_functions.py 127')
    get_artist = get_artistx(artist_id=artist_id)

    text_description = "<code>Отсутствует ❌</code>"
    photo_text = "<code>Отсутствует ❌</code>"
    get_photo = None

    if len(get_artist['logo']) >= 5:
        photo_text = "<code>Присутствует ✅</code>"
        get_photo = get_artist['logo']

    if get_artist['description'] != "0":
        text_description = f"\n{get_artist['description']}"

    get_message = f"<b>📁 Артист : <code>{get_artist['name']}</code></b>\n" \
                  f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                  f"🏙 Город: <code>{get_artist['city']}</code>\n" \
                  f"📸 Изображение: {photo_text}\n" \
                  f"📜 Описание: {text_description}"

    return get_message, get_photo


# Получить информацию о позиции для админа
def get_position_admin(position_id):
    print('Получить информацию о позиции для админа misc_functions.py 465')
    get_items = get_itemsx(position_id=position_id)
    get_position = get_positionx(position_id=position_id)
    get_category = get_categoryx(category_id=get_position['category_id'])

    text_description = "<code>Отсутствует ❌</code>"
    photo_text = "<code>Отсутствует ❌</code>"
    get_photo = None

    if len(get_position['position_photo']) > 5:
        photo_text = "<code>Присутствует ✅</code>"
        get_photo = get_position['position_photo']

    if get_position['position_description'] != "0":
        text_description = f"\n{get_position['position_description']}"

    if get_position['position_type'] == 1:
        position_rest = get_position['position_rest']
    elif get_position['position_type'] == 2:
        position_rest = len(get_items)

    get_message = f"<b>📁 Позиция: <code>{get_position['position_name']}</code></b>\n" \
                  f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                  f"🏙 Город: <code>{get_position['position_city']}</code>\n" \
                  f"🗃 Категория: <code>{get_category['category_name']}</code>\n" \
                  f"💰 Стоимость: <code>{get_position['position_price']}₽</code>\n" \
                  f"📦 Остаток: <code>{position_rest}шт</code>\n" \
                  f"📸 Изображение: {photo_text}\n" \
                  f"📜 Описание: {text_description}"

    return get_message, get_photo
# f"🗃 Категория: <code>{get_category['category_name']}</code>\n" \

def user_refill_my(user_id, lang):
    return _("<b>Нажмите пожалуйста кнопку:</b>", locale=lang)

def open_profile_my2(user_id):
    print("||||A+===")
    get_user = get_userx(user_id=user_id)
    #get_purchases = get_purchasesx(user_id=user_id)
    lang = get_userx(user_id=user_id)['user_lang']
    user_role = get_userx(user_id=user_id)['user_role']
    #user_promocode = get_userx(user_id=user_id)['user_promocode'] or "None"
    #user_unix = get_user['user_unix'] // 60 // 60 // 24
    print(lang)
    count_items = 0
    #how_days = get_unix() - user_unix
    print("||||B+===")
    '''if get_user['user_role'] in ["ShopAdmin", "Admin"]:
        free_delivery_point = get_user['free_delivery_point']
        delivery_rate = get_user['delivery_rate']
        selleradd = _("📄 Бесплатная доставка от: ", locale=lang) + str(get_user['free_delivery_point']) + "\n"
        selleradd += _("📄 Ставка доставки: ", locale=lang) + str(get_user['delivery_rate'])
    else: selleradd = "None"
    print(selleradd)'''

    '''if len(get_purchases) >= 1:
        for items in get_purchases:
            count_items += int(items['purchase_count'])'''


    get_message = ded(f"""
                  <b>📁 Позиция: <code>{get_position['position_name']}</code></b>
                  ➖➖➖➖➖➖➖➖➖➖
                  🗃 Категория: <code>{get_category['category_name']}</code>
                  💰 Стоимость: <code>{get_position['position_price']}₽</code>
                  📦 Количество: <code>{len(get_items)}шт</code>
                  📸 Изображение: {photo_text}
                  📜 Описание: {text_description}

                  💸 Продаж за День: <code>{show_profit_count_day}шт</code> - <code>{show_profit_amount_day}₽</code>
                  💸 Продаж за Неделю: <code>{show_profit_count_week}шт</code> - <code>{show_profit_amount_week}₽</code>
                  💸 Продаж за Всё время: <code>{show_profit_count_all}шт</code> - <code>{show_profit_amount_all}₽</code>
                  """)

    #get_settings = get_settingsx()
    #profile_text = f"<b>👤 Ваш профиль:</b>"
    profile_text = _("<b>👤 Ваш профиль:</b>", locale=lang) + "\n"
    profile_text += "➖➖➖➖➖➖➖➖➖➖\n"
    profile_text += _("🆔 ID: <code>", locale=lang) + str(get_user['user_id']) + "</code>\n"
    profile_text += _("💰 Баланс: <code>", locale=lang) + str(get_user['user_balance']) + "₽</code>\n"
    profile_text += _("📄 Скидка(промокод): <code>", locale=lang) + prmtxt + "</code>\n"
    profile_text += _("🎁 Куплено товаров: <code>", locale=lang) + str(count_items) +"шт</code>\n"
    profile_text += _("🕰 Регистрация: <code>", locale=lang) + str(get_user['user_date'].split(' ')[0]) + " " + str(convert_day(how_days)) + "</code>\n"
    profile_text += _("🏙 Город: <code>", locale=lang) + get_user['user_city'] + "</code>\n"
    profile_text += _("📄 Роль: <code>", locale=lang) + user_role + "</code>\n"

    return profile_text


def open_profile_my(user_id):
    get_purchases = get_purchasesx(user_id=user_id)
    get_user = get_userx(user_id=user_id)

    how_days = int(get_unix() - get_user['user_unix']) // 60 // 60 // 24
    count_items = sum([items['purchase_count'] for items in get_purchases])

    return ded(f"""
           <b>👤 Ваш профиль:</b>
           ➖➖➖➖➖➖➖➖➖➖
           🆔 ID: <code>{get_user['user_id']}</code>
              Роль: <code>{get_user['user_role']}</code>
           💰 Баланс: <code>{get_user['user_balance']}₽</code>
           🎁 Куплено товаров: <code>{count_items}шт</code>
           🕰 Регистрация: <code>{get_user['user_date'].split(' ')[0]} ({convert_day(how_days)})</code>
           """)

           #🎁 Куплено товаров: <code>{count_items}шт</code>
          # 🕰 Регистрация: <code>{get_user['user_date'].split(' ')[0]} ({convert_day(how_days)})</code>
# Открытие своего профиля
def open_profile_my2(user_id):
    #get_purchases = get_purchasesx(user_id=user_id)
    get_user = get_userx(user_id=user_id)

    #how_days = int(get_unix() - get_user['user_unix']) // 60 // 60 // 24
    #count_items = sum([items['purchase_count'] for items in get_purchases])
    profile_text = f"""<b>👤 Ваш профиль:</b>
           ➖➖➖➖➖➖➖➖➖➖
           🆔 ID: <code>{get_user['user_id']}</code>
           💰 Баланс: <code>{get_user['user_balance']}₽</code>
           """

    return profile_text

#🎁 Куплено товаров: <code>{count_items}шт</code>
#🕰 Регистрация: <code>{get_user['user_date'].split(' ')[0]} ({convert_day(how_days)})</code>

def open_partners_list2():
    get_partners = get_all_partnersx()

    keyboard = types.ReplyKeyboardMarkup(row_width=3, resize_keyboard=True)
    for partner in get_partners:
        buttons_to_add = append(types.InlineKeyboardButton(text=f"{partner['name']}", url=f"{partner['link']}"))
    keyboard.add(*buttons_to_add)

    return keyboard

def calc_cart_summ(user_id):
    order = get_user_orderx(user_id=user_id)
    get_positions = []
    totalm = 0
    get_positions = get_cart_positionsx(order_id=order['order_id'])
    for position in get_positions:
        poscost = position['count'] * position['position_price']
        totalm += poscost
    return totalm

def calc_order_summ(order_id):
    get_positions = []
    totalm = 0
    get_positions = get_cart_positionsx(order_id=order_id)
    for position in get_positions:
        poscost = position['count'] * position['position_price']
        totalm += poscost
    return totalm



# Открытие корзины
def open_cart_orders(order_id, lang):
    orderdata = []
    #данные заказа
    orderdata = get_orderxo(order_id=order_id)
    print(orderdata)
    #покупатель
    order_user_id = orderdata['user_id']
    #данные покупателя
    order_user = get_userx(user_id=order_user_id)
    #роль покупателя user_role
    if order_user['user_role'] != "None": user_role = order_user['user_role']
    else: user_role = "User"
    if order_user['user_balance'] != "None": ub = order_user['user_balance']
    else: ub = 0
    #юзер userid
    if order_user['user_login']: userid = f"Имя пользователя: <code>@{order_user['user_login']}</code>"
    else: userid = f"Телеграм ID: <code>{order_user['user_id']}</code>"

    #позиции заказа
    get_positions = []
    get_positions = get_cart_positionsx(order_id=order_id)
    this_itemst = this_itemst2 = this_itemst3 = ''
    totalm = 0

    this_items = ["| Наименование | Цена | Количество | Стоимость |"]
    for position in get_positions:
        poscost = position['count'] * position['position_price']
        totalm += poscost  # собираем стоимость корзины
        this_items.append(f"{position['position_name']} | {position['position_price']}₽ | {position['count']}шт. | {poscost}₽")
        this_itemst += f"{position['position_name']} | {position['position_price']}₽ | {position['count']}шт. | {poscost}₽ \n"
        print(f"{position['position_name']} | {position['position_price']}₽ | {position['count']}шт.| {poscost}₽")

    this_itemst3 += f"Всего по всем позициям: {str(totalm)}" + "\n"

    dso = get_delivery_seller_options(order_id)['free_delivery_point']
    #print(dso)

    delivery_rate = get_delivery_seller_options(order_id)['delivery_rate']
    #print(delivery_rate)
    delivery = 0 if totalm > dso else delivery_rate
    #print(f"Доставка:{str(delivery)}")
    totalm2 = totalm + delivery
    #print(totalm2)

    if ub >= totalm2: this_itemst2 = "Заказ возможно оплатить с баланса целиком."
    else:
        torefill = totalm2 - ub
        this_itemst2 = f"Для оформления заказа потребуется пополнение в размере:{str(torefill)}₽"
    #print(this_itemst2)
    print(lang)
    if lang == "ru":
        return f"<b>👤 Ваша Корзина:</b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖\n" \
               f"🆔 Корзина ID: <code>{orderdata['order_id']}</code>\n" \
               f"🆔 Статус: <code>{orderdata['order_state']}</code>\n" \
               f"💳 Баланс: <code>{ub}₽</code>\n" \
               f"🗃 Всего товаров: <code>{totalm}</code>\n" \
               f"   <code>{this_itemst}</code>\n" \
               f"🏙 Итого корзина: <code>{totalm2}₽</code>\n" \
               f"🏙 Примечание: <code>{this_itemst2}</code>"

    if lang == "en":
        return f"<b>👤 Your Cart:</b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖\n" \
               f"🆔 Cart ID: <code>{orderdata['order_id']}</code>\n" \
               f"🆔 State: <code>{orderdata['order_state']}</code>\n" \
               f"💳 Balance: <code>{ub}₽</code>\n" \
               f"🗃 Total Goods: <code>{totalm}</code>\n" \
               f"   <code>{this_itemst}</code>\n" \
               f"🏙 Total Cart: <code>{totalm2}₽</code>\n" \
               f"🏙 Aditional Text: <code>{this_itemst2}</code>"

def open_profile_search(user_id, lang):
    get_purchases = get_purchasesx(user_id=user_id)
    get_user = get_userx(user_id=user_id)
    count_items = 0

    how_days = int(get_unix() - get_user['user_unix']) // 60 // 60 // 24

    if len(get_purchases) >= 1:
        for items in get_purchases:
            count_items += items['purchase_count']

    if lang == "ru":
        message =  f"<b>👤 Профиль пользователя: <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a></b>\n" \
                   f"➖➖➖➖➖➖➖➖➖➖\n" \
                   f"🆔 ID: <code>{get_user['user_id']}</code>\n" \
                   f"👤 Логин: <b>@{get_user['user_login']}</b>\n" \
                   f"👤 Роль: <b>{get_user['user_role']}</b>\n" \
                   f"Ⓜ Имя: <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a>\n" \
                   f"🕰 Регистрация: <code>{get_user['user_date']} ({convert_day(how_days)})</code>\n" \
                   f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                   f"💰 Баланс: <code>{get_user['user_balance']}₽</code>\n" \
                   f"💰 Всего пополнено: <code>{get_user['user_refill']}₽</code>\n" \
                   f"🎁 Куплено товаров: <code>{count_items}шт</code>"

    if lang == "en":
        message = f"<b>👤 User Profile: <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a></b>\n" \
                  f"➖➖➖➖➖➖➖➖➖➖\n" \
                  f"🆔 userID: <code>{get_user['user_id']}</code>\n" \
                  f"👤 Login: <b>@{get_user['user_login']}</b>\n" \
                  f"👤 Role: <b>{get_user['user_role']}</b>\n" \
                  f"Ⓜ Name: <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a>\n" \
                  f"🕰 Registration: <code>{get_user['user_date']} ({convert_day(how_days)})</code>\n" \
                  f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                  f"💰 Balance: <code>{get_user['user_balance']}₽</code>\n" \
                  f"💰 Total Charged: <code>{get_user['user_refill']}₽</code>\n" \
                  f"🎁 Products Purchased: <code>{count_items}шт</code>"

    return message

# Открытие профиля при поиске
def open_profile_search_req(user_id, lang):
    get_requests = get_requestx(requester=user_id)
    get_purchases = get_purchasesx(user_id=user_id)
    get_user = get_userx(user_id=user_id)
    count_items = 0
    total_items = ''

    how_days = int(get_unix() - get_user['user_unix']) // 60 // 60 // 24

    if len(get_purchases) >= 1:
        for items in get_purchases:
            count_items += items['purchase_count']

    if len(get_requests) >= 1:
        for items in get_requests:
            total_items += "|" + str(items['requesttxt'])

#            total_ids += " " + str(items['increment']) + " "

    if lang == "ru":
        message = f"<b>👤 Запрос от пользователя: <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a></b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖\n" \
               f"Группа товаров: <b>{total_items}</b>\n" \
               f"🆔 userID: <code>{get_user['user_id']}</code>\n" \
               f"👤 Логин: <b>@{get_user['user_login']}</b>\n" \
               f"👤 Роль: <b>{get_user['user_role']}</b>\n" \
               f"Ⓜ Имя: <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a>\n" \
               f"🕰 Регистрация: <code>{get_user['user_date']} ({convert_day(how_days)})</code>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"💰 Баланс: <code>{get_user['user_balance']}₽</code>\n" \
               f"💰 Всего пополнено: <code>{get_user['user_refill']}₽</code>\n" \
               f"🎁 Куплено товаров: <code>{count_items}шт</code>"

    if lang == "en":
        message = f"<b>👤 Request from User: <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a></b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖\n" \
               f"Product Group: <b>{total_items}</b>\n" \
               f"🆔 userID: <code>{get_user['user_id']}</code>\n" \
               f"👤 Login: <b>@{get_user['user_login']}</b>\n" \
               f"👤 Role: <b>{get_user['user_role']}</b>\n" \
               f"Ⓜ Name: <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a>\n" \
               f"🕰 Registration: <code>{get_user['user_date']} ({convert_day(how_days)})</code>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"💰 Balance: <code>{get_user['user_balance']}₽</code>\n" \
               f"💰 Total Charged: <code>{get_user['user_refill']}₽</code>\n" \
               f"🎁 Products Purchased: <code>{count_items}шт</code>"

    return message

#f"  requestID: <code>{items['increment']}</code>\n" \
    # Статистика бота
def get_statisctics(lang):
    show_profit_all, show_profit_day, show_profit_week = 0, 0, 0
    show_refill_all, show_refill_day, show_refill_week = 0, 0, 0
    show_money_users, show_money_sellers, show_buy_items, show_city_users, top_sellers = 0, 0, 0, "", 0

    get_categories = get_all_categoriesx()
    get_positions = get_all_positionsx()
    get_purchases = get_all_purchasesx()
    get_refill = get_all_refillx()
    get_settings = get_settingsx()
    get_items = get_all_itemsx()
    get_users = get_all_usersx()
    get_all_users_by_cities = get_users_by_cities()
    top_sellers = []
    top_sellersp = []
    #keyboard = InlineKeyboardMarkup()

    for purchase in get_purchases:
        show_profit_all += purchase['purchase_price']
        show_buy_items += purchase['purchase_count']
        if purchase['purchase_unix'] - get_settings['misc_profit_day'] >= 0:
            show_profit_day += purchase['purchase_price']
        if purchase['purchase_unix'] - get_settings['misc_profit_week'] >= 0:
            show_profit_week += purchase['purchase_price']

    for refill in get_refill:
        show_refill_all += refill['refill_amount']
        if refill['refill_unix'] - get_settings['misc_profit_day'] >= 0:
            show_refill_day += refill['refill_amount']
        if refill['refill_unix'] - get_settings['misc_profit_week'] >= 0:
            show_refill_week += refill['refill_amount']

    for user in get_users:
        #print(user)
        if user['user_role'] == "ShopAdmin":
            show_money_sellers += user['user_balance']
        elif user['user_role'] is None:
            show_money_users += user['user_balance']
        if user['user_role'] == "ShopAdmin" and user['user_balance'] >= 0:
            top_sellers += user['user_name'] + str(user['user_balance']) + "|"

    #cities = json.loads(get_all_users_by_cities)
    for city in get_all_users_by_cities:
        print(city)
        #show_city_users += city['user_city']
        #show_city_users += " ".join(city['user_city'])
        #print(students = json.load(f))
        #cityj = json.load(city)
        #show_city_users += city['user_city']
        #show_city_users += " | " + city['user_city'] + " : " + str(city['countu']) + " |"
        show_city_users += f" <b> {city['user_city']} </b>:  {str(city['countu'])} \n"
        #show_city_users .join(f"| {city['city']} : {str(city['countu'])} |")
        #show_city_users += "|" + city['user_city'] + "|"

    if lang == "ru":
        return f"<b>📊 Статистика бота</b>\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n<b>🔶 Пользователи: 🔶</b>\n👤 Пользователей: <code>{len(get_users)}</code>\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n<b>🔶 Средства 🔶</b>\n💸 Продаж за 24 часа: <code>{show_profit_day}₽</code>\n💸 Продаж за неделю: <code>{show_profit_week}₽</code>\n💸 Продаж за всё время: <code>{show_profit_all}₽</code>\n💳 Средств на балансах пользователей: <code>{show_money_users}₽</code>\n💳 Средств на балансах продавцов: <code>{show_money_sellers}₽</code>\n💰 Пополнений за 24 часа: <code>{show_refill_day}₽</code>\n💰 Пополнений за неделю: <code>{show_refill_week}₽</code>\n💰 Пополнений за всё время: <code>{show_refill_all}₽</code>\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n<b>🔶 Прочее 🔶</b>\n🎁 Товаров: <code>{len(get_items)}шт</code>\n📁 Позиций: <code>{len(get_positions)}шт</code>\n🗃 Категорий: <code>{len(get_categories)}шт</code>\nПродано товаров: <code>{show_buy_items}шт</code>\n🎁 По городам: <code>{show_city_users}</code>\n"
    if lang == "en":
        return f"<b>📊 Bot statistics</b>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"<b>🔶 Users: 🔶</b>\n" \
               f"👤 Users Total: <code>{len(get_users)}</code>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"<b>🔶 Finance 🔶</b>\n" \
               f"💸 Sales for 24 hours: <code>{show_profit_day}R</code>\n" \
               f"💸 Sales for a week: <code>{show_profit_week}R</code>\n" \
               f"💸 Sales for a time: <code>{show_profit_all}R</code>\n" \
               f"💳 Money in System: <code>{show_money_users}R</code>\n" \
               f"💰 Charged for a 24 hours: <code>{show_refill_day}R</code>\n" \
               f"💰 Charged for a week: <code>{show_refill_week}R</code>\n" \
               f"💰 Charged All: <code>{show_refill_all}R</code>\n" \
               f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
               f"<b>🔶 Other 🔶</b>\n" \
               f"🎁 Digital Items: <code>{len(get_items)}pcs</code>\n" \
               f"📁 Positions: <code>{len(get_positions)}pcs</code>\n" \
               f"🗃 Categories: <code>{len(get_categories)}pcs</code>\n" \
               f"🎁 Products Sold: <code>{show_buy_items}pcs</code>\n" \
               f" Users in Cities: {show_city_users}"



# Открытие профиля при поиске
def open_profile_search_seller(user_id, price):
    get_purchases = get_purchasesx(user_id=user_id)
    get_user = get_userx(user_id=user_id)
    count_items = 0

    how_days = int(get_unix() - get_user['user_unix']) // 60 // 60 // 24

    if len(get_purchases) >= 1:
        for items in get_purchases:
            count_items += items['purchase_count']

    return f"<b>👤 Профиль пользователя: <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a></b>\n" \
           f"➖➖➖➖➖➖➖➖➖➖\n" \
           f"🆔 ID: <code>{get_user['user_id']}</code>\n" \
           f"👤 Логин: <b>@{get_user['user_login']}</b>\n" \
           f"Ⓜ Имя: <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a>\n" \
           f"🕰 Регистрация: <code>{get_user['user_date']} ({convert_day(how_days)})</code>\n" \
           f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
           f"💰 Продано: <code>{price}₽</code>\n" \
           f"💰 Баланс: <code>{get_user['user_balance']}₽</code>\n" \
           f"💰 Всего пополнено: <code>{get_user['user_refill']}₽</code>\n" \
           f"🎁 Куплено товаров: <code>{count_items}шт</code>"


# Открытие профиля при поиске
def open_profile_search_seller(user_id):
    get_purchases = get_purchasesx(user_id=user_id)
    get_user = get_userx(user_id=user_id)
    count_items = 0
    seller_items = ''
    totals = 0

    print(user_id)

    get_purchasessel = get_purchasesxx(user_id)
    print(get_purchasessel)

    how_days = int(get_unix() - get_user['user_unix']) // 60 // 60 // 24

    if len(get_purchasessel) >= 1:
        for items in get_purchasessel:
            name_item = items[1]
            count_items = items[2]
            name_price = items[3]
            seller_items += f"{name_item}  {count_items}шт. <code>{name_price}₽</code>\n"
            totals += items[3]


    if len(get_purchases) >= 1:
        for items in get_purchases:
            count_items += items['purchase_count']


    return f"<b>👤 Профиль пользователя: <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a></b>\n" \
           f"➖➖➖➖➖➖➖➖➖➖\n" \
           f"🆔 ID: <code>{get_user['user_id']}</code>\n" \
           f"👤 Логин: <b>@{get_user['user_login']}</b>\n" \
           f"Ⓜ Имя: <a href='tg://user?id={get_user['user_id']}'>{get_user['user_name']}</a>\n" \
           f"🕰 Регистрация: <code>{get_user['user_date']} ({convert_day(how_days)})</code>\n" \
           f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
           f"➖➖➖➖{seller_items}➖➖➖\n" \
           f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
           f"Всего продано: <code>{totals}₽</code>\n" \
           f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
           f"💰 Баланс: <code>{get_user['user_balance']}₽</code>\n" \
           f"💰 Всего пополнено: <code>{get_user['user_refill']}₽</code>\n" \
           f"🎁 Куплено товаров: <code>{count_items}шт</code>"

# Статистика бота
def generate_dales_report():
    show_profit_all, show_profit_day, show_profit_week = 0, 0, 0
    show_refill_all, show_refill_day, show_refill_week = 0, 0, 0
    show_money_users, show_buy_items, show_money_users = 0, 0, 0

    get_categories = get_all_categoriesx()
    get_positions = get_all_positionsx()
    get_purchases = get_all_purchasesx()
    get_refill = get_all_refillx()
    get_settings = get_settingsx()
    get_items = get_all_itemsx()
    get_users = get_all_usersx()
    #get_users_by_cities = get_users_by_cities()

    for purchase in get_purchases:
        show_profit_all += purchase['purchase_price']
        show_buy_items += purchase['purchase_count']
        if purchase['purchase_unix'] - get_settings['misc_profit_day'] >= 0:
            show_profit_day += purchase['purchase_price']
        if purchase['purchase_unix'] - get_settings['misc_profit_week'] >= 0:
            show_profit_week += purchase['purchase_price']

    for refill in get_refill:
        show_refill_all += refill['refill_amount']
        if refill['refill_unix'] - get_settings['misc_profit_day'] >= 0:
            show_refill_day += refill['refill_amount']
        if refill['refill_unix'] - get_settings['misc_profit_week'] >= 0:
            show_refill_week += refill['refill_amount']

    for user in get_users:
        show_money_users += user['user_balance']

    return f"<b>📊 Статистика бота</b>\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n<b>🔶 Пользователи: 🔶</b>\n👤 Пользователей: <code>{len(get_users)}</code>\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n<b>🔶 Средства 🔶</b>\n💸 Продаж за 24 часа: <code>{show_profit_day}₽</code>\n💸 Продаж за неделю: <code>{show_profit_week}₽</code>\n💸 Продаж за всё время: <code>{show_profit_all}₽</code>\n💳 Средств в системе: <code>{show_money_users}₽</code>\n💰 Пополнений за 24 часа: <code>{show_refill_day}₽</code>\n💰 Пополнений за неделю: <code>{show_refill_week}₽</code>\n💰 Пополнений за всё время: <code>{show_refill_all}₽</code>\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n<b>🔶 Прочее 🔶</b>\n🎁 Товаров: <code>{len(get_items)}шт</code>\n📁 Позиций: <code>{len(get_positions)}шт</code>\n🗃 Категорий: <code>{len(get_categories)}шт</code>\n🎁 Продано товаров: <code>{show_buy_items}шт</code>\n Города: <code>{show_city_users}</code>\n"



# Статистика бота
def get_statisctics2():
    show_profit_all, show_profit_day, show_profit_week = 0, 0, 0
    show_refill_all, show_refill_day, show_refill_week = 0, 0, 0
    show_money_users, show_buy_items, show_money_users, show_city_users = 0, 0, 0, 0

    get_categories = get_all_categoriesx()
    get_positions = get_all_positionsx()
    get_purchases = get_all_purchasesx()
    get_refill = get_all_refillx()
    get_settings = get_settingsx()
    get_items = get_all_itemsx()
    get_users = get_all_usersx()
    get_all_users_by_cities = get_users_by_cities()

    for purchase in get_purchases:
        show_profit_all += purchase['purchase_price']
        show_buy_items += purchase['purchase_count']
        if purchase['purchase_unix'] - get_settings['misc_profit_day'] >= 0:
            show_profit_day += purchase['purchase_price']
        if purchase['purchase_unix'] - get_settings['misc_profit_week'] >= 0:
            show_profit_week += purchase['purchase_price']

    for refill in get_refill:
        show_refill_all += refill['refill_amount']
        if refill['refill_unix'] - get_settings['misc_profit_day'] >= 0:
            show_refill_day += refill['refill_amount']
        if refill['refill_unix'] - get_settings['misc_profit_week'] >= 0:
            show_refill_week += refill['refill_amount']

    for user in get_users:
        show_money_users += user['user_balance']

    show_city_users = "".join(
        "| " + city['user_city'] + ":" + str(city['countu']) + " |"
        for city in get_all_users_by_cities
    )
    return f"<b>📊 Статистика бота</b>\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n<b>🔶 Пользователи: 🔶</b>\n👤 Пользователей: <code>{len(get_users)}</code>\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n<b>🔶 Средства 🔶</b>\n💸 Продаж за 24 часа: <code>{show_profit_day}₽</code>\n💸 Продаж за неделю: <code>{show_profit_week}₽</code>\n💸 Продаж за всё время: <code>{show_profit_all}₽</code>\n💳 Средств в системе: <code>{show_money_users}₽</code>\n💰 Пополнений за 24 часа: <code>{show_refill_day}₽</code>\n💰 Пополнений за неделю: <code>{show_refill_week}₽</code>\n💰 Пополнений за всё время: <code>{show_refill_all}₽</code>\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n<b>🔶 Прочее 🔶</b>\n🎁 Товаров: <code>{len(get_items)}шт</code>\n📁 Позиций: <code>{len(get_positions)}шт</code>\n🗃 Категорий: <code>{len(get_categories)}шт</code>\n🎁 Продано товаров: <code>{show_buy_items}шт</code>\n <b>Количество пользователей по городам:</b> \n {show_city_users} \n"

# Автобэкапы БД для админов
async def autobackup_admin():
    for admin in get_admins():
        with open(PATH_DATABASE, "rb") as document:
            try:
                await bot.send_document(admin,
                                        document,
                                        caption=f"<b>📦 AUTOBACKUP</b>\n"
                                                f"🕰 <code>{get_date()}</code>")
            except Exception:
                pass

# Статистика бота
def generate_sales_report():
    show_profit_all, show_profit_day, show_profit_week = 0, 0, 0
    show_refill_all, show_refill_day, show_refill_week = 0, 0, 0
    show_money_users, show_money_sellers, show_buy_items = 0, 0, 0


    get_categories = get_all_categoriesx()
    get_positions = get_all_positionsx()
    get_purchases = get_all_purchasesx()
    #get_purchasesbysellers = get_purchasesbysellers()
    get_refill = get_all_refillx()
    get_settings = get_settingsx()
    get_items = get_all_itemsx()
    get_users = get_all_usersx()
    top_sellers = []
    top_sellersp = []
    #keyboard = InlineKeyboardMarkup()

    for purchase in get_purchases:
        show_profit_all += purchase['purchase_price']
        show_buy_items += purchase['purchase_count']
        if purchase['purchase_unix'] - get_settings['misc_profit_day'] >= 0:
            show_profit_day += purchase['purchase_price']
        if purchase['purchase_unix'] - get_settings['misc_profit_week'] >= 0:
            show_profit_week += purchase['purchase_price']

    for refill in get_refill:
        show_refill_all += refill['refill_amount']
        if refill['refill_unix'] - get_settings['misc_profit_day'] >= 0:
            show_refill_day += refill['refill_amount']
        if refill['refill_unix'] - get_settings['misc_profit_week'] >= 0:
            show_refill_week += refill['refill_amount']

    for user in get_users:
        if user['user_role'] == "ShopAdmin":
            show_money_sellers += user['user_balance']
        elif user['user_role'] is None or user['user_role'] == "User":
            show_money_users += user['user_balance']
        if user['user_role'] == "ShopAdmin" and user['user_balance'] >= 0:
            top_sellers += user['user_name'] + str(user['user_balance']) + "\n"

    return f"<b>📊 Отчет о продажах</b>\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n<b>🔶 Пользователи: 🔶</b>\n👤 Пользователей: <code>{len(get_users)}</code>\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n<b>🔶 Средства 🔶</b>\n💸 Продаж за 24 часа: <code>{show_profit_day}₽</code>\n💸 Продаж за неделю: <code>{show_profit_week}₽</code>\n💸 Продаж за всё время: <code>{show_profit_all}₽</code>\n💳 Средств на балансах пользователей: <code>{show_money_users}₽</code>\n💳 Средств на балансах продавцов: <code>{show_money_sellers}₽</code>\n💰 Пополнений за 24 часа: <code>{show_refill_day}₽</code>\n💰 Пополнений за неделю: <code>{show_refill_week}₽</code>\n💰 Пополнений за всё время: <code>{show_refill_all}₽</code>\n➖➖➖➖➖➖➖➖➖➖➖➖➖\n<b>🔶 Прочее 🔶</b>\n🎁 Товаров: <code>{len(get_items)}шт</code>\n📁 Позиций: <code>{len(get_positions)}шт</code>\n🗃 Категорий: <code>{len(get_categories)}шт</code>\n🎁 Продано товаров: <code>{show_buy_items}шт</code>\n"

# Получить информацию о магазине для админа
def get_shop_admin(shop_id):
    print('Получить информацию о позиции для админа misc_functions.py 127')
    #get_items = get_itemsx(position_id=position_id)
    get_shop = get_shopx(shop_id=shop_id)
    #get_category = get_categoryx(category_id=get_position['category_id'])
    #link = get_start_link(str(f"deep_link&shop_id&{shop_id}"), encode=True)

    print(get_shop)

    text_description = "<code>Отсутствует ❌</code>"
    photo_text = "<code>Отсутствует ❌</code>"
    get_photo = None

    if get_shop['logo'] != None:
        photo_text = "<code>Присутствует ✅</code>"
        get_photo = get_shop['logo']

    if get_shop['address'] != "0":
            text_description = f"\n{get_shop['address']}"
    if get_shop['phone'] != "0":
        text_description = f"\n{get_shop['phone']}"
    if get_shop['description'] != "0":
        text_description = f"\n{get_shop['description']}"

    get_message = f"<b>📁 Магазин: <code>{get_shop['name']}</code></b>\n" \
                  f"➖➖➖➖➖➖➖➖➖➖➖➖➖\n" \
                  f"🏙 Город: <code>{get_shop['city']}</code>\n" \
                  f"📸 Изображение: {photo_text}\n" \
                  f"📸 Адрес: {get_shop['address']}\n" \
                  f"📸 Телефон: {get_shop['phone']}\n" \
                  f"📜 Описание: {text_description}"

    return get_message, get_photo


tgbot >utilis>misc>bot_commands.py:
# - *- coding: utf- 8 - *-
from aiogram import Dispatcher
from aiogram.types import BotCommand, BotCommandScopeChat, BotCommandScopeDefault

from tgbot.data.config import get_admins

# Команды для юзеров
user_commands = [
    BotCommand("start", "♻ Перезапустить бота"),
    BotCommand("lang", "Изменить язык"),
    BotCommand("edit_location", "📡 Изменить город"),
    BotCommand("support", "☎ Поддержка"),
    BotCommand("user_seller_request", "Я продавец"),
    BotCommand("faq", "ℹ FAQ"),
]

# Команды для админов
admin_commands = [
    BotCommand("start", "♻ Перезапустить бота"),
    BotCommand("lang", "Изменить язык"),
    BotCommand("edit_location", "📡 Изменить город"),
    BotCommand("support", "☎ Поддержка"),
    BotCommand("faq", "ℹ FAQ"),
    BotCommand("check_seller_requests", "Заявки в продавцы"),
    BotCommand("db", "📦 Получить Базу Данных"),
    BotCommand("log", "🖨 Получить логи"),
]


# Установка команд
async def set_commands(dp: Dispatcher):
    await dp.bot.set_my_commands(user_commands, scope=BotCommandScopeDefault())

    for admin in get_admins():
        try:
            await dp.bot.set_my_commands(admin_commands, scope=BotCommandScopeChat(chat_id=admin))
        except Exception:
            pass

tgbot >utilis>misc>bot_filters.py:
# - *- coding: utf- 8 - *-
from aiogram import types
from aiogram.dispatcher.filters import BoundFilter

from tgbot.data.config import get_admins, get_shopadmins, is_shopadmin
from tgbot.services.api_sqlite import get_settingsx, get_user_lang

# Проверка на админа
class IsAdmin(BoundFilter):
    async def check(self, message: types.Message):
        return message.from_user.id in get_admins()

# Проверка на админа
class IsShopAdmin(BoundFilter):
    async def check(self, message: types.Message):
        return message.from_user.id in get_shopadmins()

#Проверка на любого админа
class IsAdminorShopAdmin(BoundFilter):
    async def check(self, message: types.Message):
        return (
            message.from_user.id in get_admins()
            or message.from_user.id in get_shopadmins()
        )

# Проверка на принадлежность товара для админа магазина
class IsProductShopAdmin(BoundFilter):
    async def check(self, message: types.Message):
        #print message.from_user.id 
        # if message.from_user.id in get_admins():
        #     return True
        # else:
        #     return False
        return True

# Проверка на возможность покупки товара
class IsBuy(BoundFilter):
    async def check(self, message: types.Message):
        get_settings = get_settingsx()

        return (
            get_settings['status_buy'] != "True"
            and message.from_user.id not in get_admins()
        )


# Проверка на возможность пополнения
class IsRefill(BoundFilter):
    async def check(self, message: types.Message):
        get_settings = get_settingsx()

        return (
            get_settings['status_refill'] != "True"
            and message.from_user.id not in get_admins()
        )


# Проверка на технические работы
class IsWork(BoundFilter):
    async def check(self, message: types.Message):
        get_settings = get_settingsx()

        return (
            get_settings['status_work'] != "False"
            and message.from_user.id not in get_admins()
        )

class IsShopExist(BoundFilter):
    async def check(self, message: types.Message):
        return check_user_shop_exist(message.from_user.id) == 'True'

tgbot >utilis>misc>bot_logging.py:
# - *- coding: utf- 8 - *-
import logging as bot_logger

import colorlog

from tgbot.data.config import PATH_LOGS

# Формат логгирования
log_formatter_file = bot_logger.Formatter("%(levelname)s | %(asctime)s | %(filename)s:%(lineno)d | %(message)s")
log_formatter_console = colorlog.ColoredFormatter(
    "%(purple)s%(levelname)s %(blue)s|%(purple)s %(asctime)s %(blue)s|%(purple)s %(filename)s:%(lineno)d %(blue)s|%(purple)s %(message)s%(red)s",
    datefmt="%d-%m-%Y %H:%M:%S",
)

# Логгирование в файл tgbot/data/logs.log
file_handler = bot_logger.FileHandler(PATH_LOGS, "w", "utf-8")
file_handler.setFormatter(log_formatter_file)
file_handler.setLevel(bot_logger.INFO)

# Логгирование в консоль
console_handler = bot_logger.StreamHandler()
console_handler.setFormatter(log_formatter_console)
console_handler.setLevel(bot_logger.CRITICAL)

# Подключение настроек логгирования
bot_logger.basicConfig(
    format="%(levelname)s | %(asctime)s | %(filename)s:%(lineno)d | %(message)s",
    handlers=[
        file_handler,
        console_handler
    ]
)

tgbot>.env:
TOKEN='XXXXX'
ADMIN_ID=XXXXX
MY_CHANNEL=XXXXX
MY_CHAT_BOOKMARKS=XXXXX
DB_HOST='1XXXXX'
DB_DATABASE='XXXXX'
DB_USER='XXXXX'
DB_PASSWORD='XXXXX'

tgbot>babel.cfg:
[python: **.py]
encoding = utf-8

tgbot>bextr.py:
from babel.messages.frontend import CommandLineInterface

#CommandLineInterface().run(['pybabel','extract','-F','babel.cfg','-o','locales/mybot.pot','../tgbot', '--project', 'mybot'])
#CommandLineInterface().run(['pybabel','init','-i','locales/mybot.pot','-d','locales', '-l','en', '-D', 'mybot'])
#CommandLineInterface().run(['pybabel','init','-i','locales/mybot.pot','-d','locales', '-l','ru', '-D', 'mybot'])
CommandLineInterface().run(['pybabel','compile','-d','locales', '-D', 'mybot'])
#CommandLineInterface().run(['pybabel','update','-d','locales', '-D', 'mybot', '-i', 'locales/mybot.pot'])
tgbot>loader.py:
# - *- coding: utf- 8 - *-
from aiogram import Bot, Dispatcher
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.types import ParseMode
from apscheduler.schedulers.asyncio import AsyncIOScheduler

from tgbot.data.config import BOT_TOKEN

bot = Bot(token=BOT_TOKEN, parse_mode=ParseMode.HTML)
dp = Dispatcher(bot, storage=MemoryStorage())
scheduler = AsyncIOScheduler()

TelegramGoodsInBot (MAIN DIRECTORY)>cb.py:
from aiohttp import ClientConnectorCertificateError
from async_class import AsyncClass
#from yoomoney import Client
from coinbase.wallet.client import Client


api_key = 'XXXXXX'
api_secret = 'XXXXXX'
client = Client(api_key, api_secret)
account_id = client.get_primary_account()['id']
        #sum = int(sum) + 10 #прибавляется комиссия в btc
        #btc_price = round(float((client.get_buy_price(currency_pair='BTC-RUB')["amount"])))
        #print(btc_price)
        #sum = float(str(sum / btc_price)[:10]) #сколько сатох нужно юзеру оплатить
address_for_tranz = client.create_address(account_id)['address'] #получение кошелька для оплты
print(address_for_tranz)
TelegramGoodsInBot>cob.py:
from coinbase.wallet.client import Client

api_key = 'XXXXXX'
api_secret = 'XXXXXX'
client = Client(api_key, api_secret)
account_id = client.get_primary_account()['id']
address_for_tranz = client.create_address(account_id)['address'] #получение кошелька для оплты
print(address_for_tranz)
TelegramGoodsInBot>coinbase.py:
from aiohttp import ClientConnectorCertificateError
from async_class import AsyncClass
#from yoomoney import Client
from coinbase.wallet.client import Client


api_key = 'XXXXXX'
api_secret = 'XXXXXX'
client = Client(api_key, api_secret)
account_id = client.get_primary_account()['id']
        #sum = int(sum) + 10 #прибавляется комиссия в btc
        #btc_price = round(float((client.get_buy_price(currency_pair='BTC-RUB')["amount"])))
        #print(btc_price)
        #sum = float(str(sum / btc_price)[:10]) #сколько сатох нужно юзеру оплатить
address_for_tranz = client.create_address(account_id)['address'] #получение кошелька для оплты
print(address_for_tranz)
TelegramGoodsInBot>config.data:
[cred]
id = 29673364
hash = 3513fddd411a4a7674304d4902afc9cc
phone = +7 930 318 0287


TelegramGoodsInBot>config.py:
INV_KD = 20 #КД между инвайтами
ERR_KD = 20 #КД если юзер гнида ебаная
CH_FROM = "https://t.me/programrus" #Ссылка на чат откуда тащить юзеров
CH_TO = "https://t.me/goodnewsrussia1" #Ccылка на чат куда тащить юзеров
CHECK_TIMEOUT = False #False - Не ожидать таймаут \ True - Ожидать таймаут
INV_CNT = 40 #Количество инвайтов перед переходом в режим ожидания
PROXY_ENABLED = True
PROXY_IPS = ["172.67.3.96:80",
             "172.67.181.102:80",
             "203.30.188.43:80",
             "203.23.106.121:80",
             "203.30.189.179:80",
             "203.32.120.110:80",
             "45.8.105.176:80",
             "203.28.9.199:80",
             "203.23.104.96:80",
             "203.24.102.238:80",
             "203.28.9.52:80",
             "203.23.106.198:80",
             "203.30.188.217:80",
             "162.247.243.142:80",
             "172.67.120.209:80",
             "191.101.251.57:80",
             "172.64.173.27:80",
             "185.162.231.224:80"]

TelegramGoodsInBot>create_init.py:
from os.path import dirname, basename, isfile, join
import glob
modules = glob.glob(join(dirname(__file__), "*.py"))
__all__ = [ basename(f)[:-3] for f in modules if isfile(f) and not f.endswith('__init__.py')]
print(__all__)
TelegramGoodsInBot>createpl copy.py:
#!/usr/bin/env python3
import os, sys


with open('/var/local/bot3101f/tgbot/locales/ru/LC_MESSAGES/en/mybot.po', encoding='UTF-8') as f:
    for row in f:
        print(row)


TelegramGoodsInBot>createpl.py:
#!/usr/bin/env python3
import os, sys


with open('/var/local/bot3101f/tgbot/locales/ru/LC_MESSAGES/en/mybot.po', encoding='UTF-8') as f:
    for row in f:
        print(row)


TelegramGoodsInBot>createpla.py:
#!/usr/bin/env python3
import os, sys
import deepl

x = open("mybotr.po", "a")
with open('mybot.po', encoding='UTF-8') as f:
    idblock=""
    idblock2=""
    lines = f.readlines()
    for row in lines:
        if row[0] == '"':
            idblock = idblock + row
            xr2 = deepl.translate(source_language="RU", target_language="EN", text=row)
            idblock2 = idblock2 + xr2
            print(idblock)
            print(idblock2)
            print("1")
        if 'msgid ' in row:
            print("2")
            print("2-1")
            if 'msgid ""' in row:
                idblock= idblock + 'msgid ""' + "\n"
                idblock2= idblock2 + 'msgstr ""' + "\n"
            #x.write('msgid ""\n')
            else:
                idblock= idblock + row + "\n"
                xb2 = deepl.translate(source_language="RU", target_language="EN", text=row[7:])
                idblock2= idblock2 + 'msgstr ' + xb2
                continue
            print(row[7:])
            #x.write('msgstr ' + row[6:])
        elif 'msgstr' in row:
            print("3")
            x.write(idblock)
            x.write(idblock2)
            idblock = ""
            idblock2 = ""
            continue
        elif row[0] == "\n":
            print("4")
            x.write('\n')
            #idblock= idblock + row
            #idblock2= idblock2 + row
        else:
            xrow = deepl.translate(source_language="RU", target_language="EN", text=row)
            x.write(xrow)
x.close()
f.close()








TelegramGoodsInBot>data.json:
{
    "user_id": 919148970,
    "type_net": "USDT",
    "coinprice": "79.97000000",
    "pay_amount": 10,
    "priceincoinq": 0.125047,
    "receipt": "168316443340"
}
TelegramGoodsInBot>invite_geo.py:
#!/usr/bin/env python3
from telethon.sync import TelegramClient, connection
from telethon.tl.functions.messages import GetDialogsRequest
from telethon.tl.types import InputPeerEmpty, InputPeerChannel, InputPeerUser
from telethon.errors.rpcerrorlist import PeerFloodError, UserPrivacyRestrictedError
from telethon.tl.functions.channels import InviteToChannelRequest
import configparser
import os, sys
import csv
import traceback
import time
import random
import requests, socket
from tgbot.services.api_sqlite import *


re="\033[1;31m"
gr="\033[1;32m"
cy="\033[1;36m"

def banner():
    print(f"""
´´´´¶¶¶¶¶¶´´´´´´¶¶¶¶¶¶
´´¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶¶¶¶¶¶
´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶ ´¶¶¶¶¶´
´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´´´¶¶¶¶¶¶¶¶
´´´´´´´´´´´¶¶¶¶
{re}

by rashidovich
        """)

    #читаем список пользователей для инвайта
    os.system('clear')
    banner()
    input_file = sys.argv[1]
    users = []
    with open(input_file, encoding='UTF-8') as f:
        rows = csv.reader(f,delimiter=",",lineterminator="\n")
        next(rows, None)
        for row in rows:
            user = {
                'id': row[0],
                'access_hash': row[1],
                'name': row[2],
                'username': row[4],
            }
            #user['id'] = 5518497581
            if user['username'] is None: continue

            users.append(user)

    chats = []
    last_date = None
    chunk_size = 200
    groups=[]

    #получение чатов пользователя
    result = client(GetDialogsRequest(
                 offset_date=last_date,
                 offset_id=0,
                 offset_peer=InputPeerEmpty(),
                 limit=chunk_size,
                 hash = 0
             ))
    chats.extend(result.chats)

    for chat in chats:
        try:
            if chat.megagroup== True:
                groups.append(chat)
        except Exception:
            continue

    for i, group in enumerate(groups):
        print(f'{gr}[{cy}{str(i)}{gr}]{cy} - {group.title}')
    print(f'{gr}[+] Choose a group to add members')
    g_index = input(f"{gr}[+] Enter a Number : {re}")
    target_group=groups[int(g_index)]
    #target_group.id = -1001683374540
    target_group_entity = InputPeerChannel(target_group.id,target_group.access_hash)

    print(gr+"[1] add member by user ID\n[2] add member by username ")
    mode = int(input(f"{gr}Input : {re}"))
    n = 0
    l = 0
    print(users)
    print('before for')
    for user in users:
        n += 1
        time.sleep(1)
        try:
            print(n, f"Adding {user['id']}")
            if mode == 1:
                if user['username'] in ["", "None"]:
                    continue
                user_to_add = client.get_input_entity(user['username'])
            elif mode == 2:
                user_to_add = InputPeerUser(user['id'], user['access_hash'])
            else:
                sys.exit(f"{re}[!] Invalid Mode Selected. Please Try Again.")
            client(InviteToChannelRequest(target_group_entity,[user_to_add]))
            print(f"{gr}[+] Waiting for 10-30 Seconds...")
            #n += 1
            #if n == 40:
            #sys.exit(re+"[!] 40 пользователей приглашено.")
            time.sleep(random.randrange(10, 30))
        except PeerFloodError:
            print(re+"[!] Getting Flood Error from telegram. \n[!] Script is stopping now. \n[!] Please try again after some time.")
        except UserPrivacyRestrictedError:
            print(
                f"{re}[!] The user's privacy settings do not allow you to do this. Skipping."
            )
        except Exception:
            traceback.print_exc()
            print(f"{re}[!] Unexpected Error")
            continue


TelegramGoodsInBot>invite_sql copy.py:
#!/usr/bin/env python3
from telethon.sync import TelegramClient, connection
from telethon.tl.functions.messages import GetDialogsRequest
from telethon.tl.types import InputPeerEmpty, InputPeerChannel, InputPeerUser
#from telethon.errors.rpcerrorlist import PeerFloodError, UserPrivacyRestrictedError
from telethon.errors.rpcerrorlist import (UserPrivacyRestrictedError,
                                          UserNotMutualContactError,
                                          FloodWaitError,
                                          PeerFloodError,
                                          UserChannelsTooMuchError,
                                          UserDeactivatedBanError,
                                          PhoneNumberBannedError,
                                          UsernameInvalidError,
                                          ChatWriteForbiddenError)

from telethon.tl.functions.channels import InviteToChannelRequest, JoinChannelRequest
import config
import configparser
import tqdm
import os, sys
import socks
import csv
import traceback
import datetime
import time
import random
import requests, socket
from sutils import *
from tgbot.services.api_sqlite import *

print(type(datetime))

def get_time_str():
    return datetime.now().strftime("%H:%M:%S")

cur_time = datetime.datetime.now()

re="\033[1;31m"
gr="\033[1;32m"
cy="\033[1;36m"

def banner():
    print(f"""
´´´´¶¶¶¶¶¶´´´´´´¶¶¶¶¶¶
´´¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶¶¶¶¶¶
´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶ ´¶¶¶¶¶´
´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´´´¶¶¶¶¶¶¶¶
´´´´´´´´´´´¶¶¶¶
{re}

by rashidovich
        """)

check_phones()

mode=''

cpass=get_all_avtgaccounts()
print(cpass)
target_group = ''
for cp in cpass:
    print(cp)
    try:
        account_id = cp[0]
        api_id = cp[1]
        api_hash = cp[2]
        phone = cp[3]
        wait24field = cp[8]
        print(f"Работаем с аккаунтом:{phone}.")

        if config.PROXY_ENABLED:
            s = socks.socksocket()
            rnd_proxy = random.choice(config.PROXY_IPS).split(":")
            print(f"Подключение к Телеграмм с прокси {rnd_proxy}!")
            client = TelegramClient(phone, api_id, api_hash, proxy=s.set_proxy(socks.HTTP, rnd_proxy[0], rnd_proxy[1]) )
            #client.start(self.phone)
        else:
            print("Подключение к Телеграмм без прокси!")
            client = TelegramClient(phone, api_id, api_hash)
                    #client.start(self.phone)
        client.connect()
        if not client.is_user_authorized():
            client.send_code_request(phone)
            #os.system('clear')
            banner()
            client.sign_in(phone, input(f"{gr}[+] Enter the code for {phone}: {re}"))

    except PhoneNumberBannedError:
        print(f" | Ошибка: аккаунт {account_id} был удалён!")
        update_tgaccounts(account_id, pole="banned")
        continue

    #os.system('clear')
    banner()
    #input_file = sys.argv[1]
    users = []
    state = "created"
    count = 110
    start = 0

    print(sys.argv)
    if sys.argv[1] == 'group': rows = first_toinvite(state, start, count)
    if sys.argv[1] == 'geoparse': rows = firstgeo_toinvite(state, start, count)
    #rows = first_toinvite(state, start, count)

    #with open(input_file, encoding='UTF-8') as f:
    #    rows = csv.reader(f,delimiter=",",lineterminator="\n")
    #next(rows, None)

    for row in rows:
        #if row[2] == "ID": continue
        #if row[1] == "None": continue  #in('restricted', 'notexist', 'invited', )
        #if row[9] is None or len(row[9]) == 0: continue
        if row[9] in('noncontact', 'restricted', 'notexist', 'overg', 'deleted', 'invited'): continue
        print(row)
        user = {
            'acc_id': row[0],
            'username': row[1],
            'id': int(row[2]),
            'access_hash': int(row[3]),
            'name': row[4],
        }
        users.append(user)

    #если установлена группа - не запрашиваем
    if(target_group != ''): print("||| TARGET GROUP PRESENT")
    #чаты пользователя
    chats = []
    last_date = None
    chunk_size = 200
    groups=[]

    result = client(GetDialogsRequest(
        offset_date=last_date,
        offset_id=0,
        offset_peer=InputPeerEmpty(),
        limit=chunk_size,
        hash = 0
    ))
    chats.extend(result.chats)

    for chat in chats:
        try:
            if chat.megagroup== True:
                groups.append(chat)
        except Exception:
            continue

    for i, group in enumerate(groups):
        print(f'{gr}[{cy}{str(i)}{gr}]{cy} - {group.title}|{group.title}')
    print('')
    if (target_group == ''):
        g_index = input(
            f"{gr}[+] Введите номер группы для инвайта пользователей или N : {re}"
        )

    #    return g_index

    #g_index = select_scr_group(client)
    #target_group = ''

    if g_index == 'N':
        g_url = input(
            f"{gr}[+] Введите url или username группы для инвайта пользователей : {re}"
        )
        try:
            group_target = f't.me/{str(g_url)}'
            username = client.get_entity(group_target)
            client(JoinChannelRequest(username))
            print(f'{lg} Зашли в группу на {phone}')
            target_group = group

        except Exception:
            print(gr+'[!] Ошибка входа в группу {phone}'+re)

    else:
        target_group=groups[int(g_index)]

    print("||||||||||")
    print(target_group.title)
    print("||||||||||")

    target_group_entity = InputPeerChannel(target_group.id,target_group.access_hash)

    #if(mode != ''):
    #    print("| Режим выбран")
    #else:
    print(gr+"[1] добавлять в группу по username \n[2] добавлять в группу по user ID ")
    mode = int(input(f"{gr}Введите свой выбор( 1/2 ) : {re}"))
    n = 0
    print(f"Выбрано аккаунтов для инвайта: {len(users)}")

    cur_time = datetime.datetime.now()
    print(f"{str(account_id)}|{str(cur_time)}")
    h = get_tgaccount_statecounts(account_id)
    print(h)
    invited = h[0]
    invited_cs = 0
    #print(h['invited24'])
    not_invited = 0

    for user in users:
        n += 1
        time.sleep(1)
        try:
            print(n, f"Пробуем добавить аккаунт ID {user['id']}")
            if mode == 1:
                if user['username'] == "":
                    update_tgparsex(user['acc_id'], state='nousname')
                    print("NOusName\n")
                    #user_to_add = InputPeerUser(user['id'], user['access_hash'])
                    continue
                if check_dbfor_invited_username(user['username']):
                    print(user['username']+" был приглашен в БД.\n")
                    continue
                user_to_add = client.get_input_entity(user['username'])
            elif mode == 2:
                user_to_add = InputPeerUser(user['id'], user['access_hash'])
            else:
                sys.exit(f"{re}[!] Выбран некорректный режим работы. Попробуйте еще раз.")
            client(InviteToChannelRequest(target_group_entity,[user_to_add]))
            print(user['acc_id'])
            update_tgparsex(user['acc_id'], state='invited')
            update_tgaccounts(account_id, pole='invited24')
            invited += 1
            invited_cs += 1
            print(
                f"{gr}+ И:{invited}/ИК:{invited_cs} | Добавили пользователя: {user['username']}"
            )
            if invited >= 40: #invited_cs >= 5 or
                cur_day = cur_time.day
                cur_hour = cur_time.hour
                print(cur_time.hour)
                #cur_hour = datetime.datetime.now().hour
                #cur_min = datetime.datetime.now().minute
                #cur_sec = datetime.datetime.now().second
                print(f"{cur_time} | Аккаунт {account_id} набрал {config.INV_CNT} инвайтов !")
                print(f"{cur_time} | Аккаунт {account_id} уходит в режим ожидания до {cur_day + 1} числа и {cur_hour + 1} часов!")
                #self.lists.add_check(self.phone, [cur_day + 1, cur_hour + 1, cur_min, cur_sec])
                update_tgaccounts(account_id, pole="waitfor24")
                break

            #n += 1
            #if n == 40:
            #sys.exit(re+"[!] 40 пользователей приглашено.")
            print(f"{gr}[+] Пауза 10-30 секунд...")
            time.sleep(random.randrange(10, 30))
            continue
        except UserPrivacyRestrictedError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} запретил приглашать себя!")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='restricted')
            #self.lists.add_ban(user)
            continue
        except UserChannelsTooMuchError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} ебанутый!")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='overg')
            #self.lists.add_ban(user)
            continue
        except UserDeactivatedBanError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} удалён!")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='deleted')
            continue
        except UserNotMutualContactError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} не взаимный контакт !")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='noncontact')
            continue
        except (ValueError, UsernameInvalidError):
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователя с ником {user} не существует!")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='notexist')
            continue
        except FloodWaitError as e:
            print(
                f"{cur_time} | Ошибка: Таймаут на {e.seconds} секунд, это примерно {round(e.seconds / 60)} минут \n",
                f"За время работы бот успел пригласить {invited} пользователей"
            )
            if config.CHECK_TIMEOUT:
                for _ in range(e.seconds):
                    time.sleep(1)
            else:
                cur_sec = cur_time.second
                sec = e.seconds + cur_sec
                sec = sec % (24 * 3600)
                hour = sec // 3600
                sec %= 3600
                min = sec // 60
                sec %= 60

                print(f"{str(cur_time.hour)}:{str(cur_time.minute)}")
                utime = time.mktime(cur_time.timetuple())
                print(f"{cur_time} | Аккаунт {account_id} уходит в режим ожидания на {hour} часов, {min} минут, {sec} секунд")
                #self.lists.add_check(self.phone, [cur_day, cur_hour+hour, cur_min+min, sec])
                update_tgaccounts(account_id, pole="waitfor24")
                break
        except ChatWriteForbiddenError:
            print(
                f"{cur_time} | Ошибка: чат-цель недоступен, возможно вы не вошли в него!"
            )
            break
        except PeerFloodError as e:
            print(f"{cur_time} | Ошибка: Слишком много запросов!")
            cur_day = cur_time.day
            cur_hour = cur_time.hour
            cur_min = cur_time.minute
            cur_sec = cur_time.second
            print(f"{cur_time} | Аккаунт {account_id} уходит в режим ожидания до {cur_day + 1} числа и {cur_hour+1} часов!")
            #self.lists.add_check(self.phone, [cur_day + 1, cur_hour+1, cur_min, cur_sec])
            update_tgaccounts(account_id, pole="waitfor24")
            break

        except KeyboardInterrupt:
            break

        except Exception:
            print(f"{cur_time} | Неизвестная ошибка: ", sys.exc_info())
            continue


TelegramGoodsInBot>invite_sql.py:
#!/usr/bin/env python3
from telethon.sync import TelegramClient, connection
from telethon.tl.functions.messages import GetDialogsRequest
from telethon.tl.types import InputPeerEmpty, InputPeerChannel, InputPeerUser
#from telethon.errors.rpcerrorlist import PeerFloodError, UserPrivacyRestrictedError
from telethon.errors.rpcerrorlist import (UserPrivacyRestrictedError,
                                          UserNotMutualContactError,
                                          FloodWaitError,
                                          PeerFloodError,
                                          UserChannelsTooMuchError,
                                          UserDeactivatedBanError,
                                          PhoneNumberBannedError,
                                          UsernameInvalidError,
                                          ChatWriteForbiddenError,
                                          ChatAdminRequiredError,
                                          UserBannedInChannelError)

from telethon.tl.functions.channels import InviteToChannelRequest, JoinChannelRequest
import config
import configparser
import tqdm
import os, sys
from sys import stdout
import socks
import csv
import traceback
import datetime
#from pynput import keyboard
import keyboard
import time
import random
import requests, socket
from sutils import *
from tgbot.services.api_sqlite_advert import *

print(type(datetime))

#JUMP_LEFT_SEQ = '\u001b[100D'

def Ctrl_K():
    i = 1
    stopped = True

def callback(keyname):
    global stopped
    print(f'{keyname} was pressed!')
    stopped = True

def get_time_str():
    return datetime.now().strftime("%H:%M:%S")

def enter_group(client, g_url, group):
    group_target = f"t.me/{str(g_url)}"
    username = client.get_entity(group_target)
    client(JoinChannelRequest(username))
    print(f'{lg} Зашли в группу на {phone}')
    return group

def loading(cur):
    print(JUMP_LEFT_SEQ, end='')
    print(f'Прогресс: {cur:0>3}%', end='')
    stdout.flush()
    print()


cur_time = datetime.datetime.now()

re="\033[1;31m"
gr="\033[1;32m"
cy="\033[1;36m"

def banner():
    print(f"""
´´´´¶¶¶¶¶¶´´´´´´¶¶¶¶¶¶
´´¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶¶¶¶¶¶
´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶ ´¶¶¶¶¶´
´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´´´¶¶¶¶¶¶¶¶
´´´´´´´´´´´¶¶¶¶
{re}

by rashidovich
        """)

reset = sys.argv[2]
check_phones(reset="no")

x = 0
group_target = ''
source_group = ''
users = []
chats = []
groups = []
accs_array = []
invited = 0
state = "created"
count = 110
start = 0
iter = 1
target_group=''
mode = ''
source_group_selected = 0
target_group_selected = 0
last_date = None
chunk_size = 200
first_run = 1
print(sys.argv)


#print(gr+"[1] работать целиком \n[2] работать по 5 инвайтов ")
#mode2 = int(input(gr+"Введите свой выбор( 1/2 ) : "+re))
acc_mode = 2
mode2 = 1
gusername = "tea_club_pnz" #"goodnewsrussia1" #"tea_club_pnz" #"goodnewsrussia1" #"pf_ya" ##"shoptelegramg" #pf_ya" #"goodnewsrussia1" #"pf_ya" "pf_ya" # Current chat ID: 5620443733


'''if sys.argv[1] == 'group':
    groupsdb = groups_telegram()
    print(groupsdb)
    s = 0
    for groupdb in groupsdb:
        print(gr+'['+cy+str(s)+gr+']'+cy+str(groupdb[0])+' - '+groupdb[1] +' : '+str(groupdb[2]))
        s+=1

    gso = input(gr+"[+] Выберите группу - введите id : "+re)
    source_group=gso
    source_group_name=groupdb[1]
    source_group_selected = 1'''

group_name = "Накрутка пф"
source_group = 1592040758  #1592040758 #1935533426 #1711920479 #1592040758 #1715536909 #1711920479 #1592040758 ##1691432548 #1520545687 #1557904116 #1224708719 #1520545687 #1640509728 #1697116411
#rows = first_grouptoinvitebyid(source_group, start, count)
rows = first_grouptoreinvite(0, 110) #Пенза реинвайт
if sys.argv[1] == 'geoparse': rows = firstgeo_toinvite(state, start, count)

cpass=get_all_tgaccounts_to_invite()
print(cpass)

#собираем аккаунты для инвайта
for cp in cpass:
    #print(cp)
    if cp[4] in ['wait2', 'banned', 'wait3']: continue
    try:
        account_id = cp[0]
        api_id = cp[1]
        api_hash = cp[2]
        phone = cp[3]
        inv24, send24, iter24  = cp[8], cp[9], cp[13]
        print(f"Работаем с аккаунтом:{phone} | ЕГО время старта: И:{inv24} | C:{send24} | Итер:{iter24} |.")
        stopped = False

        if config.PROXY_ENABLED:
            s = socks.socksocket()
            rnd_proxy = random.choice(config.PROXY_IPS).split(":")
            print(f"Подключение к Телеграмм с прокси {rnd_proxy}!")
            client = TelegramClient(phone, api_id, api_hash, proxy=s.set_proxy(socks.HTTP, rnd_proxy[0], rnd_proxy[1]) )
            client.start()
            print(f'[+] Успешная аутентификация - {phone}')
            current_account_id = account_id
            accs_array.append(cp)
            invited = inv24

        else:
            print("Подключение к Телеграмм без прокси!")
            client = TelegramClient(phone, api_id, api_hash)
            invited = inv24
            client.disconnect()

        client.connect()
        if not client.is_user_authorized():
            banner()
            client.start()
            print(f'[+] Успешная аутентификация - {phone}')

            print(f'[+] Проверяем и входим в группу - {phone}')

        furl = f"t.me/{gusername}"
        gentity = client.get_entity(furl)
        client(JoinChannelRequest(gentity))
        print(f'Вступили в группу: {gentity.title})')
        client.disconnect()
        if first_run == 1:
            client.connect()
        client.connect()

        x += 1
        accs_array.append(cp)
    except PhoneNumberBannedError:
        print(f" | Ошибка: аккаунт {account_id} был удалён!")
        update_tgaccounts(account_id, pole="banned")
        continue
    except FloodWaitError as e:
        print(
            f"{cur_time} | Ошибка: Таймаут на {e.seconds} секунд, это примерно {round(e.seconds / 60)} минут \n"
        )
        if config.CHECK_TIMEOUT:
            for _ in range(e.seconds):
                time.sleep(1)
        else:
            cur_sec = cur_time.second
            sec = e.seconds + cur_sec
            sec = sec % (24 * 3600)
            hour = sec // 3600
            sec %= 3600
            min = sec // 60
            sec %= 60

            print(f"{str(cur_time.hour)}:{str(cur_time.minute)}")
            utime = time.mktime(cur_time.timetuple())
            print(f"{cur_time} | Аккаунт {account_id} уходит в режим ожидания на {hour} часов, {min} минут, {sec} секунд")
            break
    if acc_mode == 1:
        continue

    banner()
    print("Аккаунты в работе:")
    print(accs_array)

    for row in rows:
        if row[2] == "ID": continue
        if row[9] in('noncontact', 'restricted', 'notexist', 'bot', 'overg', 'deleted', 'invited'): continue
        print(row)
        user = {
            'acc_id': row[0],
            'username': row[1],
            'id': int(row[2]),
            'access_hash': int(row[3]),
            'name': row[4],
        }
        users.append(user)

    furl = f"t.me/{gusername}"
    target_group = client.get_entity(furl)
    if(target_group.title != ''): print("||| TARGET GROUP PRESENT")

    print("||||||||||")
    print(target_group.title)
    print("||||||||||")
    target_group_entity = client.get_entity(InputPeerChannel(target_group.id, target_group.access_hash))
    #print(gr+"[1] добавлять в группу по username \n[2] добавлять в группу по user ID ")
    #mode = int(input(gr+"Введите свой выбор( 1/2 ) : "+re))
    mode = 1
    n = 0
    print(f"Выбрано ТГ аккаунтов для инвайта: {len(users)}")
    cur_time = datetime.datetime.now()
    print(f"{str(account_id)}|{str(cur_time)}")
    h = get_tgaccount_statecounts(account_id)
    print(h)
    invited = h[0]
    invited_cs = 0
    f = 0
    not_invited = 0

    for user in users:
        n += 1
        time.sleep(2)
        try:
            if user['username'] != "":
                #checkacc = check_dbfor_invited_username(user['username'])
                if check_dbfor_invited_username(user['username']) == 1:
                    print(user['username']+" был приглашен в БД.\n")
                    continue
                #if checkacc == 0:
                    #print("OK")
            #if int(user['access_hash']) < 0:
            #    print (f"HASH:{int(user['access_hash'])}")
            #    continue
            print(f'Работает аккаyнт: {account_id}')
            print(f'Данные аккаунта: {cp}')
            print(n, f"Пробуем инвайтить аккаунт ID {user['id']}")
            if mode == 1:
                if user['username'] == "":
                    update_tgparsex(user['acc_id'], state='nousname')
                    print("NOusName\n")
                    #user_to_add = InputPeerUser(user['id'], user['access_hash'])
                    continue
                print(user)
                user_to_add = client.get_input_entity(user['username'])
            elif mode == 2:
                user_to_add = InputPeerUser(user['id'], user['access_hash'])
            else:
                sys.exit(f"{re}[!] Выбран некорректный режим работы. Попробуйте еще раз.")
            client(InviteToChannelRequest(target_group_entity,[user_to_add]))
            print(user['acc_id'])
            update_tgparsex(user['acc_id'], state='invited')
            update_tgaccounts(account_id, pole='invited24')

            invited += 1
            invited_cs += 1
            print(
                f"{gr}+ И:{invited}/ИК:{invited_cs} | Добавили пользователя: {user['username']}"
            )
            if invited_cs >= 20 or invited >= 20:
                cur_day = cur_time.day
                cur_hour = cur_time.hour
                print(cur_time.hour)
                print(f"{cur_time} | Аккаунт {account_id} набрал {invited} инвайтов !")
                print(f"{cur_time} | Аккаунт {account_id} уходит в режим ожидания до {cur_day + 1} числа и {cur_hour + 1} часов!")
                print(f'Обновляем данные аккаунта{account_id}')
                update_tgaccounts(account_id, pole="iter24")
                print("|||||=> данные аккаунта обновлены")
                client.disconnect()

                cpass7 = get_all_tgaccounts_to_invite()
                print(cpass7)
                iter += 1
                print(f'Итерация:{iter}')
                for cp7 in cpass7:
                    print(cp7)
                    first_run += 1
                    try:
                        if cp7[13] > 4 or cp7[0] == current_account_id: continue
                        account_id = cp7[0]
                        api_id = cp7[1]
                        api_hash = cp7[2]
                        phone = cp7[3]
                        inv24, send24, iter24  = cp7[8], cp7[9], cp7[13]
                        #update_tgaccounts(account_id, pole="reset")
                        print(f"Работаем с аккаунтом:{phone} | ЕГО время старта: И:{inv24} | C:{send24} | Итер:{iter24} |.")

                        if config.PROXY_ENABLED:
                            s = socks.socksocket()
                            rnd_proxy = random.choice(config.PROXY_IPS).split(":")
                            print(f"Подключение к Телеграмм с прокси {rnd_proxy}!")
                            client = TelegramClient(phone, api_id, api_hash, proxy=s.set_proxy(socks.HTTP, rnd_proxy[0], rnd_proxy[1]) )
                            client.start()
                            print(f'[+] Успешная аутентификация - {phone}')
                        else:
                            print("Подключение к Телеграмм без прокси!")
                            client = TelegramClient(phone, api_id, api_hash)
                            client.start()
                        invited = inv24
                        client.disconnect()

                        client.connect()
                        #пауза после переклбчения аккаунта
                        current_account_id = account_id
                        furl = f"t.me/{gusername}"
                        target_group = client.get_entity(furl)

                        target_group_entity = client.get_entity(InputPeerChannel(target_group.id, target_group.access_hash))
                        if(target_group_entity.title != ''): print("||| TARGET GROUP PRESENT")

                        sleeps = random.randrange(10, 15)
                        print(f"{gr}[+] Пауза 10-15 секунд...{sleeps}")
                        time.sleep(sleeps)
                        break

                    except PhoneNumberBannedError:
                        print(f" | Ошибка: аккаунт {account_id} был удалён!")
                        update_tgaccounts(account_id, pole="banned")
                        continue
                    except FloodWaitError as e:
                        print(
                            f"{cur_time} | Ошибка: Таймаут на {e.seconds} секунд, это примерно {round(e.seconds / 60)} минут \n"
                        )
                        if config.CHECK_TIMEOUT:
                            for _ in range(e.seconds):
                                time.sleep(1)
                        else:
                            cur_sec = cur_time.second
                            sec = e.seconds + cur_sec
                            sec = sec % (24 * 3600)
                            hour = sec // 3600
                            sec %= 3600
                            min = sec // 60
                            sec %= 60

                            print(f"{str(cur_time.hour)}:{str(cur_time.minute)}")
                            utime = time.mktime(cur_time.timetuple())
                            print(f"{cur_time} | Аккаунт {account_id} уходит в режим ожидания на {hour} часов, {min} минут, {sec} секунд")
                #пауза между авторизациями
                sleeps = random.randrange(80, 120)
                print(f"{gr}[+] Пауза 80-120 секунд...{sleeps}")
                time.sleep(sleeps)
                continue

            sleeps = random.randrange(30, 60)
            client.get_entity(furl)
            print(f"{gr}[+] Пауза 30-60 секунд...{sleeps}")

            time.sleep(sleeps)
            continue
        except UserBannedInChannelError:
            print(f'{str(account_id)} в бане!')
            update_tgaccounts(account_id, pole='banned')
            remove_accountx(account_id=account_id)
            break
        except UserPrivacyRestrictedError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} запретил приглашать себя!")
            not_invited += 1
            sleeps = random.randrange(80, 120)
            print(f"{gr}[+] Пауза 80-120 секунд...{sleeps}")
            time.sleep(sleeps)
            #time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='restricted')
            #self.lists.add_ban(user)
            continue
        except UserChannelsTooMuchError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} имеет слишком много групп!")
            not_invited += 1
            sleeps = random.randrange(80, 120)
            print(f"{gr}[+] Пауза 80-120 секунд...{sleeps}")
            time.sleep(sleeps)
            update_tgparsex(user['acc_id'], state='overg')
            #self.lists.add_ban(user)
            continue
        except UserDeactivatedBanError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} удалён!")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='deleted')
            continue
        except UserNotMutualContactError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} не взаимный контакт !")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='noncontact')
            continue
        except ChatAdminRequiredError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} является ботом !")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='bot')
            continue
        except (ValueError, UsernameInvalidError):
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователя с ником {user} не существует!")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='notexist')
            continue
        except FloodWaitError as e:
            print(
                f"{cur_time} | Ошибка: Таймаут на {e.seconds} секунд, это примерно {round(e.seconds / 60)} минут \n",
                f"За время работы бот успел пригласить {invited} пользователей"
            )
            if config.CHECK_TIMEOUT:
                for _ in range(e.seconds):
                    time.sleep(1)
            else:
                cur_sec = cur_time.second
                sec = e.seconds + cur_sec
                sec = sec % (24 * 3600)
                hour = sec // 3600
                sec %= 3600
                min = sec // 60
                sec %= 60

                print(f"{str(cur_time.hour)}:{str(cur_time.minute)}")
                utime = time.mktime(cur_time.timetuple())
                print(f"{cur_time} | Аккаунт {account_id} уходит в режим ожидания на {hour} часов, {min} минут, {sec} секунд")
                #self.lists.add_check(self.phone, [cur_day, cur_hour+hour, cur_min+min, sec])
                update_tgaccounts(account_id, pole="waitfor24")
                break
        except ChatWriteForbiddenError:
            print(
                f"{cur_time} | Ошибка: чат-цель недоступен, возможно вы не вошли в него!"
            )
            break
        except PeerFloodError as e:
            f += 1
            if f >= 11:
                update_tgaccounts(account_id, pole="waitfor24")
                break
                #print("||||")
            print(f"{cur_time} | Ошибка пользователя: Слишком много запросов!")
            cur_day = cur_time.day
            cur_hour = cur_time.hour
            cur_min = cur_time.minute
            cur_sec = cur_time.second
            continue

        except KeyboardInterrupt:
            break

        except Exception:
            print(f"{cur_time} | Неизвестная ошибка: ", sys.exc_info())
            continue


TelegramGoodsInBot>invite_sql2.py:
#!/usr/bin/env python3
from telethon.sync import TelegramClient, connection
from telethon.tl.functions.messages import GetDialogsRequest
from telethon.tl.types import InputPeerEmpty, InputPeerChannel, InputPeerUser
#from telethon.errors.rpcerrorlist import PeerFloodError, UserPrivacyRestrictedError
from telethon.errors.rpcerrorlist import (UserPrivacyRestrictedError,
                                          UserNotMutualContactError,
                                          FloodWaitError,
                                          PeerFloodError,
                                          UserChannelsTooMuchError,
                                          UserDeactivatedBanError,
                                          PhoneNumberBannedError,
                                          UsernameInvalidError,
                                          ChatWriteForbiddenError,
                                          ChatAdminRequiredError,
                                          UserBannedInChannelError)

from telethon.tl.functions.channels import InviteToChannelRequest, JoinChannelRequest
import config
import configparser
import tqdm
import os, sys
from sys import stdout
import socks
import csv
import traceback
import datetime
import time
import random
import requests, socket
from sutils import *
from tgbot.services.api_sqlite import *

print(type(datetime))

#JUMP_LEFT_SEQ = '\u001b[100D'

def get_time_str():
    return datetime.now().strftime("%H:%M:%S")

def enter_group(client, g_url, group):
    group_target = f"t.me/{str(g_url)}"
    username = client.get_entity(group_target)
    client(JoinChannelRequest(username))
    print(f'{lg} Зашли в группу на {phone}')
    return group

def loading(cur):
    print(JUMP_LEFT_SEQ, end='')
    print(f'Прогресс: {cur:0>3}%', end='')
    stdout.flush()
    print()

cur_time = datetime.datetime.now()

re="\033[1;31m"
gr="\033[1;32m"
cy="\033[1;36m"

def banner():
    print(f"""
´´´´¶¶¶¶¶¶´´´´´´¶¶¶¶¶¶
´´¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶¶¶¶¶¶
´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶ ´¶¶¶¶¶´
´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´´´¶¶¶¶¶¶¶¶
´´´´´´´´´´´¶¶¶¶
{re}

by rashidovich
        """)

check_phones()

group_target = ''
source_group = ''
users = []
chats = []
groups = []
invited = 0
state = "created"
count = 110
start = 0
target_group=''
mode = ''
source_group_selected = 0
target_group_selected = 0
last_date = None
chunk_size = 200
print(sys.argv)

print(gr+"[1] работать целиком \n[2] работать по 5 инвайтов ")
mode2 = int(input(f"{gr}Введите свой выбор( 1/2 ) : {re}"))

#cpass=get_all_tgaccounts_time()
cpass=get_all_tgaccounts_time_wb()
print(cpass)

#подключаемся к аккаунту по времени
for cp in cpass:
    print(cp)
    if cp[4] in ['wait2', 'banned', 'wait3']: continue
    try:
        account_id = cp[0]
        api_id = cp[1]
        api_hash = cp[2]
        phone = cp[3]
        wait24field = cp[8]
        print(f"Работаем с аккаунтом:{phone} | ЕГО время старта: {wait24field}.")

        if config.PROXY_ENABLED:
            s = socks.socksocket()
            rnd_proxy = random.choice(config.PROXY_IPS).split(":")
            print(f"Подключение к Телеграмм с прокси {rnd_proxy}!")
            client = TelegramClient(phone, api_id, api_hash, proxy=s.set_proxy(socks.HTTP, rnd_proxy[0], rnd_proxy[1]) )
            client.start()
            print(f'[+] Успешная аутентификация - {phone}')
            client.disconnect()

        else:
            print(f"Подключение к Телеграмм без прокси!")
            client = TelegramClient(phone, api_id, api_hash)

        client.connect()
        if not client.is_user_authorized():
            banner()
            client.start()
            print(f'[+] Успешная аутентификация - {phone}')
            client.disconnect()
            client.connect()

    except PhoneNumberBannedError:
        print(f" | Ошибка: аккаунт {account_id} был удалён!")
        update_tgaccounts(account_id, pole="banned")
        continue
    except FloodWaitError as e:
        print(
            f"{cur_time} | Ошибка: Таймаут на {e.seconds} секунд, это примерно {round(e.seconds / 60)} минут \n"
        )
        if config.CHECK_TIMEOUT:
            for _ in range(e.seconds):
                time.sleep(1)
        else:
            cur_sec = cur_time.second
            sec = e.seconds + cur_sec
            sec = sec % (24 * 3600)
            hour = sec // 3600
            sec %= 3600
            min = sec // 60
            sec %= 60

            print(f"{str(cur_time.hour)}:{str(cur_time.minute)}")
            utime = time.mktime(cur_time.timetuple())
            print(f"{cur_time} | Аккаунт {account_id} уходит в режим ожидания на {hour} часов, {min} минут, {sec} секунд")
            break

    #os.system('clear')
    banner()

    if sys.argv[1] == 'group':
        groupsdb = groups_telegram()
        print(groupsdb)
        for s, groupdb in enumerate(groupsdb):
            print(f'{gr}[{cy}{str(s)}{gr}]{cy} - {groupdb[1]}')
        gso = input(f"{gr}[+] Выберите группу - введите наименование : {re}")
        source_group=gso
        source_group_selected = 1

        rows = first_grouptoinvite(source_group, start, count)

    if sys.argv[1] == 'geoparse': rows = firstgeo_toinvite(state, start, count)

    for row in rows:
        if row[2] == "ID": continue
        if row[9] in('noncontact', 'restricted', 'notexist', 'bot', 'overg', 'deleted', 'invited'): continue
        print(row)
        user = {
            'acc_id': row[0],
            'username': row[1],
            'id': int(row[2]),
            'access_hash': int(row[3]),
            'name': row[4],
        }
        users.append(user)

    if(target_group != ''): print("||| TARGET GROUP PRESENT")

    result = client(GetDialogsRequest(
        offset_date=last_date,
        offset_id=0,
        offset_peer=InputPeerEmpty(),
        limit=chunk_size,
        hash = 0
    ))
    chats.extend(result.chats)
    print(chats)

    for chat in chats:
        try:
            if chat.megagroup== True:
                groups.append(chat)
        except Exception:
            continue

    print(groups)
    for i, group in enumerate(groups):
        print(f'{gr}[{cy}{str(i)}{gr}]{cy} - {group.title}|{group.title}')
        if group.title == gso:
            clientingroup = 1
            target_group = client.get_entity(group.id)
            client(JoinChannelRequest(target_group))
    g_index = ''
    if (group_target == ''):
        g_index = input(
            f"{gr}[+] Введите номер группы для инвайта пользователей или N : {re}"
        )
        if g_index != 'N': target_group=groups[int(g_index)]

    if g_index == 'N':
        g_url = input(
            f"{gr}[+] Введите url или username группы для инвайта пользователей : {re}"
        )
        try:
            group_target = f"t.me/{str(g_url)}"
            username = client.get_entity(group_target)
            client(JoinChannelRequest(username))
            print(f'{lg} Зашли в группу на {phone}')
            target_group = username
        except Exception:
            print(gr+'[!] Ошибка входа в группу {phone}'+re)

    print("||||||||||")
    print(target_group.title)
    print("||||||||||")
    target_group_entity = client.get_entity(InputPeerChannel(target_group.id, target_group.access_hash))
    print(gr+"[1] добавлять в группу по username \n[2] добавлять в группу по user ID ")
    mode = int(input(f"{gr}Введите свой выбор( 1/2 ) : {re}"))
    n = 0
    print(f"Выбрано ТГ аккаунтов для инвайта: {len(users)}")
    cur_time = datetime.datetime.now()
    print(f"{str(account_id)}|{str(cur_time)}")
    h = get_tgaccount_statecounts(account_id)
    print(h)
    invited = h[0]
    invited_cs = 0
    f = 0
    not_invited = 0
    for user in users:
        n += 1
        time.sleep(2)
        try:
            print(n, f"Пробуем добавить аккаунт ID {user['id']}")
            if mode == 1:
                if user['username'] == "":
                    update_tgparsex(user['acc_id'], state='nousname')
                    print("NOusName\n")
                    #user_to_add = InputPeerUser(user['id'], user['access_hash'])
                    continue
                if check_dbfor_invited_username(user['username']):
                    print(user['username']+" был приглашен в БД.\n")
                    continue
                user_to_add = client.get_input_entity(user['username'])
            elif mode == 2:
                user_to_add = InputPeerUser(user['id'], user['access_hash'])
            else:
                sys.exit(f"{re}[!] Выбран некорректный режим работы. Попробуйте еще раз.")
            client(InviteToChannelRequest(target_group_entity,[user_to_add]))
            print(user['acc_id'])
            update_tgparsex(user['acc_id'], state='invited')
            update_tgaccounts(account_id, pole='invited24')

            invited += 1
            invited_cs += 1
            print(
                f"{gr}+ И:{invited}/ИК:{invited_cs} | Добавили пользователя: {user['username']}"
            )
            if invited >= 40:
                cur_day = cur_time.day
                cur_hour = cur_time.hour
                print(cur_time.hour)
                print(f"{cur_time} | Аккаунт {account_id} набрал {config.INV_CNT} инвайтов !")
                print(f"{cur_time} | Аккаунт {account_id} уходит в режим ожидания до {cur_day + 1} числа и {cur_hour + 1} часов!")
                update_tgaccounts(account_id, pole="waitfor24")
                break

            sleeps = random.randrange(80, 120)
            print(f"{gr}[+] Пауза 80-120 секунд...{str(sleeps)}")
            time.sleep(sleeps)
            continue
        except UserBannedInChannelError:
            print(str(account_id) + ' в бане!')
            update_tgaccounts(account_id, pole='banned')
            remove_accountx(account_id=account_id)
            break
        except UserPrivacyRestrictedError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} запретил приглашать себя!")
            not_invited += 1
            sleeps = random.randrange(80, 120)
            print(gr+"[+] Пауза 80-120 секунд..."+ str(sleeps))
            time.sleep(sleeps)
            #time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='restricted')
            #self.lists.add_ban(user)
            continue
        except UserChannelsTooMuchError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} имеет слишком много групп!")
            not_invited += 1
            sleeps = random.randrange(80, 120)
            print(gr+"[+] Пауза 80-120 секунд..."+ str(sleeps))
            time.sleep(sleeps)
            update_tgparsex(user['acc_id'], state='overg')
            #self.lists.add_ban(user)
            continue
        except UserDeactivatedBanError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} удалён!")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='deleted')
            continue
        except UserNotMutualContactError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} не взаимный контакт !")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='noncontact')
            continue
        except ChatAdminRequiredError:
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователь {user} является ботом !")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='bot')
            continue
        except (ValueError, UsernameInvalidError):
            print(f"{cur_time} | Ошибка: {user} не приглашён!")
            print(f"Пользователя с ником {user} не существует!")
            not_invited += 1
            time.sleep(config.ERR_KD)
            update_tgparsex(user['acc_id'], state='notexist')
            continue
        except FloodWaitError as e:
            print(
                f"{cur_time} | Ошибка: Таймаут на {e.seconds} секунд, это примерно {round(e.seconds / 60)} минут \n",
                f"За время работы бот успел пригласить {invited} пользователей"
            )
            if config.CHECK_TIMEOUT:
                for _ in range(e.seconds):
                    time.sleep(1)
            else:
                cur_sec = cur_time.second
                sec = e.seconds + cur_sec
                sec = sec % (24 * 3600)
                hour = sec // 3600
                sec %= 3600
                min = sec // 60
                sec %= 60

                print(str(cur_time.hour)+":"+str(cur_time.minute))
                utime = time.mktime(cur_time.timetuple())
                print(f"{cur_time} | Аккаунт {account_id} уходит в режим ожидания на {hour} часов, {min} минут, {sec} секунд")
                #self.lists.add_check(self.phone, [cur_day, cur_hour+hour, cur_min+min, sec])
                update_tgaccounts(account_id, pole="waitfor24")
                break
        except ChatWriteForbiddenError:
            print(
                f"{cur_time} | Ошибка: чат-цель недоступен, возможно вы не вошли в него!"
            )
            break
        except PeerFloodError as e:
            f += 1
            if f >= 3:
                update_tgaccounts(account_id, pole="waitfor24")
                break
            print(f"{cur_time} | Ошибка пользователя: Слишком много запросов!")
            cur_day = cur_time.day
            cur_hour = cur_time.hour
            cur_min = cur_time.minute
            cur_sec = cur_time.second
            continue

        except KeyboardInterrupt:
            break

        except Exception:
            print(f"{cur_time} | Неизвестная ошибка: ", sys.exc_info())
            continue


TelegramGoodsInBot>invite.py:
#!/usr/bin/env python3
from telethon.sync import TelegramClient, connection
from telethon.tl.functions.messages import GetDialogsRequest
from telethon.tl.types import InputPeerEmpty, InputPeerChannel, InputPeerUser
from telethon.errors.rpcerrorlist import PeerFloodError, UserPrivacyRestrictedError
from telethon.tl.functions.channels import InviteToChannelRequest
import configparser
import os, sys
import csv
import traceback
import time
import random
import requests, socket
from tgbot.services.api_sqlite import *



re="\033[1;31m"
gr="\033[1;32m"
cy="\033[1;36m"

def banner():
    print(f"""
´´´´¶¶¶¶¶¶´´´´´´¶¶¶¶¶¶
´´¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶¶¶¶¶¶
´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶ ´¶¶¶¶¶´
´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´´´¶¶¶¶¶¶¶¶
´´´´´´´´´´´¶¶¶¶
{re}

by rikudo
        """)
        

cpass=get_all_tgaccounts()
print(cpass)
chunk_size = 200
for cp in cpass:
    print(cp)

    #подлючение к ТГ
    try:
        #api_id = cpass['cred']['id']
        #api_hash = cpass['cred']['hash']
        #phone = cpass['cred']['phone']

        api_id = cp[1]
        api_hash = cp[2]
        phone = cp[3]

        #api_id = cpass['tg_api_id']
        #api_hash = cpass['tg_api_hash']
        #phone = cpass['phone']
        client = TelegramClient(phone, api_id, api_hash)
        #client = TelegramClient(phone, api_id, api_hash)
    except KeyError:
        os.system('clear')
        print(re+"[!] run python3 setup.py first !!\n")
        sys.exit(1)

    client.connect()
    if not client.is_user_authorized():
        client.send_code_request(phone)
        os.system('clear')
        banner()
        client.sign_in(phone, input(f'{gr}[+] Enter the code: {re}'))

    os.system('clear')
    banner()
    input_file = sys.argv[1]
    users = []

    with open(input_file, encoding='UTF-8') as f:
        rows = csv.reader(f,delimiter=",",lineterminator="\n")
        next(rows, None)
        for row in rows:
            user = {
                'username': row[0],
                'id': int(row[1]),
                'access_hash': int(row[2]),
                'name': row[3],
            }
            users.append(user)



    chats = []
    last_date = None
    groups=[]

    result = client(GetDialogsRequest(
                 offset_date=last_date,
                 offset_id=0,
                 offset_peer=InputPeerEmpty(),
                 limit=chunk_size,
                 hash = 0
             ))
    chats.extend(result.chats)

    for chat in chats:
        try:
            if chat.megagroup== True:
                groups.append(chat)
        except Exception:
            continue

    for i, group in enumerate(groups):
        print(f'{gr}[{cy}{str(i)}{gr}]{cy} - {group.title}')
    print(f'{gr}[+] Choose a group to add members')
    g_index = input(f"{gr}[+] Enter a Number : {re}")
    target_group=groups[int(g_index)]

    target_group_entity = InputPeerChannel(target_group.id,target_group.access_hash)

    print(gr+"[1] add member by user ID\n[2] add member by username ")
    mode = int(input(f"{gr}Input : {re}"))
    n = 0
    print(users)
    print('before for')
    for user in users:
        n += 1
        time.sleep(1)
        try:
            print(n, f"Adding {user['id']}")
            if mode == 1:
                if user['username'] == "":
                    continue
                user_to_add = client.get_input_entity(user['username'])
            elif mode == 2:
                user_to_add = InputPeerUser(user['id'], user['access_hash'])
            else:
                sys.exit(f"{re}[!] Invalid Mode Selected. Please Try Again.")
            client(InviteToChannelRequest(target_group_entity,[user_to_add]))
            print(f"{gr}[+] Waiting for 10-30 Seconds...")

                #n += 1
                #if n == 40:
                #sys.exit(re+"[!] 40 пользователей приглашено.")
            time.sleep(random.randrange(10, 30))
        except PeerFloodError:
            print(re+"[!] Getting Flood Error from telegram. \n[!] Script is stopping now. \n[!] Please try again after some time.")
        except UserPrivacyRestrictedError:
            print(
                f"{re}[!] The user's privacy settings do not allow you to do this. Skipping."
            )
        except Exception:
            traceback.print_exc()
            print(f"{re}[!] Unexpected Error")


TelegramGoodsInBot>license.md:
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

TelegramGoodsInBot>lo_geo.py:
#!/usr/bin/env python3
import os, sys
import csv
import traceback
import glob
from tgbot.services.api_sqlite import *

woman_names = ("Агафья",
               "Аглая",
               "Агния",
               "Агриппина",
               "Аза",
               "Акулина",
               "Алевтина",
               "Александра",
               "Алина",
               "Алла",
               "Анастасия",
               "Ангелина",
               "Анжела",
               "Анжелика",
               "Анна",
               "Антонина",
               "Анфиса",
               "Валентина",
               "Валерия",
               "Варвара",
               "Василиса",
               "Вера",
               "Вероника",
               "Виктория",
               "Галина",
               "Глафира",
               "Гликерия",
               "Дана",
               "Дарья",
               "Евгения",
               "Евдокия",
               "Евлалия",
               "Евлампия",
               "Евпраксия",
               "Евфросиния",
               "Екатерина",
               "Елена",
               "Елизавета",
               "Епистима",
               "Ермиония",
               "Жанна",
               "Зинаида",
               "Злата",
               "Зоя",
               "Инга",
               "Инесса",
               "Инна",
               "Иоанна",
               "Ираида",
               "Ирина",
               "Ия",
               "Капитолина",
               "Карина",
               "Каролина",
               "Кира",
               "Клавдия",
               "Ксения",
               "Лада",
               "Лариса",
               "Лидия",
               "Лилия",
               "Любовь",
               "Людмила",
               "Маргарита",
               "Марина",
               "Мария",
               "Марфа",
               "Матрёна",
               "Милица",
               "Мирослава",
               "Надежда",
               "Наталья",
               "Нина",
               "Нонна",
               "Оксана",
               "Октябрина",
               "Олимпиада",
               "Ольга",
               "Павлина",
               "Пелагея",
               "Пинна",
               "Полина",
               "Прасковья",
               "Рада",
               "Раиса",
               "Регина",
               "Римма",
               "Рогнеда",
               "Руслана",
               "Светлана",
               "Серафима",
               "Снежана",
               "София",
               "Таисия",
               "Тамара",
               "Татьяна",
               "Улита",
               "Ульяна",
               "Урсула",
               "Фаина",
               "Феврония",
               "Фёкла",
               "Феодора",
               "Целестина",
               "Юлия",
               "Яна",
               "Ярослава")

print(woman_names)

re="\033[1;31m"
gr="\033[1;32m"
cy="\033[1;36m"

def banner():
    print(f"""
´´´´¶¶¶¶¶¶´´´´´´¶¶¶¶¶¶
´´¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶¶¶¶¶¶
´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶ ´¶¶¶¶¶´
´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´´´¶¶¶¶¶¶¶¶
´´´´´´´´´´´¶¶¶¶
{re}

by rashidovich
        """)

print("TEST")
#читаем список пользователей для инвайта
#os.system('clear')
banner()
#input_file = sys.argv[1]
users = []
path = "/var/local/bot3101f/only_geo*.csv"
print(path)

for file in glob.glob(path):
    with open(file, encoding='UTF-8') as f:
        rows = csv.reader(f,delimiter=",",lineterminator="\n")
        next(rows, None)
        #print(len(rows))

        for row in rows:
            if row[4] is None: continue
            if row[4] == "": continue
            if row[4] == "username": continue
            if row[4] == "None": continue
            if check_dbfor_username(row[4]):
                print(row[4]+" есть в БД.\n")
                continue
            #print(row)
            user = {
                'id': row[0],
                'access_hash': row[1],
                'name': f"{row[2]} {row[3]}",
                'username': row[4],
                'source': 'geoparse',
            }
            try:
                username = user['username']
                if check_dbfor_username(row[4]): continue
                usid = user['id']
                usah = user['access_hash']
                name = user['name']
                source = "geoparse"
                state = "created"
                groupname = "REG_PENZA"
                groupid = 70077
                tag = "GEO_PNZ"
                #print(username)
                if row[2] in woman_names: print(row[2])
                add_tgacc_todb(username,usid,usah,name,source,groupname,groupid,tag,state)

            except Exception:
                traceback.print_exc()
                print(f"{re}[!] Неизвестная ошибка")
                continue

            users.append(user)
    #sleep(30)
    print(f"Загружено:{len(users)} пользователей.")
TelegramGoodsInBot>lo_groups.py:
#!/usr/bin/env python3
from telethon.sync import TelegramClient, connection
from telethon.tl.functions.messages import GetDialogsRequest
from telethon.tl.types import InputPeerEmpty, InputPeerChannel, InputPeerUser, ChannelParticipantsRecent
#from telethon.errors.rpcerrorlist import PeerFloodError, UserPrivacyRestrictedError
from telethon.errors.rpcerrorlist import (UserPrivacyRestrictedError,
                                          UserNotMutualContactError,
                                          FloodWaitError,
                                          PeerFloodError,
                                          UserChannelsTooMuchError,
                                          UserDeactivatedBanError,
                                          PhoneNumberBannedError,
                                          UsernameInvalidError,
                                          ChatWriteForbiddenError)

from telethon.tl.functions.channels import InviteToChannelRequest, JoinChannelRequest, GetParticipantsRequest
import config
import configparser
import tqdm
import os, sys
import socks
import csv
import traceback
from colorama import init, Fore
import datetime
import time
import random
import requests, socket
from sutils import *
from tgbot.services.api_sqlite_advert import *

print(type(datetime))

def get_time_str():
    return datetime.now().strftime("%H:%M:%S")

cur_time = datetime.datetime.now()

re="\033[1;31m"
gr="\033[1;32m"
cy="\033[1;36m"

lg = Fore.LIGHTGREEN_EX
w = Fore.WHITE
cy = Fore.CYAN
ye = Fore.YELLOW
r = Fore.RED
n = Fore.RESET
colors = [lg, r, w, cy, ye]


def banner():
    print(f"""
´´´´¶¶¶¶¶¶´´´´´´¶¶¶¶¶¶
´´¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶¶¶¶¶¶
´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶ ´¶¶¶¶¶´
´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´´´¶¶¶¶¶¶¶¶
´´´´´´´´´´´¶¶¶¶
{re}

by rashidovich
        """)

check_phones()

cpass=get_all_avtgaccounts()
print(cpass)
for cp in cpass:
    print(cp)
    try:
        account_id = cp[0]
        api_id = cp[1]
        api_hash = cp[2]
        phone = cp[3]
        wait24field = cp[8]
        print(f"Работаем с аккаунтом:{phone}.")

        if config.PROXY_ENABLED:
            s = socks.socksocket()
            rnd_proxy = random.choice(config.PROXY_IPS).split(":")
            print(f"Подключение к Телеграмм с прокси {rnd_proxy}!")
            client = TelegramClient(phone, api_id, api_hash, proxy=s.set_proxy(socks.HTTP, rnd_proxy[0], rnd_proxy[1]) )
            #client.start(self.phone)
        else:
            print("Подключение к Телеграмм без прокси!")
            client = TelegramClient(phone, api_id, api_hash)
                    #client.start(self.phone)
        client.connect()
        if not client.is_user_authorized():
            client.send_code_request(phone)
            #os.system('clear')
            banner()
            client.sign_in(phone, input(f"{gr}[+] Enter the code for {phone}: {re}"))

    except PhoneNumberBannedError:
        print(f" | Ошибка: аккаунт {account_id} был удалён!")
        update_tgaccounts(account_id, pole="banned")
        continue

    chats = []
    last_date = None
    chunk_size = 200
    groups=[]

#def select_scr_group(client):
    result = client(GetDialogsRequest(
                 offset_date=last_date,
                 offset_id=0,
                 offset_peer=InputPeerEmpty(),
                 limit=chunk_size,
                 hash = 0
             ))
    chats.extend(result.chats)

    for chat in chats:
        try:
            if chat.megagroup== True:
                groups.append(chat)
        except Exception:
            continue

    print(
        f'{gr}[+] Выберите группу для сбора участников из группу на аккаунте {phone}:{re}'
    )
    for i, g in enumerate(groups):
        print(f'{gr}[{cy}{str(i)}{gr}]{cy} - {g.title}')
    print('')
    g_index = input(
        f"{gr}[+] Введите номер группы для сбора пользователей или N : {re}"
    )

#    return g_index

#g_index = select_scr_group(client)
    target_group = ''

    if g_index == 'N':
        g_url = input(
            f"{gr}[+] Введите url или username группы для сбора пользователей : {re}"
        )
        try:
            group = f't.me/{str(g_url)}'
            username = client.get_entity(group)
            client(JoinChannelRequest(username))
            print(f'{lg} Зашли в группу на {phone}')
            target_group = username

        except Exception:
            print(f'{r} Ошибка входа в группу {phone}')
            continue


    else:
        target_group=groups[int(g_index)]

    print("||||||||||")
    print(target_group.title)
    print("||||||||||")

    channel = target_group

    print(f'{gr}[+] Собираем пользователей...')
    time.sleep(1)

#all_participants = self.client.get_participants(target_Group)

#all_participants = []
#while_condition = True
#my_filter = ChannelParticipantsSearch('')
#offset = 0
#while while_condition:
#	participants = self.client(GetParticipantsRequest(channel=target_Group,  offset= offset, filter = my_filter, limit=200, hash=0))
#	all_participants.extend(participants.users)
#	offset += len(participants.users)
#	print(len(participants.users))
#	if len(participants.users) < 1 :
#		while_condition = False

    offset = 0
    limit = 100
    all_participants = []
    #channel = 'building_work'
    while True:
        participants = client(GetParticipantsRequest(
            channel, ChannelParticipantsRecent(), offset, limit,
            hash=0
        ))
        if not participants.users:
            break
        all_participants.extend(participants.users)
        offset += len(participants.users)
        print(offset)

    print(f'{gr}[+] Сохраняем в БД...')
    time.sleep(1)
    with open("members.csv","w",encoding='UTF-8') as f:
        writer = csv.writer(f,delimiter=",",lineterminator="\n")
        writer.writerow(['username','user id', 'access hash','name','group', 'group id'])
        #print(f"Кол-во участников группы:"+ len(all_participants))
        for user in all_participants:
            if user.username is None: continue
            if user.username == "": continue
            if check_dbfor_username(user.username): continue
            username = user.username or ""
            first_name = user.first_name or ""
            last_name = user.last_name or ""
            name = f'{first_name} {last_name}'.strip()
            state = "created"
            groupname = target_group.title
            groupid = target_group.id
            usah = user.access_hash
            usid = user.id
            source = 'groups'
            tag = target_group.title

            #writer.writerow([username,user.id,user.access_hash,name,target_group.title, target_group.id])
            add_tgacc_todb(username,usid,usah,name,source,groupname,groupid,tag,state)

    print(f'{gr}[+] Пользователи успешно собраны.')
TelegramGoodsInBot>load_geo.py:
#!/usr/bin/env python3
#from telethon.sync import TelegramClient, connection
#from telethon.tl.functions.messages import GetDialogsRequest
#from telethon.tl.types import InputPeerEmpty, InputPeerChannel, InputPeerUser
#from telethon.errors.rpcerrorlist import PeerFloodError, UserPrivacyRestrictedError
#from telethon.tl.functions.channels import InviteToChannelRequest
import configparser
import os, sys
import csv
import traceback
import time
import random
import requests, socket
from tgbot.services.api_sqlite import *

woman_names = ['Агафья',
               'Аглая',
               'Агния',
               'Агриппина',
               'Аза',
               'Акулина',
               'Алевтина',
               'Александра',
               'Алина',
               'Алла',
               'Анастасия',
               'Ангелина',
               'Анжела',
               'Анжелика',
               'Анна',
               'Антонина',
               'Анфиса',
               'Валентина',
               'Валерия',
               'Варвара',
               'Василиса',
               'Вера',
               'Вероника',
               'Виктория',
               'Галина',
               'Глафира',
               'Гликерия',
               'Дана',
               'Дарья',
               'Евгения',
               'Евдокия',
               'Евлалия',
               'Евлампия',
               'Евпраксия',
               'Евфросиния',
               'Екатерина',
               'Елена',
               'Елизавета',
               'Епистима',
               'Ермиония',
               'Жанна',
               'Зинаида',
               'Злата',
               'Зоя',
               'Инга',
               'Инесса',
               'Инна',
               'Иоанна',
               'Ираида',
               'Ирина',
               'Ия',
               'Капитолина',
               'Карина',
               'Каролина',
               'Кира',
               'Клавдия',
               'Ксения',
               'Лада',
               'Лариса',
               'Лидия',
               'Лилия',
               'Любовь',
               'Людмила',
               'Маргарита',
               'Марина',
               'Мария',
               'Марфа',
               'Матрёна',
               'Милица',
               'Мирослава',
               'Надежда',
               'Наталья',
               'Нина',
               'Нонна',
               'Оксана',
               'Октябрина',
               'Олимпиада',
               'Ольга',
               'Павлина',
               'Пелагея',
               'Пинна',
               'Полина',
               'Прасковья',
               'Рада',
               'Раиса',
               'Регина',
               'Римма',
               'Рогнеда',
               'Руслана',
               'Светлана',
               'Серафима',
               'Снежана',
               'София',
               'Таисия',
               'Тамара',
               'Татьяна',
               'Улита',
               'Ульяна',
               'Урсула',
               'Фаина',
               'Феврония',
               'Фёкла',
               'Феодора',
               'Целестина',
               'Юлия',
               'Яна',
               'Ярослава']
#print(woman_names)

re="\033[1;31m"
gr="\033[1;32m"
cy="\033[1;36m"

def banner():
    print(f"""
´´´´¶¶¶¶¶¶´´´´´´¶¶¶¶¶¶
´´¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶¶¶¶¶¶
´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶ ´¶¶¶¶¶´
´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´´´¶¶¶¶¶¶¶¶
´´´´´´´´´´´¶¶¶¶
{re}

by rashidovich
        """)

    #читаем список пользователей для инвайта
    os.system('clear')
    banner()
    input_file = sys.argv[1]
    users = []
    with open(input_file, encoding='UTF-8') as f:
        rows = csv.reader(f,delimiter=",",lineterminator="\n")
        next(rows, None)
        #print(len(rows))

        for row in rows:
            user = {
                'id': row[0],
                'access_hash': row[1],
                'name': f"{row[2]} {row[3]}",
                'username': row[4],
                'source': 'geoparse',
            }
            try:
                username = user['username']
                usid = user['id']
                usah = user['access_hash']
                name = user['name']
                source = "geoparse"
                state = ""
            except Exception:
                traceback.print_exc()
                print(f"{re}[!] Unexpected Error")
                continue

            users.append(user)

    print(f"Загружено:{len(users)} пользователей.")
TelegramGoodsInBot>main.py:
# - *- coding: utf- 8 - *-
import os
import sys
import asyncio

import colorama
import aiogram
from aiogram import Dispatcher
from aiogram import executor
from colorama import Fore

from tgbot.data.config import get_admins
from tgbot.handlers import dp
from tgbot.loader import scheduler
from tgbot.middlewares import setup_middlewares
from tgbot.services.api_session import RequestsSession
from tgbot.services.api_sqlite import create_dbx
from tgbot.services.regular import send_message_start
from tgbot.utils.misc.bot_commands import set_commands
from tgbot.utils.misc.bot_logging import bot_logger
from tgbot.utils.misc_functions import check_update, check_bot_data, on_startup_notify, update_profit_day, \
    update_profit_week, autobackup_admin, post_every_hour, post_every_eighteen, post_every_half_hour, \
    post_half_eight, post_evening_events, posts3_every_hour, reinvite_sellers_by_city, sellers_news, catch_transactions, fetch_token


# Запуск шедулеров
async def scheduler_start():
    #scheduler.add_job(send_message_start, 'interval', seconds=600)
    #scheduler.add_job(post_every_hour, "cron", hour=21, minute=43)
    #scheduler.add_job(sellers_news, "cron", hour=15, minute=9)
    #scheduler.add_job(reinvite_sellers_by_city, "cron", hour=11, minute=20)
    #scheduler.add_job(posts3_every_hour, "interval", minutes=60)
    #scheduler.add_job(post_every_hour, "interval", minutes=30)
    #scheduler.add_job(post_half_eight, "cron", hour=18, minute=30)
    #scheduler.add_job(post_evening_events, "cron", hour=22, minute=45)
    #scheduler.add_job(post_evening_events, "cron", hour=19, minute=50)
    #scheduler.add_job(post_half_eight, "interval", seconds=30)
    #scheduler.add_job(post_every_eighteen, "cron", hour=17)
    #scheduler.add_job(post_half_eight, "cron", hour=19, minute=35)
    #scheduler.add_job(post_evening_events, "cron", hour=10, minute = 40)
    #scheduler.add_job(check_order_messages, 'interval', seconds=600)
    #scheduler.add_job(catch_transactions, "cron", hour=00)
    #scheduler.add_job(fetch_token(user_login="raclear", password="123456"), 'interval', seconds=30)
    scheduler.add_job(update_profit_week, "cron", day_of_week="mon", hour=00, minute=1)
    scheduler.add_job(update_profit_day, "cron", hour=00)
    scheduler.add_job(autobackup_admin, "cron", hour=00)

# Выполнение функции после запуска бота
async def on_startup(dp: Dispatcher):
    await dp.bot.delete_webhook()
    await dp.bot.get_updates(offset=-1)
    dp.bot['rSession'] = RequestsSession()

    await set_commands(dp)
    await check_bot_data()
    await scheduler_start()
    await on_startup_notify(dp)
    #asyncio.run(fetch_token(user_login="raclear", password="123456"))

    bot_logger.exception("BOT WAS STARTED")
    print(f"{Fore.LIGHTYELLOW_EX}~~~~~ Bot was started ~~~~~")
    print(f"{Fore.LIGHTBLUE_EX}~~~~~ TG Developer: @raclear ~~~~~")
    print(Fore.RESET)

    if len(get_admins()) == 0: print("***** ENTER ADMIN ID IN settings.ini *****")


# Выполнение функции после выключения бота
async def on_shutdown(dp: Dispatcher):
    rSession: RequestsSession = dp.bot['rSession']
    await rSession.close()
    #
    await dp.storage.close()
    await dp.storage.wait_closed()
    await (await dp.bot.get_session()).close()
    #
    if sys.platform.startswith("win"):
        os.system("cls")
    else:
        os.system("clear")


if __name__ == "__main__":
    create_dbx()

    scheduler.start()
    setup_middlewares(dp)

    executor.start_polling(dp, on_startup=on_startup, on_shutdown=on_shutdown)

TelegramGoodsInBot>main.sh:
#!/bin/bash
cd autoshopDjimbo3.1&&python3.9 main.py
TelegramGoodsInBot>manage.py:
import requests
from telethon.sync import TelegramClient
from telethon.errors.rpcerrorlist import PhoneNumberBannedError
import pickle, pyfiglet
from colorama import init, Fore
import os, random
import subprocess
from time import sleep, time
#from tgbot.services.api_sqlite import *
from tgbot.services.api_sqlite_advert import *
import configparser

init()

lg = Fore.LIGHTGREEN_EX
w = Fore.WHITE
cy = Fore.CYAN
ye = Fore.YELLOW
r = Fore.RED
n = Fore.RESET
colors = [lg, r, w, cy, ye]

def banner():
    f = pyfiglet.Figlet(font='slant')
    banner = f.renderText('TelegramRa')
    print(f'{random.choice(colors)}{banner}{n}')
    print(f'{r}  Версия: 1.0 |  Автор: Rashidovich{n}' + '\n')


def clr():
    if os.name == 'nt':
        os.system('cls')
    else:
        os.system('clear')

while True:
    clr()
    banner()
    print(f'{r}[] Аккаунты{n}')
    print(f'{cy}[1] Добавить новые аккаунты{n}')
    print(f'{cy}[2] Удалить все аккаунты в бане{n}')
    print(f'{cy}[3] Показать список всех аккаунтов{n}')
    print(f'{cy}[4] Удалить конкретный аккаунт{n}')
    print(f'{cy}[5] Перевести аккаунты из Создан в Доступен{n}')
    print(f'{cy}[6] Перевести аккаунт из Ожидает в Доступен{n}')
    print(f'{cy}[7] Перевести аккаунт в Ожидает{n}')
    print(f'{cy}[8] Перевести аккаунт в Забанен{n}')
    print(f'{r}[] Парсинг и загрузка в БД{n}')
    print(f'{cy}[9] Загрузить контакты из гео в БД{n}')
    print(f'{cy}[10] Cпарсить группу и загрузить контакты в БД{n}')
    print(f'{cy}[11] Статистика БД аккаунтов{n}')
    print(f'{r}[] Инвайт участников из БД{n}')
    print(f'{cy}[12] Инвайт из групп в группу{n}')
    print(f'{cy}[13] Инвайт по гео в группу{n}')
    print(f'{r}[] Рассылка сообщений{n}')
    print(f'{cy}[14] Рассылка сообщений{n}')
    #print(lg+'[5] Update your Genisys'+n)
    print(f'{r}[] Прогрев аккаунтов 20 минут{n}')
    print(f'{cy}[15] Прогрев акаунтов{n}')
    print(f'{cy}[99] Настройки')
    print(f'{cy}[16] Выход')
    a = int(input(f'\nВведите номер пункта и нажмите Enter: {r}'))
    if a == 1:
        g = get_all_tgaccounts()
        registered = []
        while True:
            a = int(input(f'\n{lg}Введите API ID: {r}'))
            b = str(input(f'{lg}Введите API Hash: {r}'))
            c = str(input(f'{lg}Введите номер телефона: {r}'))
            p = ''.join(c.split())
            #pickle.dump([a, b, p], g)
            add_account_todb(a, b, p, 0,'created')
            nacc=get_lasttgaccount()
            print(nacc)
            registered.append([nacc, a, b, p])
            ab = input(f'\nХотите ли добавить еще аккаунты?[y/n]: ')
            if 'y' not in ab:
                print('\n'+lg+'[i] Все аккаунты сохранены в базе данных'+n)
                sleep(3)
                clr()
                print(lg + '[*] Аутентификация новых аккаунтов...\n')
                for added in registered:
                    c = TelegramClient(f'{added[3]}', added[1], added[2])
                    try:
                        c.start()
                        print(f'n\n{lg}[+] Успешная аутентификация - {added[3]}')
                        c.disconnect()
                        update_tgaccounts(nacc, pole='available')
                    except PhoneNumberBannedError:
                        print(f'{r}[!] {added[2]} в бане! Удалите его, используя опцию 2')
                        continue
                    print('\n')
                input(f'\n{lg}Нажмите enter чтобы вернуться в главное меню...')
                break

    elif a == 2:
        accounts = []
        banned_accs = []
        accounts = get_all_tgaccounts_time()
        if len(accounts) == 0:
            print(f'{r}[!] У Вас нет аккаунтов! Пожалуйста добавьте и повторите еще раз')
            sleep(3)
        else:
            for account in accounts:
                acc_id = int(account[0])
                api_id = int(account[1])
                api_hash = str(account[2])
                phone = str(account[3])
                client = TelegramClient(f'{phone}', api_id, api_hash)
                client.connect()
                print(f'{r}[!] Аккаунт {phone}:')
                if not client.is_user_authorized():
                    try:
                        client.send_code_request(phone)
                        client.sign_in(phone, input('[+] Введите код: '))
                    except PhoneNumberBannedError:
                        print(r + phone + ' в бане!' + n)
                        remove_accountx(account_id=acc_id)
                        banned_accs.append(account)
            if not banned_accs:
                print(f'{lg}Поздравляем! Нет аккаунтов в бане')
            else:
                for _ in banned_accs:
                    remove_accountx(state='banned')
                print(f'{lg}[i] Все аккаунты из бана удалены{n}')
            input('\nНажмите enter чтобы вернуться в главное меню')
    elif a == 3:
        display = []
        j = get_all_tgaccounts_time()
        #while True:
        #    try:
        #        display.append(pickle.load(j))
        #    except EOFError:
        #        break
        #j.close()
        print(f'\n{cy}')
        print(
            ' #     |   API ID  |     Номер телефона  |    Статус   |    Приглашено24  |  Время старта'
        )
        print(
            '================================================================================================================'
        )
        for z in j:
            print(f'{z[0]} | {z[1]} | {z[3]}  | {z[4]} | {z[7]}  | {z[8]}')
        print(
            '========================================================================='
        )
        input('\nНажмите enter чтобы вернуться в главное меню')

    elif a == 4:
        f = get_all_tgaccounts()
        accs = list(f)
        print(f'{lg}[i] Выберите аккаунт для удаления\n')
        for i, acc in enumerate(f):
            print(f'{lg}[{i}] {acc[3]} {acc[4]} {n}')
        index = int(input(f'\n{lg}[+] Введите выбор: {n}'))
        acc_to_del = int(accs[index][0])
        phone = accs[index][3]
        session_file = f'{phone}.session'
        if os.name == 'nt':
            os.system(f'del sessions\\{session_file}')
        else:
            os.system(f'rm sessions/{session_file}')
        dacc = delete_tgacc(accs[index][0])
        #del accs[index]
        f = get_all_tgaccounts()
        for account in f:
            #print("||||DEL|||")
            print(f'{cy}[{account[0]}] {account[3]} {account[4]} {n}')
            #pickle.dump(account, f)
        print(f'\n{n}[+] Аккаунт удален{n}')
        input(f'{lg}Нажмите enter чтобы вернуться в главное меню{n}')
                #f.close()
    elif a == 5:
        display = []
        j = get_all_tgaccounts_time()
        i = 0
        for indacc in j:
            if(indacc[4]=='created'):
                update_tgaccounts(indacc[0], pole='available')
                print(f'{cy}[{indacc[0]}] {indacc[3]} {indacc[4]} {i}')
                i += 1
        print('=====================================================')
    elif a == 6:
        f = get_all_tgaccounts_time()
        accs = list(f)
        print(f'{lg}[i] Выберите аккаунт для перевода в available\n')
        for i, acc in enumerate(f):
            print(f'{lg}[{i}] {acc[3]} {acc[4]} {n}')
        index = int(input(f'\n{lg}[+] Введите выбор: {n}'))
        acc_to_change = int(accs[index][0])
        phone = accs[index][3]
        #session_file = phone + '.session'
        #if os.name == 'nt':
        #    os.system(f'del sessions\\{session_file}')
        #else:
        #    os.system(f'rm sessions/{session_file}')
        #dacc = delete_tgacc(accs[index][0])
        update_tgaccounts(accs[index][0], pole='available')
        #del accs[index]
        f = get_all_tgaccounts()
        for account in f:
            #print("||||DEL|||")
            print(f'{cy}[{account[0]}] {account[3]} {account[4]} {n}')
            #pickle.dump(account, f)
        print(f'\n{n}[+] Статус аккаунта изменен {n}')
        input(f'{lg}Нажмите enter чтобы вернуться в главное меню{n}')
            #f.close()
    elif a == 7:
        f = get_all_tgaccounts_time()
        accs = list(f)
        i = 0
        print(f'{lg}[i] Выберите аккаунт для перевода в Ожидание\n')
        for acc in f:
            print(f'{lg}[{i}] {acc[3]} {acc[4]} {n}')
            i += 1
        index = int(input(f'\n{lg}[+] Введите выбор: {n}'))
        acc_to_change = int(accs[index][0])
        phone = accs[index][3]
        update_tgaccounts(accs[index][0], pole='banned')
        f = get_all_tgaccounts()
        for account in f:
            print(f'{cy}[{account[0]}] {account[3]} {account[4]} {n}')
        print(f'\n{n}[+] Статус аккаунта изменен {n}')
        input(f'{lg}Нажмите enter чтобы вернуться в главное меню{n}')

    elif a == 8:
        accs = []
        f = get_all_tgaccounts_time()
        for indacc in f:
            accs.append(indacc)
        i = 0
        print(f'{lg}[i] Выберите аккаунт для перевода в Забанен\n')
        for acc in f:
            print(f'{lg}[{i}] {acc[3]} {acc[4]} {n}')
            i += 1
        index = int(input(f'\n{lg}[+] Введите выбор: {n}'))
        acc_to_change = int(accs[index][0])
        phone = accs[index][3]
        update_tgaccounts(accs[index][0], pole='banned')
        f = get_all_tgaccounts()
        for account in f:
            print(f'{cy}[{account[0]}] {account[3]} {account[4]} {n}')
        print(f'\n{n}[+] Статус аккаунта изменен {n}')
        input(f'{lg}Нажмите enter чтобы вернуться в главное меню{n}')
    elif a == 9:
        subprocess.run(["python3", "lo_geo.py"])
        sleep(1.5)

    elif a == 10:
        subprocess.run(["python3", "lo_groups.py"])
        sleep(1.5)

    elif a == 11:
        display = []
        j = get_all_tgaccounts_states()
        print(f'\n{cy}')
        print('Источник |   Группа  |   ID   | Статус  |  Количество  | ')
        print(
            '============================================================================================================='
        )
        for z in j:
            print(f'{z[0]} | {z[1]}  | {z[2]} | {z[3]} |  {z[4]} |')
        print('======================================================================')
        input('\nНажмите enter чтобы вернуться в главное меню')

    elif a == 12:
        subprocess.run(["python3", "invite_sql.py", "group", "no"])
        sleep(1.5)

    elif a == 13:
        subprocess.run(["python3", "invite_sql.py", "geoparse"])
        sleep(1.5)

    elif a == 14:
        subprocess.run(["python3", "sendmessages.py", "group"])
        sleep(1.5)

    elif a == 99:
        read_config = configparser.ConfigParser()
        read_config.read('settings.ini')
        TARGET_GROUP_USERNAME = read_config['settings']['TGU'].strip()
        str(input(f'\n{lg}[+] Введите имя пользователя группы: {TARGET_GROUP_USERNAME}{n}'))
        subprocess.run(["python3", "sendmessages.py", "group"])
        sleep(1.5)

    elif a == 17:
        accs_to_join = ['https://t.me/sportsru', ]
        accs = []
        f = get_all_tgaccounts()
        for indacc in f:
            accs.append(indacc)
        #f.close()
        i = 0
        print(f'{lg}[i] Выберите аккаунт для прогрева или all для created\n')
        for acc in f:
            print(f'{lg}[{i}] {acc[3]} {acc[4]} {n}')
            i += 1
        index = int(input(f'\n{lg}[+] Введите выбор: {n}'))
        if index == "all":
            f = get_all_createdaccounts()
        for acc in f:
        #добавляем пользователей и пишем им
        #вступаем в группы и задаем вопрос
        #делаем паузу
            acc_to_change = int(accs[index][0])
            phone = accs[index][3]
            remove_accountx(account_id=acc_id)
            update_tgaccounts(accs[index][0], pole='available')
            f = get_all_tgaccounts()
        for account in f:
            print(f'{cy}[{account[0]}] {account[3]} {account[4]} {n}')
        print(f'\n{n}[+] Статус аккаунта изменен {n}')
        input(f'{lg}Нажмите enter чтобы вернуться в главное меню{n}')


    elif a == 16:
        clr()
        banner()
        quit()

TelegramGoodsInBot>neon.py:
#!/usr/bin/env python3

import argparse
import array
import cairo
from PIL import ImageFilter, Image
from tools import transform_color


class NeonGlowText:
    """Neon glow text"""
    
    MIN_FONT_SIZE = 20
    MAX_FONT_SIZE = 300
    MAX_PADDING   = 120
    MIN_SHADOW    = 20
    FONT          = "Tomorrow"

    BG_COLOR   = '000000'
    GLOW_COLOR = 'ec0e77' #(0.929, 0.055, 0.467)
    FG_COLOR_1 = 'ff31f4' #(1, 0.196, 0.957)
    FG_COLOR_2 = 'ffd796' #(1, 0.847, 0.592)
    FILL_COLOR = 'FFFFFF'

    def __init__(self, args_dict):
        self.text           = args_dict.get('text')
        self.filename       = args_dict.get('filename')
        self.width          = args_dict.get('width')
        self.height         = args_dict.get('height')
        self.font           = args_dict.get('font')
        self.font_size      = None
        self.bg_color       = args_dict.get('bg_color')
        self.glow_color     = args_dict.get('glow_color')
        self.fill_color     = args_dict.get('fill_color')
        self.stroke_1_color = args_dict.get('stroke_1_color')
        self.stroke_2_color = args_dict.get('stroke_2_color')
    
    
    def draw(self):
        surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, self.width, self.height)
        
        cr = cairo.Context(surface)
        
        self._set_font(cr)
        self._move_to_center(cr)
        
        self._paint_bg(cr)

        cr.text_path(self.text)
        self._draw_glow(cr)
        
        surface = self._blur(surface, 35)
        
        cr = cairo.Context(surface)
        
        self._set_font(cr)
        self._move_to_center(cr)
        
        cr.text_path(self.text)
        self._draw_neon(cr)
        
        surface.write_to_png(self.filename)
    
    
    def _set_font(self, cr):
        cr.select_font_face(self.font, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)

        if self.font_size:
            cr.set_font_size(self.font_size)
            return

        # Let's find an appropriate font size...
        f_size = self.MAX_FONT_SIZE

        while True:
            cr.set_font_size(f_size)
            _, _, t_width, t_height, _, _ = cr.text_extents(self.text)

            # Check if text is within the desired boundaries
            if (
                t_width <= self.width - min(self.MAX_PADDING, f_size)
                and t_height <= self.height - min(self.MAX_PADDING, f_size)
                or f_size <= self.MIN_FONT_SIZE
            ):
                break

            f_size -= 2

        self.font_size = f_size

    def _move_to_center(self, cr):
        cr.select_font_face(self.font, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
        cr.set_font_size(self.font_size)
        x_bearing, y_bearing, t_width, t_height, _, _ = cr.text_extents(self.text)
        
        x = self.width / 2 - (t_width / 2 + x_bearing)
        y = self.height / 2 - (t_height / 2 + y_bearing)

        cr.move_to(x, y)

    def _paint_bg(self, cr):
        cr.set_source_rgb(*transform_color(self.bg_color))
        cr.paint()
        
    def _draw_glow(self, cr):
        stroke_width = max(self.font_size / 3, self.MIN_SHADOW)
        self._draw_stroke(cr, self.glow_color, stroke_width)
        self._fill(cr, self.fill_color)

    def _draw_stroke(self, cr, rgb, stroke_width):
        cr.set_source_rgb(*transform_color(rgb))
        cr.set_line_width(stroke_width)
        cr.stroke_preserve()
        
    def _fill(self, cr, rgb):
        cr.set_source_rgb(*transform_color(rgb))
        cr.fill()

    def _draw_neon(self, cr):
        self._draw_stroke(cr, self.stroke_1_color, 10 if self.font_size > 100 else 5)
        self._draw_stroke(cr, self.stroke_2_color, 5 if self.font_size > 100 else 2)
        self._fill(cr, self.fill_color)
        
    def _blur(self, surface, blur_amount):
        # Load as PIL Image
        bg_image = Image.frombuffer("RGBA",( surface.get_width(), surface.get_height() ), surface.get_data(), "raw", "RGBA", 0, 1)
        
        # Apply blur
        blurred_image = bg_image.filter(ImageFilter.GaussianBlur(blur_amount))
        
        # Restore cairo surface
        image_bytes = blurred_image.tobytes()
        image_array = array.array('B', image_bytes)
        stride = cairo.ImageSurface.format_stride_for_width(cairo.FORMAT_ARGB32, self.width)
        
        return surface.create_for_data(image_array, cairo.FORMAT_ARGB32, self.width, self.height, stride)



def main():
    args = _parse_arguments()
    neon_text = NeonGlowText(args)
    neon_text.draw()


def _parse_arguments():
    parser = argparse.ArgumentParser(
        description='Creates a neon glow effect image with the given text')

    parser.add_argument('-t', '--text',
                        help='Text to render',
                        required=True)
    parser.add_argument('-f', '--filename',
                        help='Image filename (png)',
                        required=True)

    parser.add_argument('--width',
                        help='Image width in pixels',
                        type=int,
                        default=1920)
    parser.add_argument('--height',
                        help='Image height in pixels',
                        type=int,
                        default=1080)
    
    parser.add_argument('--font',
                        help='Font name',
                        default=NeonGlowText.FONT)
    
    parser.add_argument('-bc', '--bg-color',
                        help='Image background color in hex (e.g. 020202)',
                        default=NeonGlowText.BG_COLOR)
    parser.add_argument('-gc', '--glow-color',
                        help='Text glow color in hex (e.g. EC0E77)',
                        default=NeonGlowText.GLOW_COLOR)
    parser.add_argument('-fc', '--fill-color',
                        help='Text fill color in hex (e.g. FFFFFF)',
                        default=NeonGlowText.FILL_COLOR)
    parser.add_argument('-s1c', '--stroke-1-color',
                        help='Text stroke 1 color in hex (e.g. FF31F4)',
                        default=NeonGlowText.FG_COLOR_1)
    parser.add_argument('-s2c', '--stroke-2-color',
                        help='Text stroke 2 color in hex (e.g. FFD796)',
                        default=NeonGlowText.FG_COLOR_2)

    return vars(parser.parse_args())

if __name__ == '__main__':
    main()

TelegramGoodsInBot>new_send_message.py:
import time
from selenium import webdriver
import telegram

def updateStatus():
    browser.find_element_by_xpath('//*[@id="paramInvcNo"]').send_keys(num)
    browser.find_element_by_xpath('//*[@id="btnSubmit"]').click()
    status = browser.find_element_by_xpath('//*[@id="statusDetail"]')
    return status.text

options = webdriver.ChromeOptions()
options.add_argument('headless')
options.add_argument('window-size=1920x1080')
options.add_argument("disable-gpu")
browser = webdriver.Chrome("Location of Chrome Driver", options = options)
browser.implicitly_wait(5)
url = 'https://www.cjlogistics.com/ko/tool/parcel/tracking'
browser.get(url)
myToken = 'TelegramToken'
bot = telegram.Bot(token = myToken)
chat_id = ID#bot.getUpdates()[-1].message.chat.id #가장 최근에 온 메세지의 chat id를 가져옵니다
num = 운송장 번호
statusArr = ["", ""]

i = 0
while True:
    status = updateStatus()
    statusArr[i%2] = str(status)
    if statusArr[0] != statusArr[1]:
        bot.sendMessage(chat_id=chat_id, text=statusArr[i%2])
        print('Different')
    browser.refresh()
    time.sleep(1)
    i = i+1

TelegramGoodsInBot>os2.py:

TelegramGoodsInBot>pars2.py:
from telethon.sync import TelegramClient
from telethon.tl.functions.messages import GetDialogsRequest
from telethon.tl.functions.messages import ReadHistoryRequest
from telethon.tl.functions.channels import GetParticipantsRequest
from telethon.tl.functions.channels import GetFullChannelRequest
from telethon.tl.types import ChannelParticipantsRecent
from telethon.tl.types import ChannelParticipantsSearch
from telethon.tl.types import InputPeerEmpty

import os, sys
import configparser
import csv
import time
from tgbot.services.api_sqlite import *

re="\033[1;31m"
gr="\033[1;32m"
cy="\033[1;36m"

def banner():
    print(f"""
´´´´¶¶¶¶¶¶´´´´´´¶¶¶¶¶¶
´´¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶¶¶¶¶¶
´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶ ´¶¶¶¶¶´
´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´´´¶¶¶¶¶¶¶¶
´´´´´´´´´´´¶¶¶¶
{re}

by rikudo
        """)
        

cpass = configparser.RawConfigParser()
cpass.read('config.data')

try:
    api_id = cpass['cred']['id']
    api_hash = cpass['cred']['hash']
    phone = cpass['cred']['phone']
    client = TelegramClient(phone, api_id, api_hash)
except KeyError:
    os.system('clear')
    banner()
    print(re+"[!] run python3 setup.py first !!\n")
    sys.exit(1)

client.connect()
if not client.is_user_authorized():
    client.send_code_request(phone)
    os.system('clear')
    banner()
    client.sign_in(phone, input(f'{gr}[+] Enter the code: {re}'))

os.system('clear')
banner()
chats = []
last_date = None
chunk_size = 200
groups=[]

result = client(GetDialogsRequest(
             offset_date=last_date,
             offset_id=0,
             offset_peer=InputPeerEmpty(),
             limit=chunk_size,
             hash = 0
         ))
chats.extend(result.chats)

for chat in chats:
    try:
        if chat.megagroup== True:
            groups.append(chat)
    except Exception:
        continue

print(f'{gr}[+] Choose a group to scrape members :{re}')
for i, g in enumerate(groups):
    print(f'{gr}[{cy}{str(i)}{gr}]{cy} - {g.title}')
print('')
g_index = input(f"{gr}[+] Enter a Number : {re}")
target_group=groups[int(g_index)]

print(f'{gr}[+] Fetching Members...')
time.sleep(1)

#all_participants = self.client.get_participants(target_Group)

#all_participants = []
#while_condition = True
#my_filter = ChannelParticipantsSearch('')
#offset = 0
#while while_condition:
#	participants = self.client(GetParticipantsRequest(channel=target_Group,  offset= offset, filter = my_filter, limit=200, hash=0))
#	all_participants.extend(participants.users)
#	offset += len(participants.users)
#	print(len(participants.users))
#	if len(participants.users) < 1 :
#		while_condition = False


offset = 0
limit = 100
all_participants = []
channel = 'building_work'
while True:
    participants = client(GetParticipantsRequest(
        channel, ChannelParticipantsRecent(), offset, limit,
        hash=0
    ))
    if not participants.users:
        break
    all_participants.extend(participants.users)
    offset += len(participants.users)
    print(offset)


print(f'{gr}[+] Saving In file...')
time.sleep(1)
with open("members.csv","w",encoding='UTF-8') as f:
    writer = csv.writer(f,delimiter=",",lineterminator="\n")
    writer.writerow(['username','user id', 'access hash','name','group', 'group id'])
    state = ""
    source = 'groups'
    for user in all_participants:
        username = user.username or ""
        first_name = user.first_name or ""
        last_name = user.last_name or ""
        name = f'{first_name} {last_name}'.strip()
        groupname = target_group.title
        usah = user.access_hash
        usid = user.id
        writer.writerow([username,user.id,user.access_hash,name,target_group.title, target_group.id])
        add_tgacc_todb(username,usid,usah,name,source,state)

print(f'{gr}[+] Members scraped successfully.')
TelegramGoodsInBot>proxy.list:
146.19.191.116:3128 
186.5.94.201:999 
45.233.67.209:999 
201.219.194.202:8080 
112.210.246.145:8080 
77.236.236.85:8080 
82.223.102.92:9443 
8.214.4.72:33080 
81.200.123.74:80 
180.191.40.48:8080 
157.230.48.102:80 
160.251.9.62:3128 
38.45.33.1:999 
192.248.190.249:12916
91.205.197.226:8080 
178.128.21.246:20425
44.195.36.104:443
202.91.77.222:83 
190.2.213.116:999 
5.58.58.209:8080 
194.145.138.84:9090 
176.236.141.30:10001
176.236.85.246:9090 
172.67.3.96:80
172.67.181.102:80
203.30.188.43:80
203.23.106.121:80
203.30.189.179:80
203.32.120.110:80
45.8.105.176:80
203.28.9.199:80
203.23.104.96:80
203.24.102.238:80
203.28.9.52:80
203.23.106.198:80
203.30.188.217:80
162.247.243.142:80
172.67.120.209:80
191.101.251.57:80
172.64.173.27:80
185.162.231.224:80
203.30.188.34:80
203.24.108.158:80
203.23.104.130:80
203.32.121.138:80
203.23.103.206:80
203.23.104.183:80
203.23.104.10:80
203.34.28.78:80
185.162.230.192:80
203.24.109.6:80
185.171.230.153:80
185.162.231.127:80
45.8.107.245:80
91.226.97.22:80
203.34.28.115:80
45.12.30.55:80
191.101.251.231:80
162.247.243.144:80
203.24.103.181:80
141.101.122.17:80
203.23.103.14:80
203.28.8.113:80
203.24.103.246:80
185.162.229.0:80
45.8.107.81:80
203.32.121.155:80
23.227.38.52:80
203.30.189.130:80
45.14.174.122:80
203.23.106.219:80
185.171.230.186:80
172.67.136.60:80
185.171.231.75:80
141.193.213.99:80
172.67.70.14:80
185.162.231.181:80
203.28.9.80:80
185.162.231.77:80
185.171.231.92:80
45.8.106.167:80
203.32.120.113:80
172.67.179.207:80
191.101.251.123:80
31.43.179.133:80
141.101.90.1:80
172.67.70.39:80
185.171.230.4:80
185.171.230.51:80
185.162.231.79:80
45.8.106.114:80
203.28.9.28:80
45.8.106.75:80
203.24.108.33:80
45.8.104.140:80
45.8.104.94:80
45.8.106.229:80
203.24.102.179:80
203.13.32.12:80
45.8.105.250:80
45.8.104.7:80
203.23.104.78:80
203.23.106.104:80
172.67.83.151:80
172.67.165.43:80
66.42.224.229:41679
72.49.49.11:31034
98.170.57.231:4145
184.178.172.11:4145
72.217.216.239:4145
139.99.237.62:80
72.221.172.203:4145
192.252.220.92:17328
103.155.217.156:41469
43.250.107.91:80
121.139.218.165:43295
89.43.5.134:3629
72.221.232.155:4145
204.150.185.27:6413
204.150.183.109:6851
66.29.154.103:1080
204.150.176.42:8100
43.255.113.232:8080
103.149.162.195:80
204.150.182.168:5395
103.155.217.156:41485
193.53.87.215:33128
72.206.181.103:4145
184.178.172.3:4145
204.150.180.167:8355
103.155.217.156:41460
193.53.87.222:33128
193.53.87.219:33128
103.155.217.156:41489
204.150.187.178:6609
204.150.187.233:7138
204.150.189.177:5848
169.57.1.85:8123
89.43.31.134:3128
198.199.86.11:3128
103.155.217.156:41475
204.150.210.188:6666
159.203.84.241:3128
204.150.191.88:7249
204.150.183.227:5551
204.150.187.255:7739
204.150.185.119:6319
204.150.177.105:8153
204.150.191.85:8237
103.155.217.156:41484
121.1.41.162:111
103.155.217.156:41476
103.155.217.156:41472
72.221.171.130:4145
185.148.223.76:3128
204.150.208.198:7781
67.201.33.10:25283
50.219.7.210:80
103.155.217.156:41482
103.155.217.156:41483
5.161.100.145:1080
50.237.9.176:80
190.58.248.86:80
103.155.217.156:41497
103.155.217.156:41495
51.68.207.81:443
103.155.217.156:41456
204.150.178.146:5068
50.219.7.216:80
50.217.110.217:80
50.204.190.234:80
204.150.211.76:7897
50.219.7.215:80
50.218.57.70:80
50.231.110.26:80
91.249.134.148:80
50.223.130.88:80
50.219.7.212:80
47.241.245.186:80
50.217.22.111:80
103.155.217.156:41487
204.150.232.240:7664
204.150.214.239:8763
198.8.94.170:4145
192.111.139.162:4145
190.216.56.1:4153
50.227.121.39:80
50.228.83.226:80
204.150.190.63:7458
204.150.177.87:8335
204.150.184.233:7121
204.150.180.9:7349
204.150.179.236:8060
50.206.111.90:80
50.219.7.194:80
50.219.7.199:80
80.179.140.189:80
50.218.57.66:80
50.218.57.71:80
50.217.44.153:80
119.18.52.224:17000
70.166.167.55:57745
72.206.181.105:64935
50.216.216.66:80
50.217.153.72:80
50.217.22.105:80
50.223.130.92:80
8.219.97.248:80
47.91.44.217:8000
195.2.71.201:16072
50.237.89.165:80
50.237.9.183:80
50.227.121.34:80
50.219.7.213:80
50.219.7.193:80
50.227.121.35:80
68.188.59.198:80
68.185.57.66:80
159.89.228.253:38172
217.17.56.160:4145
50.216.216.64:80
50.218.57.68:80
194.158.203.14:80
50.204.233.30:80
50.237.9.180:80
50.219.7.195:80
50.219.7.197:80
50.219.7.220:80
50.201.51.250:80
50.217.44.154:80
50.217.110.219:80
89.149.176.186:80
50.237.89.161:80
31.30.98.114:80
98.162.25.7:31653
50.206.25.106:80
50.227.121.38:80
50.237.89.163:80
72.195.34.42:4145
50.237.9.174:80
50.219.7.214:80
66.29.154.105:1080
50.219.7.201:80
50.219.7.204:80
50.219.7.205:80
50.219.7.223:80
50.217.153.74:80
50.217.153.78:80
157.245.72.33:1080
72.221.196.157:35904
98.162.25.4:31654
50.206.25.108:80
50.206.25.104:80
66.29.154.105:3128
66.191.31.158:80
50.217.22.107:80
50.219.7.196:80
98.170.57.249:4145
50.217.153.79:80
50.217.22.114:80
50.237.9.182:80
50.239.72.18:80
50.217.153.73:80
50.237.9.181:80
65.37.106.2:80
106.107.205.112:80
72.210.221.197:4145
192.111.138.29:4145
62.113.115.94:16072
50.219.7.200:80
50.219.7.222:80
50.219.7.209:80
50.219.7.207:80
50.219.168.10:80
50.217.153.77:80
50.216.216.65:80
208.109.11.232:8089
50.206.25.105:80
50.206.25.107:80
85.26.146.169:80
50.218.57.69:80
50.217.22.108:80
50.219.7.202:80
50.237.89.170:80
50.204.219.229:80
50.219.7.218:80
50.218.57.65:80
24.95.253.39:80
50.223.130.94:80
50.228.141.98:80
50.228.141.101:80
50.219.7.192:80
50.219.7.208:80
157.245.210.217:37864
50.228.141.102:80
50.231.33.154:80
50.219.7.211:80
50.219.7.217:80
50.217.44.152:80
50.223.130.90:80
50.230.222.202:80
50.239.72.19:80
106.107.203.151:80
50.220.21.202:80
194.106.16.41:80
213.143.113.82:80
50.223.130.91:80
50.40.32.90:80
64.201.163.133:80
50.228.141.97:80
50.220.168.134:80
20.230.193.232:80
50.228.141.100:80
50.223.130.34:80
50.206.111.91:80
50.218.57.74:80
50.217.22.104:80
50.237.89.167:80
50.217.44.178:80
176.192.70.58:8003
50.237.89.160:80
77.73.241.154:80
212.230.172.6:80
20.110.214.83:80
80.228.235.2:80
185.171.231.148:80
203.30.189.241:80
45.8.105.240:80
203.23.104.18:80
185.162.231.212:80
185.171.230.139:80
45.8.105.223:80
45.14.174.211:80
191.101.251.76:80
185.238.228.99:80
185.162.229.3:80
185.162.228.19:80
185.238.228.52:80
172.67.146.112:80
203.24.103.16:80
203.30.190.64:80
203.23.104.45:80
45.12.30.61:80
203.34.28.160:80
203.30.190.83:80
185.162.228.45:80
203.13.32.83:80
45.12.30.139:80
203.23.103.134:80
203.23.103.230:80
203.30.190.35:80
203.32.121.84:80
203.23.103.175:80
203.24.108.178:80
203.23.104.42:80
45.12.31.94:80
203.32.121.78:80
203.23.104.157:80
45.14.174.11:80
203.23.106.141:80
45.14.174.99:80
185.171.231.116:80
45.12.30.237:80
203.28.9.136:80
203.30.191.154:80
203.23.104.171:80
23.227.38.104:80
203.30.189.68:80
45.8.107.54:80
185.171.230.223:80
203.34.28.159:80
203.23.106.13:80
185.171.231.248:80
185.171.231.73:80
185.162.229.184:80
203.23.104.152:80
203.24.108.91:80
203.30.191.157:80
203.34.28.216:80
185.171.231.31:80
162.247.243.67:80
162.247.243.145:80
172.67.29.178:80
23.227.39.73:80
172.67.181.42:80
203.32.120.8:80
172.67.177.110:80
45.8.106.7:80
203.22.223.136:80
185.162.228.220:80
45.8.104.215:80
45.12.30.141:80
203.32.121.252:80
203.30.190.189:80
185.162.231.242:80
203.24.103.108:80
185.162.228.80:80
185.171.231.157:80
203.32.120.64:80
203.28.9.111:80
203.32.120.15:80
203.30.189.217:80
91.226.97.127:80
185.171.231.43:80
172.67.27.61:80
31.43.179.125:80
31.43.179.16:80
172.67.192.25:80
172.67.71.85:80
172.67.0.19:80
172.67.70.168:80
203.30.189.152:80
203.28.9.95:80
185.162.228.206:80
91.226.97.212:80
203.23.103.44:80
203.13.32.100:80
203.13.32.177:80
203.13.32.201:80
203.30.188.56:80
45.12.30.31:80
185.162.229.87:80
203.32.120.69:80
185.162.229.97:80
45.8.107.56:80
203.22.223.170:80
203.30.191.142:80
203.24.102.65:80
31.43.179.131:80
141.193.213.27:80
185.238.228.175:80
203.32.121.98:80
172.67.3.114:80
185.162.229.5:80
45.14.174.128:80
45.8.104.61:80
185.171.230.35:80
203.23.104.143:80
185.162.231.201:80
185.171.230.169:80
185.162.230.37:80
185.162.230.233:80
203.28.9.253:80
203.23.103.179:80
45.12.30.30:80
203.24.109.47:80
185.171.230.22:80
185.162.231.117:80
203.32.121.196:80
185.171.231.47:80
203.30.189.167:80
45.8.107.162:80
203.30.188.28:80
203.23.106.122:80
203.24.103.32:80
185.171.230.137:80
203.30.190.245:80
190.93.247.0:80
162.247.243.211:80
191.101.251.210:80
185.238.228.186:80
172.67.72.79:80
172.64.146.245:80
172.67.70.3:80
172.67.70.140:80
103.21.244.18:80
172.67.3.141:80
172.67.3.83:80
172.67.167.170:80
45.8.104.216:80
185.162.231.139:80
203.34.28.87:80
203.28.8.239:80
203.23.106.3:80
185.162.230.243:80
203.34.28.194:80
203.28.9.133:80
203.28.9.121:80
203.24.108.11:80
185.162.230.148:80
185.171.231.88:80
45.8.106.148:80
203.32.121.121:80
203.22.223.239:80
185.162.230.5:80
203.30.191.67:80
23.227.38.150:80
23.227.38.102:80
203.34.28.116:80
203.32.120.167:80
45.8.106.20:80
185.162.229.215:80
185.162.230.200:80
185.171.230.64:80
203.32.121.135:80
191.101.251.11:80
188.114.96.7:80
172.67.0.22:80
172.67.43.151:80
172.67.44.13:80
185.238.228.101:80
162.247.243.158:80
130.61.181.176:80
188.114.96.13:80
172.67.190.45:80
172.64.162.2:80
203.24.103.86:80
203.30.191.51:80
203.32.120.52:80
23.227.38.101:80
203.24.102.54:80
203.23.103.51:80
91.226.97.97:80
185.238.228.16:80
172.67.192.63:80
103.75.53.107:1433
172.67.51.155:80
172.67.3.65:80
45.8.105.200:80
45.8.106.150:80
203.22.223.238:80
185.171.231.250:80
45.8.107.242:80
203.24.102.133:80
203.13.32.151:80
185.171.231.94:80
203.30.190.195:80
203.22.223.57:80
185.162.230.30:80
203.32.121.55:80
203.34.28.62:80
203.24.102.194:80
47.243.240.77:3128
8.210.155.195:3128
125.21.3.41:8080
64.189.24.250:3129
178.128.96.182:8080
172.67.3.152:80
203.30.190.101:80
91.226.97.209:80
203.24.103.218:80
203.30.190.233:80
185.162.230.232:80
172.67.181.89:80
203.28.9.129:80
203.23.103.180:80
203.23.106.243:80
185.171.230.25:80
172.67.180.205:80
191.101.251.178:80
172.67.205.92:80
172.67.70.155:80
172.67.70.73:80
172.67.3.116:80
185.162.230.65:80
172.67.167.224:80
45.8.105.181:80
45.12.30.53:80
203.24.103.210:80
45.8.106.109:80
203.28.9.188:80
203.24.103.4:80
185.162.228.12:80
203.24.102.123:80
45.14.174.135:80
203.24.109.149:80
185.171.230.209:80
203.23.103.172:80
203.23.104.135:80
45.8.106.211:80
203.30.189.222:80
203.24.103.171:80
203.32.120.165:80
203.23.106.38:80
91.226.97.191:80
203.23.106.252:80
203.23.103.103:80
185.162.229.78:80
31.43.179.236:80
172.67.171.214:80
162.247.243.16:80
172.67.172.165:80
162.247.243.15:80
172.67.43.233:80
162.247.243.14:80
141.193.213.8:80
172.67.0.17:80
172.67.255.225:80
103.21.244.1:80
103.21.244.7:80
23.227.38.127:80
185.162.229.101:80
203.24.103.67:80
185.171.230.129:80
45.14.174.144:80
185.162.229.141:80
203.24.102.175:80
185.171.231.197:80
203.24.103.35:80
203.24.109.201:80
45.14.174.192:80
45.8.104.254:80
203.30.188.125:80
45.8.104.66:80
203.30.190.47:80
45.8.106.142:80
141.101.114.87:80
103.21.244.0:80
203.24.109.158:80
45.12.30.131:80
203.13.32.5:80
45.12.31.125:80
45.8.105.210:80
203.28.8.219:80
45.14.174.19:80
203.23.103.73:80
45.8.104.113:80
185.162.229.255:80
203.30.190.198:80
45.12.30.106:80
203.32.120.163:80
31.43.179.126:80
185.238.228.122:80
172.67.78.169:80
172.67.55.226:80
203.34.28.63:80
185.162.231.68:80
203.22.223.55:80
203.13.32.171:80
203.30.190.109:80
203.23.106.110:80
203.22.223.200:80
203.34.28.81:80
185.171.231.167:80
203.30.188.210:80
203.30.191.205:80
185.162.229.220:80
203.34.28.140:80
203.24.109.242:80
185.162.228.152:80
203.30.189.235:80
185.171.230.234:80
45.12.30.213:80
203.30.188.54:80
91.226.97.0:80
203.30.190.236:80
203.23.104.181:80
185.238.228.22:80
172.67.43.141:80
172.64.141.2:80
172.67.3.126:80
45.8.104.224:80
45.8.107.85:80
203.32.120.239:80
45.8.104.109:80
45.12.30.74:80
185.162.230.10:80
185.162.230.134:80
185.171.230.178:80
203.28.8.109:80
45.8.105.47:80
203.23.103.120:80
203.23.104.240:80
185.171.230.65:80
185.171.230.138:80
45.12.31.204:80
203.23.104.188:80
185.162.228.145:80
162.247.243.133:80
185.170.166.150:80
172.67.56.1:80
141.101.123.7:80
172.67.3.80:80
203.32.120.164:80
45.14.174.36:80
203.24.103.136:80
23.227.38.156:80
203.24.108.120:80
203.32.121.188:80
203.30.191.117:80
185.162.230.218:80
203.30.188.90:80
185.162.229.165:80
45.8.105.68:80
203.23.104.250:80
45.8.106.247:80
203.34.28.211:80
203.32.121.216:80
203.28.9.32:80
203.34.28.185:80
203.28.8.62:80
203.24.109.74:80
185.171.231.139:80
203.30.191.220:80
203.30.188.48:80
45.12.31.138:80
45.14.174.15:80
172.67.33.224:80
141.193.213.236:80
162.247.243.210:80
162.247.243.98:80
203.24.102.160:80
172.64.128.2:80
188.114.96.246:80
23.227.38.47:80
203.30.189.168:80
185.171.230.121:80
203.30.190.213:80
203.24.103.229:80
45.12.30.46:80
45.8.107.198:80
203.30.189.45:80
23.227.38.91:80
203.24.109.14:80
185.171.231.49:80
203.23.103.91:80
203.13.32.68:80
45.8.105.244:80
45.14.174.50:80
184.178.172.14:4145
174.75.211.222:4145
72.210.252.134:46164
72.210.252.137:4145
98.162.25.16:4145
204.150.191.156:6920
39.175.75.144:30001
172.67.181.85:80
172.67.3.85:80
172.67.138.108:80
45.8.104.37:80
185.162.229.71:80
45.12.30.160:80
203.28.8.141:80
203.24.103.94:80
203.23.103.9:80
45.8.106.146:80
91.226.97.104:80
203.30.189.12:80
203.28.9.77:80
203.24.109.134:80
185.162.229.65:80
185.162.231.49:80
203.28.8.84:80
203.23.104.179:80
185.162.231.74:80
45.8.105.197:80
8.209.220.34:80
185.238.228.46:80
203.32.120.128:80
185.238.228.10:80
172.67.182.136:80
172.67.0.2:80
203.24.109.20:80
23.227.38.235:80
203.23.103.53:80
45.12.31.206:80
185.162.229.236:80
185.162.231.189:80
172.64.171.46:80
141.193.213.130:80
172.67.6.144:80
203.24.108.24:80
203.23.104.217:80
45.8.104.3:80
203.30.190.122:80
45.14.174.254:80
185.162.230.255:80
91.226.97.9:80
203.23.103.36:80
203.34.28.102:80
185.171.231.98:80
203.28.8.12:80
203.30.189.178:80
172.67.171.237:80
162.247.243.224:80
172.67.177.24:80
203.23.106.0:80
203.30.190.127:80
203.23.103.211:80
203.30.190.129:80
45.8.107.233:80
185.162.230.157:80
203.24.102.254:80
203.22.223.89:80
203.23.104.126:80
203.32.120.66:80
203.24.103.68:80
91.226.97.139:80
203.32.121.236:80
185.171.230.29:80
203.23.106.27:80
91.226.97.86:80
45.8.105.153:80
203.32.120.90:80
185.162.230.48:80
203.13.32.246:80
91.243.164.214:5678
81.91.137.42:8080
217.218.242.75:5678
173.212.216.104:3128
172.67.3.110:80
203.13.32.242:80
203.23.104.231:80
203.24.109.26:80
203.30.189.87:80
203.34.28.118:80
45.12.30.225:80
172.64.131.2:80
172.67.180.1:80
45.8.105.85:80
203.23.104.226:80
172.67.171.197:80
141.193.213.13:80
172.67.206.108:80
172.67.0.16:80
172.67.70.158:80
45.14.174.224:80
185.162.229.240:80
185.162.230.152:80
203.24.103.25:80
203.24.102.132:80
203.28.8.24:80
23.227.38.242:80
91.226.97.186:80
185.162.229.200:80
203.24.102.249:80
185.162.230.175:80
185.171.230.247:80
203.30.191.87:80
91.226.97.213:80
185.162.230.47:80
185.162.231.132:80
45.8.105.12:80
23.227.38.126:80
45.8.104.231:80
203.32.121.18:80
203.30.189.200:80
203.24.109.207:80
91.226.97.44:80
203.34.28.51:80
45.12.30.49:80
185.171.230.38:80
185.162.228.247:80
185.238.228.124:80
172.67.192.9:80
185.238.228.112:80
172.67.165.119:80
203.30.191.25:80
172.67.167.165:80
23.227.38.232:80
185.162.231.157:80
45.12.31.61:80
203.32.120.143:80
203.23.106.89:80
185.162.230.59:80
203.30.191.40:80
203.24.103.173:80
203.30.191.107:80
45.8.107.226:80
91.226.97.181:80
203.23.106.188:80
45.8.106.173:80
185.238.228.6:80
172.67.43.230:80
172.67.43.210:80
45.8.105.69:80
141.193.213.110:80
172.67.38.66:80
172.67.181.183:80
172.67.167.92:80
203.24.108.59:80
203.24.103.167:80
91.226.97.241:80
45.8.107.49:80
31.43.179.207:80
172.67.172.173:80
172.67.185.185:80
185.238.228.25:80
172.64.160.2:80
185.162.229.100:80
185.171.230.143:80
203.24.103.131:80
203.24.108.230:80
45.12.30.208:80
203.30.188.9:80
203.30.189.99:80
45.14.174.39:80
23.227.38.95:80
203.24.103.193:80
195.137.167.109:80
172.67.63.110:80
172.67.6.156:80
172.67.71.46:80
172.67.70.87:80
45.12.31.26:80
203.22.223.39:80
203.30.188.132:80
203.32.121.211:80
45.8.105.218:80
185.171.231.241:80
203.28.9.179:80
203.24.102.153:80
45.8.107.164:80
45.8.107.215:80
203.30.190.188:80
203.22.223.199:80
203.30.189.11:80
203.22.223.53:80
203.30.190.218:80
45.12.31.10:80
188.114.96.20:80
172.67.43.7:80
172.67.3.111:80
203.32.120.22:80
185.162.229.30:80
45.12.31.181:80
185.162.229.107:80
45.8.104.147:80
203.24.103.172:80
203.23.106.70:80
203.34.28.12:80
45.8.106.151:80
203.32.120.127:80
203.23.104.221:80
45.8.107.60:80
185.162.229.24:80
185.162.228.49:80
203.32.121.112:80
185.162.230.186:80
203.30.191.144:80
45.12.30.135:80
45.14.174.69:80
203.24.108.74:80
203.23.106.191:80
203.30.190.62:80
45.12.30.84:80
172.67.171.236:80
172.67.75.5:80
61.183.234.226:9091
172.67.89.138:80
172.67.199.190:80
172.67.70.173:80
172.67.70.7:80
172.67.167.79:80
203.28.9.127:80
45.12.31.148:80
203.13.32.92:80
45.8.106.45:80
203.24.102.117:80
185.238.228.235:80
162.247.241.14:80
172.67.161.166:80
172.64.136.8:80
172.67.180.23:80
172.67.180.16:80
203.30.190.137:80
203.34.28.241:80
203.24.108.3:80
185.162.230.187:80
203.28.9.226:80
91.226.97.1:80
185.171.231.154:80
203.28.8.182:80
185.162.230.95:80
203.24.109.53:80
203.24.102.159:80
185.171.231.90:80
203.30.191.181:80
45.14.174.121:80
185.171.230.148:80
31.43.179.23:80
188.114.97.5:80
172.67.0.27:80
172.67.43.219:80
141.193.213.119:80
31.43.179.185:80
191.101.251.97:80
162.247.241.2:80
203.30.190.70:80
203.23.103.22:80
203.30.189.159:80
45.8.105.182:80
185.162.228.54:80
203.24.108.179:80
203.32.120.204:80
23.227.38.119:80
203.32.121.182:80
185.238.228.121:80
162.247.243.199:80
172.64.168.2:80
222.237.249.172:8080
45.8.105.199:80
185.162.228.235:80
203.28.9.90:80
45.8.105.168:80
203.32.120.226:80
185.238.228.216:80
141.193.213.166:80
172.64.169.2:80
172.67.165.47:80
172.67.182.163:80
172.67.3.68:80
172.67.3.67:80
203.30.189.4:80
23.227.38.4:80
203.28.9.147:80
23.227.38.144:80
203.30.190.121:80
203.30.188.144:80
203.24.108.23:80
185.162.230.29:80
203.30.188.212:80
185.171.231.145:80
203.30.189.31:80
203.32.120.44:80
203.24.108.50:80
23.227.38.61:80
203.22.223.95:80
203.28.9.237:80
203.24.108.122:80
45.8.107.208:80
203.22.223.162:80
141.193.213.35:80
172.64.131.181:80
172.67.182.79:80
172.67.3.113:80
172.67.176.18:80
203.32.121.0:80
45.8.104.100:80
203.24.108.243:80
203.22.223.147:80
185.162.228.103:80
203.22.223.223:80
185.162.231.70:80
162.247.243.188:80
31.43.179.229:80
31.43.179.188:80
172.67.171.232:80
172.67.0.26:80
172.67.181.252:80
172.67.164.43:80
172.67.197.65:80
185.162.228.1:80
203.28.8.72:80
185.162.228.156:80
172.67.185.202:80
172.67.192.7:80
172.67.207.187:80
172.67.70.82:80
203.32.121.158:80
203.24.108.4:80
203.34.28.41:80
203.23.104.252:80
203.28.9.0:80
203.23.104.4:80
45.12.31.89:80
203.22.223.242:80
45.8.106.73:80
203.22.223.233:80
203.30.188.35:80
172.67.171.202:80
172.67.166.241:80
141.193.213.230:80
172.67.43.238:80
172.67.192.20:80
172.67.1.50:80
141.193.213.28:80
141.101.123.24:80
203.28.9.108:80
45.8.107.31:80
45.12.30.142:80
203.23.103.183:80
45.14.174.24:80
185.162.230.170:80
45.12.30.151:80
45.14.174.85:80
203.23.103.192:80
45.12.31.81:80
23.227.38.149:80
203.24.109.210:80
203.30.190.90:80
31.43.179.124:80
141.193.213.183:80
185.238.228.62:80
162.247.243.96:80
141.193.213.238:80
172.67.75.9:80
162.247.243.198:80
172.67.42.113:80
185.162.231.89:80
203.24.108.6:80
45.8.105.73:80
45.8.106.63:80
185.162.229.196:80
23.227.38.22:80
203.30.189.174:80
203.30.190.25:80
31.43.179.199:80
172.67.0.12:80
45.14.174.172:80
203.30.191.185:80
45.8.104.225:80
203.24.103.150:80
45.14.174.193:80
203.28.8.149:80
203.30.189.122:80
203.32.121.239:80
203.24.103.120:80
203.28.8.85:80
45.8.107.65:80
45.14.174.238:80
203.23.104.211:80
45.12.31.51:80
185.162.231.32:80
45.12.31.4:80
203.30.189.83:80
203.30.188.127:80
203.30.191.188:80
185.162.229.155:80
203.32.121.173:80
185.162.228.85:80
203.22.223.88:80
203.23.104.82:80
185.162.228.21:80
185.162.230.40:80
185.162.228.143:80
203.30.189.50:80
185.238.228.131:80
172.67.170.10:80
172.67.0.39:80
172.67.43.226:80
188.114.97.79:80
172.64.206.2:80
172.67.182.141:80
172.67.182.77:80
45.12.30.128:80
185.162.228.55:80
185.171.231.199:80
203.22.223.8:80
203.34.28.18:80
45.8.104.182:80
185.162.228.98:80
45.8.106.43:80
45.8.105.171:80
45.8.106.137:80
185.162.231.18:80
203.23.104.139:80
172.67.75.199:80
172.67.70.218:80
172.67.70.11:80
172.67.70.50:80
141.101.113.46:80
203.32.120.122:80
185.162.230.183:80
45.8.104.60:80
203.22.223.21:80
203.28.8.197:80
45.14.174.181:80
203.34.28.30:80
203.30.188.157:80
45.8.105.203:80
45.12.30.252:80
203.30.191.167:80
185.162.231.237:80
203.34.28.203:80
203.34.28.238:80
185.162.228.238:80
203.30.188.147:80
203.30.188.227:80
31.43.179.143:80
172.67.0.24:80
172.67.192.16:80
172.67.137.237:80
141.101.122.235:80
45.14.174.0:80
45.12.31.114:80
203.24.102.161:80
203.32.121.38:80
203.22.223.159:80
45.8.105.83:80
45.8.105.185:80
185.171.231.165:80
203.23.106.53:80
203.30.191.225:80
203.13.32.190:80
185.162.230.221:80
45.12.30.113:80
203.24.103.0:80
185.162.231.202:80
172.67.75.154:80
172.67.254.167:80
185.162.228.187:80
203.24.108.214:80
203.32.120.214:80
185.162.231.130:80
45.8.106.245:80
203.24.102.202:80
203.23.104.245:80
185.162.228.81:80
203.24.103.30:80
45.8.106.238:80
31.43.179.216:80
188.114.99.206:80
23.227.38.173:80
203.22.223.249:80
172.67.165.253:80
172.67.215.205:80
172.67.3.90:80
23.227.38.167:80
172.67.167.57:80
203.24.108.253:80
185.162.231.211:80
203.24.102.98:80
203.30.190.232:80
203.30.190.10:80
23.227.38.103:80
45.8.107.156:80
203.23.103.226:80
185.171.230.198:80
185.162.231.115:80
91.226.97.75:80
203.30.189.114:80
203.30.189.136:80
203.30.189.225:80
185.162.231.142:80
45.8.106.78:80
203.23.106.174:80
185.162.229.20:80
185.171.230.27:80
203.24.103.105:80
203.32.121.142:80
172.67.172.12:80
195.137.167.107:80
172.67.170.13:80
141.193.213.181:80
191.101.251.127:80
185.238.228.126:80
172.67.188.1:80
172.67.192.14:80
191.101.251.152:80
141.193.213.15:80
141.193.213.229:80
172.64.149.27:80
172.67.117.231:80
172.67.3.70:80
191.101.251.227:80
172.67.68.214:80
91.226.97.80:80
203.13.32.108:80
185.162.230.247:80
203.23.106.19:80
203.30.191.95:80
45.8.105.216:80
45.8.104.35:80
203.23.104.248:80
91.226.97.178:80
45.8.107.77:80
203.30.190.1:80
203.24.108.229:80
172.67.206.44:80
185.171.230.146:80
162.247.243.130:80
45.131.6.143:80
172.67.44.9:80
172.67.192.34:80
172.67.3.89:80
172.67.3.73:80
203.28.8.89:80
203.24.108.167:80
45.8.105.239:80
203.30.190.55:80
203.28.8.2:80
45.12.30.134:80
45.8.107.150:80
203.24.109.39:80
91.226.97.14:80
185.162.231.218:80
203.24.102.41:80
185.162.229.9:80
203.30.189.252:80
45.12.30.222:80
203.28.9.215:80
203.22.223.66:80
203.30.188.177:80
172.67.203.99:80
185.238.228.198:80
172.67.70.210:80
141.101.115.248:80
36.67.248.129:8080
208.113.134.223:80
172.67.208.217:80
172.67.3.77:80
185.162.229.168:80
203.28.8.150:80
45.8.106.160:80
203.13.32.162:80
45.8.106.189:80
23.227.38.124:80
185.162.230.8:80
203.24.109.132:80
45.12.31.87:80
45.8.107.209:80
45.8.106.156:80
203.24.102.154:80
203.23.103.84:80
203.24.108.192:80
203.23.103.45:80
172.67.43.240:80
172.67.187.238:80
172.67.61.88:80
172.67.177.173:80
203.32.121.69:80
203.34.28.50:80
203.23.106.254:80
203.30.190.130:80
45.12.30.227:80
203.34.28.97:80
185.162.228.44:80
185.171.231.166:80
203.30.190.30:80
185.162.228.95:80
185.171.231.7:80
203.28.9.219:80
203.32.121.199:80
185.162.231.65:80
203.23.104.158:80
141.101.123.26:80
172.67.70.120:80
172.67.70.109:80
172.67.70.172:80
172.67.70.108:80
172.67.3.109:80
203.34.28.53:80
203.24.108.188:80
203.32.121.193:80
23.227.38.159:80
45.8.105.17:80
203.24.109.81:80
203.24.102.172:80
203.32.120.245:80
45.8.107.136:80
185.162.231.59:80
185.171.230.225:80
203.32.121.131:80
203.32.121.118:80
45.8.106.221:80
203.23.106.142:80
203.30.191.143:80
185.162.229.13:80
185.162.230.11:80
45.8.105.221:80
203.28.9.94:80
45.12.31.36:80
45.8.106.111:80
203.28.9.64:80
45.8.104.149:80
185.171.230.147:80
203.24.109.171:80
185.162.230.136:80
203.23.104.93:80
45.14.174.120:80
185.162.230.75:80
191.101.251.2:80
91.226.97.72:80
68.183.65.29:80
172.67.0.7:80
172.67.7.187:80
45.8.106.32:80
172.67.167.140:80
185.162.228.62:80
203.30.188.220:80
203.30.191.208:80
203.30.191.115:80
203.32.120.200:80
45.14.174.91:80
203.30.189.8:80
203.24.103.82:80
185.171.230.89:80
91.226.97.60:80
185.171.231.202:80
203.24.108.45:80
185.171.230.239:80
172.67.75.176:80
185.238.228.205:80
185.171.231.34:80
172.67.137.250:80
172.67.179.204:80
172.67.43.156:80
172.67.185.188:80
185.238.228.85:80
172.67.70.76:80
172.67.70.251:80
203.13.32.203:80
203.30.188.68:80
185.162.228.242:80
185.162.230.179:80
185.162.231.118:80
45.8.105.145:80
185.162.229.57:80
23.227.38.50:80
203.30.190.86:80
185.162.228.101:80
45.8.107.87:80
203.22.223.4:80
203.23.104.203:80
45.8.105.96:80
45.12.30.42:80
203.24.102.251:80
45.8.104.6:80
45.12.31.49:80
203.23.104.102:80
45.8.107.114:80
203.32.120.157:80
203.28.9.58:80
203.23.103.151:80
45.8.105.112:80
203.30.189.239:80
185.171.231.211:80
147.185.161.0:80
185.238.228.245:80
162.247.243.164:80
45.12.31.35:80
203.28.8.151:80
162.247.241.10:80
141.193.213.243:80
185.171.230.193:80
203.24.109.83:80
45.14.174.106:80
203.24.109.150:80
45.12.31.171:80
203.24.103.83:80
45.12.31.216:80
203.32.120.209:80
45.12.30.194:80
203.32.120.57:80
162.247.243.204:80
23.227.39.254:80
172.67.70.66:80
103.21.244.12:80
172.67.3.124:80
172.67.177.156:80
203.28.8.164:80
203.24.102.236:80
45.8.107.36:80
45.14.174.88:80
45.8.107.173:80
203.30.188.189:80
203.28.9.82:80
203.24.108.221:80
185.171.231.191:80
203.30.191.60:80
91.226.97.84:80
23.227.38.3:80
130.61.216.226:80
185.238.228.214:80
172.67.43.97:80
141.193.213.9:80
172.67.167.131:80
203.28.9.149:80
185.171.230.26:80
203.24.108.130:80
45.12.31.28:80
203.30.191.93:80
185.171.230.109:80
203.32.121.25:80
23.227.38.51:80
130.61.211.208:80
185.162.231.167:80
172.67.70.154:80
172.67.3.72:80
203.30.188.152:80
185.171.231.124:80
203.23.104.43:80
23.227.38.176:80
185.162.230.178:80
203.28.8.16:80
203.28.9.43:80
45.12.30.18:80
45.8.104.67:80
23.227.38.44:80
185.238.228.93:80
172.64.195.2:80
103.21.244.8:80
185.171.230.231:80
203.32.121.178:80
203.34.28.109:80
185.162.229.154:80
185.162.229.103:80
203.30.189.215:80
185.171.231.53:80
203.28.8.160:80
203.28.8.189:80
185.162.230.167:80
203.23.104.1:80
203.23.103.34:80
91.226.97.33:80
45.12.30.52:80
203.32.120.89:80
185.162.228.134:80
91.226.97.240:80
203.13.32.14:80
203.28.9.151:80
203.24.102.78:80
203.13.32.73:80
203.28.8.59:80
185.162.229.158:80
172.67.182.27:80
190.93.247.9:80
172.67.3.58:80
203.32.120.18:80
172.67.167.47:80
203.32.120.28:80
203.28.9.158:80
203.28.9.123:80
203.30.191.240:80
45.8.107.44:80
45.8.105.235:80
185.171.230.211:80
203.13.32.138:80
203.23.106.117:80
203.34.28.66:80
203.28.8.173:80
203.24.108.121:80
203.30.190.124:80
162.247.243.39:80
162.247.243.151:80
103.160.204.104:80
172.67.72.41:80
141.101.123.22:80
172.67.3.99:80
185.162.231.161:80
172.67.177.99:80
185.171.231.213:80
203.30.190.173:80
45.8.107.240:80
45.8.106.70:80
45.12.30.88:80
203.13.32.15:80
45.8.107.112:80
203.30.188.112:80
203.34.28.16:80
45.14.174.7:80
203.30.188.223:80
45.8.106.80:80
45.14.174.55:80
203.30.189.53:80
203.23.106.143:80
185.238.228.253:80
191.101.251.133:80
130.61.212.181:80
172.67.176.233:80
203.30.188.207:80
203.30.190.172:80
203.30.191.8:80
45.8.105.232:80
185.162.231.186:80
203.30.189.29:80
203.30.188.53:80
203.24.103.231:80
91.226.97.83:80
203.24.102.165:80
45.14.174.4:80
23.227.38.87:80
203.28.8.69:80
45.8.105.127:80
203.32.121.154:80
141.193.213.80:80
45.8.107.146:80
45.8.105.5:80
45.8.104.196:80
203.22.223.158:80
45.8.105.217:80
203.24.103.124:80
203.13.32.191:80
203.13.32.124:80
203.13.32.197:80
185.162.230.21:80
203.34.28.202:80
203.30.188.248:80
203.28.9.98:80
203.23.103.213:80
191.101.251.34:80
185.238.228.67:80
141.193.213.120:80
172.67.34.9:80
203.24.108.87:80
45.14.174.51:80
203.28.9.156:80
203.24.102.213:80
45.12.30.196:80
203.23.103.142:80
203.24.109.13:80
203.24.103.109:80
23.227.38.24:80
172.67.171.222:80
172.67.179.209:80
185.238.228.32:80
172.67.156.214:80
172.67.0.9:80
141.101.115.2:80
172.67.3.62:80
172.64.108.12:80
172.67.167.118:80
203.28.8.4:80
203.23.103.194:80
203.22.223.123:80
203.13.32.10:80
203.23.103.233:80
185.162.230.237:80
203.30.191.215:80
203.24.102.96:80
203.24.109.102:80
45.14.174.207:80
185.162.229.206:80
45.8.106.71:80
45.8.105.138:80
185.162.228.7:80
203.32.121.159:80
203.23.104.123:80
185.238.228.192:80
172.67.191.242:80
191.101.251.204:80
141.101.123.23:80
203.28.9.120:80
203.30.189.100:80
203.24.103.117:80
203.24.109.178:80
203.30.190.39:80
203.23.104.147:80
45.12.31.80:80
185.162.231.31:80
91.226.97.183:80
45.12.31.126:80
203.32.121.60:80
185.171.231.137:80
203.24.102.140:80
185.171.231.46:80
203.30.191.182:80
141.193.213.102:80
45.8.104.131:80
203.28.9.102:80
203.30.191.175:80
185.162.231.102:80
203.23.104.182:80
203.24.108.90:80
203.24.102.143:80
203.23.103.40:80
203.28.8.211:80
203.24.108.107:80
45.8.104.239:80
203.22.223.244:80
45.8.106.49:80
203.30.191.183:80
203.30.191.155:80
203.24.103.220:80
203.28.9.150:80
45.8.104.187:80
45.8.104.76:80
203.30.191.28:80
203.28.9.91:80
188.114.97.7:80
188.114.97.1:80
185.238.228.12:80
185.162.229.126:80
203.22.223.201:80
45.14.174.57:80
45.8.104.138:80
185.162.231.251:80
185.162.231.151:80
203.28.8.156:80
45.8.107.9:80
45.12.31.139:80
203.30.190.19:80
185.162.230.189:80
185.171.230.90:80
185.162.231.250:80
45.8.106.206:80
185.162.229.139:80
203.24.102.120:80
185.238.228.132:80
172.67.0.20:80
172.67.43.124:80
172.67.22.228:80
172.67.3.115:80
45.12.31.123:80
203.30.188.45:80
45.8.107.88:80
185.162.229.197:80
203.30.190.240:80
45.8.106.214:80
203.34.28.223:80
185.171.230.165:80
91.226.97.171:80
203.24.108.144:80
203.28.9.116:80
23.227.38.253:80
203.30.191.130:80
203.32.121.175:80
31.43.179.220:80
191.101.251.122:80
141.101.123.218:80
185.221.87.41:80
203.30.189.126:80
185.162.229.194:80
203.24.102.101:80
203.30.190.41:80
203.28.8.40:80
203.30.191.6:80
203.22.223.28:80
203.23.106.66:80
203.30.189.84:80
185.162.229.188:80
203.24.108.52:80
203.30.191.163:80
91.226.97.30:80
45.8.106.177:80
203.23.104.163:80
203.23.103.137:80
185.162.229.85:80
91.226.97.18:80
203.22.223.80:80
91.226.97.21:80
203.30.190.207:80
203.13.32.43:80
45.12.31.248:80
31.43.179.95:80
172.67.118.110:80
203.32.120.248:80
172.67.207.31:80
162.247.243.113:80
31.43.179.215:80
141.193.213.43:80
203.24.103.63:80
203.30.190.142:80
203.32.121.40:80
203.30.191.194:80
91.226.97.138:80
203.30.190.18:80
45.8.107.35:80
185.162.228.219:80
203.23.106.215:80
203.24.102.180:80
185.162.230.84:80
45.8.107.62:80
203.28.8.193:80
203.30.188.102:80
203.30.191.197:80
203.24.102.88:80
203.23.103.24:80
31.43.179.163:80
31.43.179.52:80
191.101.251.72:80
172.67.43.135:80
172.67.43.208:80
31.43.179.252:80
203.24.108.2:80
203.28.9.10:80
45.12.31.91:80
203.32.121.251:80
203.30.188.107:80
203.30.191.166:80
45.8.104.25:80
172.67.171.212:80
172.64.90.57:80
188.114.97.19:80
203.23.106.85:80
203.32.120.36:80
45.8.106.60:80
203.28.8.116:80
203.13.32.149:80
45.8.107.66:80
203.23.104.228:80
45.8.104.161:80
45.12.31.2:80
203.32.121.172:80
203.30.191.11:80
203.32.120.100:80
203.32.121.185:80
203.24.109.214:80
23.227.38.23:80
203.24.103.162:80
172.67.75.198:80
141.101.115.247:80
172.67.122.222:80
172.67.3.0:80
172.67.3.122:80
203.34.28.236:80
203.28.9.12:80
203.30.190.158:80
45.8.105.213:80
203.24.109.175:80
203.24.103.36:80
185.171.231.79:80
185.171.230.73:80
45.8.104.51:80
203.13.32.159:80
203.32.121.99:80
185.162.231.64:80
203.24.103.219:80
45.8.104.89:80
203.30.189.185:80
203.24.108.99:80
203.30.189.191:80
203.28.9.70:80
31.43.179.187:80
162.247.243.226:80
172.67.161.180:80
45.12.31.113:80
172.67.188.9:80
141.101.115.26:80
172.67.70.232:80
172.67.3.87:80
172.67.167.113:80
185.162.230.213:80
203.23.106.167:80
203.24.108.109:80
203.30.189.244:80
203.24.103.22:80
45.8.105.34:80
185.162.230.145:80
185.162.229.195:80
203.23.103.93:80
203.13.32.40:80
45.14.174.204:80
45.12.31.44:80
203.24.109.69:80
185.162.229.159:80
45.12.30.57:80
203.24.103.241:80
203.34.28.147:80
45.8.104.208:80
203.23.104.122:80
172.67.43.131:80
172.67.21.39:80
222.79.249.182:9091
172.67.70.192:80
203.22.223.14:80
172.67.167.8:80
172.67.167.251:80
203.34.28.4:80
185.162.228.34:80
45.8.105.74:80
203.23.104.156:80
203.34.28.13:80
185.162.230.119:80
203.30.189.164:80
203.30.189.119:80
45.12.31.107:80
203.32.120.116:80
203.24.102.169:80
203.28.9.193:80
203.30.191.145:80
45.14.174.149:80
45.8.104.84:80
185.162.228.50:80
203.23.104.37:80
162.247.243.75:80
162.247.243.111:80
172.67.0.21:80
172.67.75.195:80
188.114.99.205:80
172.67.37.63:80
172.67.182.138:80
172.67.3.66:80
203.28.8.37:80
45.8.104.115:80
203.32.120.149:80
185.171.231.20:80
185.171.231.193:80
203.32.120.50:80
203.28.9.160:80
172.67.74.161:80
31.43.179.55:80
185.238.228.207:80
203.30.190.8:80
45.8.106.237:80
45.12.30.107:80
45.8.106.199:80
185.171.230.24:80
185.162.231.8:80
203.34.28.23:80
203.23.106.148:80
191.101.251.171:80
172.64.156.213:80
221.6.215.202:9091
118.212.152.82:9091
172.67.167.55:80
203.13.32.156:80
141.101.123.229:80
172.67.34.10:80
172.67.70.194:80
172.67.3.69:80
172.67.167.4:80
172.67.176.25:80
185.171.230.42:80
185.171.231.21:80
203.23.104.21:80
203.30.188.163:80
203.22.223.128:80
203.30.189.113:80
203.32.120.25:80
203.23.104.237:80
203.23.103.141:80
203.23.104.236:80
203.24.108.248:80
45.8.105.36:80
45.12.31.144:80
91.226.97.67:80
203.24.108.150:80
203.23.106.113:80
203.13.32.220:80
203.34.28.197:80
162.247.243.102:80
172.67.172.168:80
172.67.43.196:80
191.101.251.108:80
203.24.108.174:80
23.227.38.182:80
203.30.188.214:80
23.227.38.213:80
185.162.231.103:80
203.32.120.76:80
203.24.102.42:80
185.162.228.107:80
185.162.228.138:80
203.23.104.215:80
185.162.228.77:80
203.28.8.33:80
185.171.230.255:80
203.24.108.168:80
172.67.34.164:80
172.67.174.180:80
172.67.181.106:80
172.67.0.0:80
185.162.230.110:80
91.226.97.41:80
203.24.103.185:80
203.28.8.0:80
203.22.223.210:80
203.23.106.153:80
45.8.104.212:80
203.34.28.145:80
45.8.107.178:80
203.23.103.168:80
203.28.9.183:80
203.30.189.36:80
203.32.120.133:80
185.162.231.66:80
185.162.228.30:80
185.162.228.244:80
45.8.105.246:80
45.8.105.212:80
203.24.103.199:80
45.14.174.100:80
45.8.105.110:80
185.162.230.141:80
45.14.174.49:80
203.32.120.237:80
185.162.228.202:80
203.23.104.159:80
203.23.104.160:80
191.101.251.3:80
141.193.213.93:80
141.193.213.246:80
172.67.3.120:80
45.12.31.210:80
203.28.9.60:80
203.24.109.211:80
91.226.97.120:80
203.30.190.248:80
185.171.230.158:80
185.162.228.73:80
45.8.106.28:80
203.30.188.79:80
203.24.102.216:80
185.162.231.176:80
185.162.230.76:80
203.28.9.140:80
23.227.38.121:80
185.162.231.241:80
45.12.30.90:80
162.247.243.31:80
191.101.251.125:80
172.64.201.2:80
185.162.228.125:80
203.24.103.87:80
203.24.103.203:80
45.12.31.183:80
23.227.38.161:80
203.22.223.41:80
45.8.106.176:80
31.43.179.84:80
172.67.75.190:80
172.67.70.28:80
23.227.38.117:80
203.23.103.95:80
185.171.231.192:80
185.162.229.16:80
203.30.188.139:80
203.22.223.2:80
45.12.31.180:80
45.8.106.129:80
203.24.108.12:80
185.162.231.16:80
203.13.32.21:80
45.14.174.133:80
203.34.28.161:80
45.8.106.86:80
45.8.104.1:80
203.23.106.171:80
185.162.228.140:80
185.162.231.179:80
203.28.8.43:80
203.32.121.1:80
203.30.189.193:80
203.24.102.103:80
45.12.30.191:80
203.34.28.138:80
45.8.105.251:80
203.24.102.239:80
203.32.121.51:80
185.171.230.17:80
191.101.251.156:80
162.247.243.20:80
203.28.9.172:80
185.238.228.148:80
31.43.179.57:80
172.67.167.198:80
203.30.190.24:80
203.28.9.242:80
203.24.103.3:80
203.24.102.81:80
45.8.105.220:80
185.162.229.203:80
185.162.231.133:80
185.171.230.82:80
185.162.230.50:80
45.14.174.113:80
203.24.108.85:80
185.171.230.61:80
203.23.104.149:80
45.14.174.147:80
91.226.97.251:80
203.22.223.203:80
162.247.243.166:80
141.193.213.241:80
162.247.243.143:80
103.21.244.25:80
203.13.32.233:80
203.34.28.209:80
45.8.107.201:80
203.23.103.124:80
203.28.9.225:80
203.24.109.183:80
203.23.104.70:80
185.162.230.22:80
203.24.102.89:80
45.14.174.43:80
45.8.107.108:80
203.24.108.20:80
91.226.97.188:80
203.13.32.182:80
45.8.105.56:80
185.162.228.83:80
203.24.103.52:80
203.32.121.101:80
203.32.121.95:80
185.171.231.38:80
203.13.32.210:80
203.32.120.228:80
45.8.106.252:80
203.24.109.43:80
185.162.228.124:80
172.67.8.19:80
172.67.75.169:80
172.67.75.165:80
172.67.75.187:80
141.193.213.71:80
45.14.174.58:80
124.131.219.94:9091
172.67.70.131:80
172.67.3.140:80
172.67.167.234:80
45.8.106.185:80
203.13.32.109:80
203.23.104.162:80
203.30.189.138:80
185.162.228.164:80
203.22.223.115:80
185.171.231.37:80
91.226.97.140:80
185.162.228.38:80
45.12.31.245:80
45.14.174.90:80
45.8.107.244:80
185.162.229.2:80
203.13.32.199:80
203.22.223.250:80
45.8.107.128:80
185.162.230.236:80
45.8.106.106:80
203.23.106.77:80
23.227.38.135:80
45.8.105.99:80
45.14.174.225:80
203.23.104.249:80
45.8.107.250:80
185.162.230.201:80
203.23.106.88:80
185.171.230.236:80
31.43.179.195:80
172.67.75.171:80
172.67.125.224:80
172.67.181.227:80
172.67.75.175:80
31.43.179.223:80
172.67.117.192:80
103.21.244.37:80
185.162.230.217:80
172.67.177.251:80
185.162.228.186:80
203.13.32.62:80
203.32.120.249:80
203.23.103.126:80
203.32.121.109:80
203.13.32.173:80
203.30.190.175:80
203.30.190.65:80
45.12.30.173:80
45.8.107.154:80
31.43.179.156:80
191.101.251.196:80
130.61.157.52:80
172.67.43.110:80
172.67.167.61:80
172.67.27.32:80
162.247.243.225:80
172.67.173.43:80
172.67.181.15:80
172.67.68.10:80
203.24.103.226:80
45.12.30.104:80
185.162.231.198:80
203.22.223.124:80
185.171.231.159:80
203.24.102.105:80
185.171.231.51:80
185.171.230.166:80
203.32.121.96:80
91.226.97.161:80
203.30.189.161:80
185.162.229.48:80
185.162.229.202:80
91.226.97.69:80
203.13.32.234:80
45.8.104.214:80
203.34.28.9:80
185.238.228.145:80
203.24.103.232:80
203.32.121.231:80
203.30.191.88:80
203.30.191.176:80
203.30.188.22:80
45.12.30.164:80
203.32.121.124:80
203.28.8.51:80
185.162.228.43:80
23.227.38.110:80
45.12.31.157:80
185.162.229.245:80
203.13.32.239:80
45.14.174.220:80
203.30.189.140:80
45.14.174.22:80
185.162.229.125:80
31.43.179.32:80
121.22.53.166:9091
185.162.230.172:80
172.67.181.20:80
141.101.123.227:80
141.101.123.20:80
203.28.9.206:80
172.67.167.156:80
45.12.31.121:80
203.28.9.119:80
203.22.223.98:80
203.30.191.91:80
203.30.190.79:80
185.171.231.132:80
203.23.104.169:80
185.162.230.212:80
45.8.104.190:80
203.28.8.137:80
185.162.231.227:80
203.23.103.193:80
185.162.231.35:80
185.162.231.1:80
203.32.121.17:80
185.162.230.241:80
203.23.103.210:80
203.32.120.32:80
203.22.223.18:80
203.22.223.205:80
203.13.32.252:80
185.162.230.188:80
31.43.179.158:80
172.67.75.150:80
172.67.43.129:80
203.24.109.126:80
141.193.213.205:80
188.114.96.171:80
223.112.174.62:9091
172.67.181.107:80
172.67.255.117:80
203.24.102.18:80
45.8.106.95:80
45.8.106.36:80
185.162.228.121:80
172.67.180.210:80
172.67.181.143:80
203.28.9.15:80
45.14.174.14:80
45.12.31.22:80
203.22.223.19:80
185.162.228.141:80
203.32.121.180:80
23.227.38.227:80
45.8.107.70:80
91.226.97.155:80
45.8.107.41:80
203.13.32.130:80
203.32.120.134:80
185.171.231.50:80
185.171.230.21:80
45.8.106.54:80
185.162.228.162:80
203.30.189.213:80
185.162.229.218:80
23.227.38.248:80
185.162.230.174:80
45.8.107.94:80
203.22.223.85:80
185.162.228.168:80
203.23.104.55:80
203.13.32.247:80
172.67.72.1:80
185.171.231.72:80
185.171.231.164:80
203.13.32.117:80
45.12.30.249:80
203.13.32.146:80
45.8.105.43:80
45.12.31.24:80
31.43.179.8:80
172.67.43.231:80
141.193.213.91:80
203.32.121.71:80
45.8.106.130:80
203.30.190.184:80
203.30.188.7:80
203.23.106.96:80
185.162.231.169:80
45.8.105.167:80
45.8.107.213:80
45.8.107.75:80
203.30.189.25:80
45.8.107.180:80
203.32.120.150:80
203.13.32.3:80
203.22.223.148:80
45.12.30.197:80
45.8.104.46:80
185.171.231.105:80
185.162.229.210:80
172.67.69.86:80
139.255.74.125:8080
95.140.31.39:41890
183.88.135.151:8080
179.1.73.100:999
159.65.133.175:31280
85.14.243.31:3128
172.67.176.24:80
172.67.182.63:80
172.67.70.72:80
172.67.70.52:80
203.22.223.152:80
203.24.102.100:80
203.23.103.253:80
185.162.231.184:80
91.226.97.149:80
185.162.229.27:80
185.171.230.126:80
45.8.104.219:80
45.8.107.219:80
203.28.9.228:80
203.24.109.84:80
203.30.188.252:80
185.171.230.135:80
203.30.189.77:80
203.28.9.93:80
203.30.189.64:80
203.34.28.157:80
31.43.179.189:80
141.193.213.108:80
185.238.228.222:80
172.67.8.155:80
45.8.105.202:80
203.24.109.34:80
203.30.190.2:80
203.22.223.163:80
45.14.174.141:80
45.14.174.9:80
172.67.3.59:80
203.34.28.3:80
91.226.97.24:80
203.13.32.155:80
45.14.174.111:80
23.227.38.58:80
203.22.223.172:80
45.12.31.17:80
203.30.189.132:80
185.162.230.171:80
203.24.108.36:80
203.30.191.102:80
203.30.191.136:80
45.12.30.155:80
203.28.8.95:80
172.67.171.220:80
172.67.73.212:80
103.21.244.26:80
45.8.104.119:80
203.23.106.154:80
45.12.30.28:80
185.171.230.136:80
203.23.104.173:80
45.8.105.89:80
23.227.38.41:80
45.8.107.103:80
203.30.190.241:80
203.34.28.243:80
45.8.105.227:80
45.8.104.120:80
185.162.229.61:80
45.8.106.215:80
203.30.188.160:80
23.227.38.164:80
185.162.229.199:80
203.13.32.112:80
203.28.9.74:80
203.23.103.4:80
203.24.102.73:80
203.23.103.228:80
203.32.120.137:80
185.162.229.244:80
45.12.31.14:80
203.23.104.66:80
203.28.9.13:80
203.22.223.65:80
185.162.228.154:80
203.30.189.144:80
191.101.251.145:80
172.67.75.180:80
172.67.25.199:80
172.67.3.100:80
203.23.106.195:80
185.171.231.178:80
45.12.31.13:80
203.23.103.78:80
203.24.102.183:80
185.171.230.161:80
203.28.8.236:80
23.227.38.154:80
203.13.32.134:80
203.23.106.172:80
23.227.38.220:80
203.23.106.245:80
203.30.188.92:80
185.171.231.141:80
203.23.106.140:80
45.8.105.13:80
203.23.106.22:80
172.67.192.43:80
193.138.178.6:8282
58.147.186.226:8080
94.28.32.117:8080
91.226.97.232:80
185.171.230.249:80
203.13.32.114:80
185.162.229.119:80
45.8.105.228:80
203.30.191.135:80
45.8.106.64:80
203.23.104.24:80
203.30.189.198:80
173.245.49.114:80
203.30.188.5:80
185.238.228.8:80
172.67.75.152:80
191.101.251.30:80
191.101.251.25:80
185.238.228.60:80
112.250.110.172:9091
172.67.181.47:80
141.101.123.215:80
172.67.70.37:80
172.67.70.254:80
103.21.244.24:80
172.67.3.107:80
203.28.9.231:80
203.24.103.224:80
203.32.120.158:80
203.22.223.45:80
203.23.103.207:80
45.8.105.133:80
203.23.104.36:80
185.162.230.92:80
203.22.223.236:80
203.22.223.133:80
203.23.104.26:80
203.34.28.235:80
203.23.103.83:80
203.30.189.226:80
203.30.188.23:80
203.30.188.151:80
203.23.103.2:80
203.34.28.170:80
203.28.8.190:80
45.14.174.158:80
45.12.31.136:80
162.247.243.53:80
172.67.75.15:80
141.193.213.122:80
185.238.228.49:80
203.23.106.45:80
188.114.96.254:80
172.67.202.134:80
203.30.190.28:80
45.8.104.22:80
203.23.103.146:80
203.23.106.200:80
162.247.243.230:80
172.64.129.2:80
172.67.182.114:80
91.226.97.114:80
172.67.3.147:80
172.67.3.130:80
203.22.223.215:80
203.23.104.190:80
203.24.109.93:80
203.30.191.113:80
203.28.9.104:80
45.8.105.30:80
23.227.38.228:80
185.171.231.209:80
45.14.174.217:80
203.28.8.250:80
203.30.188.118:80
45.8.106.4:80
203.28.8.86:80
203.24.103.17:80
185.162.231.30:80
203.30.191.234:80
203.28.9.205:80
203.24.109.199:80
45.14.174.201:80
185.171.231.143:80
45.12.31.112:80
203.32.121.8:80
203.32.121.34:80
203.22.223.40:80
91.226.97.109:80
185.162.229.72:80
23.227.38.234:80
45.8.107.27:80
203.13.32.31:80
31.43.179.17:80
191.101.251.105:80
185.238.228.129:80
162.247.241.13:80
31.43.179.26:80
172.67.33.197:80
172.66.40.203:80
173.212.224.134:3128
47.243.91.156:3128
47.243.99.43:3128
176.9.20.195:8080
221.193.240.115:9091
172.67.70.201:80
172.67.3.133:80
172.67.169.199:80
185.162.229.67:80
45.8.107.167:80
172.67.167.157:80
172.67.177.174:80
203.30.190.237:80
23.227.38.105:80
203.32.121.153:80
203.30.191.140:80
45.12.30.118:80
45.8.106.223:80
203.32.120.154:80
203.32.121.16:80
185.162.229.216:80
203.28.9.243:80
203.24.102.181:80
185.162.231.53:80
203.24.108.18:80
203.34.28.79:80
203.30.188.141:80
203.30.190.40:80
45.8.106.172:80
45.14.174.187:80
185.162.229.143:80
172.67.176.58:80
31.43.179.122:80
141.193.213.3:80
141.193.213.197:80
191.101.251.188:80
172.67.43.169:80
141.193.213.53:80
45.12.30.174:80
23.227.38.6:80
185.162.229.198:80
45.12.30.87:80
45.8.106.149:80
203.28.9.169:80
203.30.191.187:80
203.24.102.206:80
203.22.223.138:80
185.238.228.107:80
172.67.255.223:80
172.67.3.145:80
172.67.3.71:80
45.8.104.0:80
45.8.106.194:80
45.14.174.127:80
203.24.108.201:80
45.8.104.55:80
45.14.174.102:80
45.8.104.15:80
203.28.8.91:80
203.23.106.138:80
45.12.31.118:80
203.30.191.230:80
203.24.103.179:80
45.12.30.66:80
185.162.231.110:80
185.162.228.177:80
203.34.28.46:80
203.28.9.130:80
185.171.231.160:80
45.14.174.185:80
203.34.28.139:80
45.8.105.103:80
203.28.9.210:80
203.32.121.190:80
45.8.105.211:80
203.24.103.76:80
45.12.30.72:80
185.171.231.169:80
45.8.107.168:80
185.171.231.180:80
31.43.179.241:80
172.67.171.226:80
185.238.228.100:80
162.247.243.70:80
185.238.228.217:80
141.193.213.151:80
138.68.147.101:80
31.43.179.51:80
172.64.172.2:80
172.67.3.102:80
203.32.120.135:80
203.30.191.212:80
185.171.231.252:80
185.162.228.249:80
203.30.189.216:80
185.171.230.180:80
203.30.188.181:80
185.171.231.168:80
203.22.223.75:80
31.43.179.154:80
162.247.243.56:80
141.101.120.10:80
172.67.8.106:80
172.67.73.231:80
185.171.231.214:80
203.24.109.101:80
23.227.38.247:80
185.171.230.250:80
185.171.230.101:80
203.23.104.111:80
203.32.120.174:80
185.171.231.33:80
203.30.188.169:80
203.13.32.235:80
203.23.104.227:80
172.67.16.210:80
172.67.43.157:80
172.67.192.3:80
141.193.213.138:80
141.193.213.176:80
172.67.54.32:80
172.67.11.166:80
141.101.115.9:80
45.14.174.105:80
203.32.121.91:80
203.30.191.78:80
45.8.105.159:80
203.24.108.225:80
45.8.107.123:80
203.24.109.12:80
203.23.103.90:80
45.8.107.3:80
45.8.106.27:80
91.226.97.242:80
203.32.121.218:80
203.24.103.104:80
203.28.8.35:80
185.162.229.34:80
45.12.30.147:80
203.22.223.1:80
203.24.103.216:80
203.24.109.217:80
203.24.109.63:80
45.8.105.233:80
45.12.30.171:80
185.162.231.253:80
203.24.109.181:80
45.12.30.95:80
203.32.121.48:80
45.8.106.132:80
185.162.231.177:80
185.162.231.34:80
203.23.103.250:80
45.8.105.252:80
185.238.228.153:80
172.67.191.223:80
172.67.70.90:80
203.23.103.98:80
203.24.108.62:80
203.23.103.166:80
45.14.174.62:80
203.24.102.187:80
203.30.188.216:80
185.171.230.48:80
185.162.229.250:80
203.23.106.107:80
45.12.30.43:80
185.162.228.39:80
203.28.8.114:80
45.14.174.210:80
185.162.228.241:80
45.8.105.3:80
203.24.103.116:80
45.12.30.224:80
185.162.231.154:80
203.28.8.247:80
45.12.31.205:80
185.171.230.104:80
203.22.223.185:80
185.162.230.151:80
45.8.106.101:80
45.8.107.172:80
203.30.188.242:80
203.28.9.89:80
45.12.31.153:80
203.24.109.155:80
185.162.229.214:80
185.162.230.99:80
45.8.107.79:80
203.24.102.93:80
191.101.251.111:80
162.247.243.152:80
172.67.173.124:80
172.67.3.75:80
23.227.38.19:80
172.67.167.44:80
45.14.174.37:80
203.28.8.232:80
203.24.109.162:80
203.30.188.100:80
203.22.223.71:80
203.13.32.225:80
203.32.120.145:80
45.8.106.96:80
45.14.174.124:80
173.245.49.52:80
203.30.188.156:80
45.8.105.222:80
45.14.174.21:80
91.226.97.76:80
45.8.107.122:80
203.22.223.60:80
23.227.38.203:80
172.64.133.2:80
172.67.70.13:80
203.28.9.200:80
203.28.9.238:80
203.30.189.199:80
203.23.106.24:80
203.23.103.86:80
45.8.105.143:80
23.227.38.188:80
45.14.174.184:80
23.227.38.206:80
203.23.104.99:80
203.32.120.24:80
203.24.109.18:80
45.8.106.216:80
203.24.108.220:80
91.226.97.196:80
45.8.106.217:80
203.30.191.49:80
45.12.30.152:80
203.24.108.40:80
45.12.30.153:80
203.30.189.37:80
191.101.251.51:80
172.67.75.202:80
31.43.179.243:80
172.67.185.204:80
185.238.228.45:80
191.101.251.21:80
141.193.213.132:80
172.67.35.15:80
172.67.2.16:80
172.67.73.5:80
203.24.103.18:80
45.14.174.131:80
203.30.188.18:80
185.162.229.14:80
203.28.8.231:80
203.30.188.20:80
203.28.8.130:80
185.162.230.123:80
203.32.120.34:80
203.32.121.74:80
203.22.223.109:80
45.8.104.90:80
203.28.8.38:80
203.24.102.58:80
203.32.120.225:80
203.30.189.110:80
203.30.190.252:80
23.227.38.155:80
45.12.30.195:80
45.12.31.236:80
203.28.8.71:80
185.162.229.81:80
45.8.107.116:80
31.43.179.174:80
191.101.251.22:80
185.238.228.4:80
141.193.213.250:80
172.66.44.95:80
172.67.167.43:80
172.64.69.135:80
172.67.200.220:80
172.67.17.123:80
91.226.97.94:80
203.32.120.62:80
45.8.106.107:80
203.30.188.164:80
203.24.103.197:80
203.32.121.41:80
185.162.231.52:80
45.14.174.200:80
45.8.104.177:80
45.8.106.72:80
185.238.228.249:80
172.67.170.28:80
172.67.192.6:80
161.35.154.174:80
31.43.179.186:80
203.23.104.131:80
203.28.9.25:80
203.23.103.20:80
45.8.104.171:80
203.24.108.200:80
23.227.38.2:80
45.8.107.0:80
37.32.40.178:8080
23.227.38.166:80
203.28.9.185:80
203.34.28.191:80
203.30.189.1:80
203.34.28.85:80
185.162.229.91:80
45.14.174.87:80
203.30.189.117:80
45.8.106.200:80
45.8.105.97:80
45.8.107.138:80
203.24.102.217:80
185.162.229.62:80
185.162.231.101:80
45.8.105.173:80
45.14.174.104:80
45.8.105.164:80
45.8.107.64:80
203.23.104.174:80
185.171.231.225:80
185.162.228.61:80
91.226.97.121:80
45.12.31.31:80
172.67.75.196:80
172.67.43.179:80
172.67.185.205:80
172.67.192.56:80
172.67.7.19:80
130.61.172.176:80
45.8.107.18:80
185.162.229.63:80
203.24.103.211:80
203.24.109.198:80
185.162.229.243:80
45.8.104.54:80
45.8.105.78:80
185.162.228.112:80
45.8.104.14:80
185.162.230.163:80
203.22.223.112:80
45.14.174.108:80
203.23.104.29:80
173.245.49.3:80
185.162.230.39:80
203.24.109.98:80
203.32.121.194:80
45.8.106.68:80
203.34.28.252:80
91.226.97.143:80
203.13.32.25:80
185.171.230.191:80
203.22.223.186:80
185.171.230.12:80
203.30.191.209:80
45.12.30.48:80
45.8.107.197:80
45.12.31.159:80
45.14.174.77:80
203.23.104.120:80
203.32.121.115:80
203.30.189.141:80
45.12.31.59:80
185.238.228.203:80
188.114.97.8:80
172.67.3.135:80
185.171.230.162:80
203.28.9.63:80
203.30.190.206:80
45.8.104.204:80
45.8.104.213:80
203.30.189.102:80
185.171.231.77:80
203.32.120.115:80
203.24.108.110:80
203.28.9.46:80
203.30.188.228:80
203.32.120.72:80
203.24.109.133:80
185.171.230.67:80
203.24.109.208:80
172.67.75.201:80
172.67.74.230:80
172.64.152.2:80
103.21.244.9:80
203.28.9.232:80
203.28.9.155:80
45.12.30.77:80
203.22.223.171:80
185.162.230.139:80
203.23.106.59:80
203.30.188.184:80
23.227.38.130:80
203.24.103.250:80
203.30.189.101:80
203.24.102.157:80
185.171.230.244:80
31.43.179.210:80
172.67.23.56:80
203.34.28.38:80
203.24.109.188:80
203.30.191.20:80
185.162.228.253:80
185.162.228.224:80
45.8.104.26:80
203.30.188.250:80
45.12.31.239:80
203.32.121.234:80
185.171.230.119:80
91.226.97.118:80
203.24.103.91:80
203.30.189.49:80
91.226.97.157:80
203.24.102.43:80
203.24.108.249:80
45.8.104.207:80
203.28.8.171:80
203.30.191.151:80
45.8.106.241:80
185.238.228.158:80
172.67.181.75:80
185.171.230.195:80
203.23.103.30:80
203.24.109.191:80
203.30.190.104:80
185.162.231.3:80
203.28.8.234:80
203.32.120.152:80
203.32.120.49:80
203.24.109.232:80
185.162.228.176:80
45.8.106.67:80
203.30.188.203:80
185.162.230.60:80
45.12.30.101:80
203.28.8.45:80
203.28.8.199:80
203.23.106.124:80
185.162.229.50:80
203.28.9.54:80
185.171.231.227:80
203.32.120.109:80
203.23.103.217:80
203.30.191.184:80
45.12.31.169:80
45.8.104.73:80
203.13.32.165:80
203.30.189.165:80
203.13.32.135:80
162.247.243.103:80
172.67.192.1:80
172.67.192.50:80
141.193.213.30:80
141.101.123.28:80
185.162.229.74:80
203.23.106.212:80
203.13.32.8:80
203.30.189.201:80
31.43.179.161:80
172.64.143.2:80
190.93.247.2:80
172.67.3.79:80
203.28.8.251:80
185.171.230.69:80
172.67.167.106:80
185.162.231.76:80
185.162.231.26:80
91.226.97.58:80
203.32.121.4:80
45.8.107.149:80
45.8.105.121:80
203.24.108.219:80
23.227.38.86:80
45.8.106.3:80
203.30.189.189:80
203.30.188.233:80
45.8.104.79:80
45.14.174.171:80
45.12.31.165:80
23.227.38.201:80
45.8.104.72:80
203.24.108.70:80
203.30.191.39:80
203.23.104.109:80
185.162.230.77:80
45.8.104.102:80
203.28.9.181:80
203.28.9.68:80
203.32.121.144:80
45.12.30.216:80
203.34.28.52:80
203.30.188.6:80
45.14.174.59:80
203.13.32.46:80
31.43.179.179:80
172.67.43.160:80
172.67.43.234:80
162.247.243.66:80
172.64.171.2:80
141.101.115.252:80
185.171.231.99:80
185.162.231.254:80
203.28.8.158:80
191.101.251.7:80
185.162.228.32:80
203.13.32.49:80
185.162.229.152:80
45.12.31.191:80
185.162.228.4:80
23.227.38.221:80
203.24.109.129:80
203.28.8.7:80
203.23.103.92:80
45.8.104.199:80
191.101.251.126:80
141.101.113.2:80
172.67.176.171:80
45.8.107.223:80
45.12.31.111:80
185.162.229.99:80
203.32.120.222:80
45.12.31.106:80
185.162.229.54:80
203.23.103.12:80
203.13.32.87:80
203.30.188.171:80
203.24.108.233:80
203.30.191.5:80
185.171.231.84:80
185.162.230.193:80
203.23.103.187:80
45.8.105.230:80
185.171.230.83:80
203.28.8.76:80
203.22.223.204:80
203.32.120.213:80
203.30.191.89:80
203.23.103.122:80
45.8.105.149:80
203.24.109.122:80
185.171.230.80:80
203.24.109.52:80
203.22.223.116:80
203.32.121.128:80
203.22.223.13:80
185.162.231.160:80
203.30.188.109:80
203.32.121.219:80
203.23.106.1:80
45.8.107.42:80
172.67.43.72:80
185.238.228.14:80
172.67.110.33:80
190.93.244.26:80
103.21.244.31:80
203.30.188.150:80
203.34.28.186:80
91.226.97.91:80
45.8.107.235:80
203.30.190.21:80
185.162.228.231:80
203.22.223.154:80
185.171.231.36:80
203.30.189.70:80
203.30.190.205:80
203.23.106.132:80
185.171.231.15:80
203.22.223.73:80
203.30.190.84:80
203.32.120.227:80
185.162.229.33:80
203.34.28.130:80
203.24.103.99:80
203.30.191.137:80
191.101.251.38:80
185.238.228.181:80
191.101.251.160:80
185.162.231.166:80
172.67.3.81:80
172.67.3.60:80
91.226.97.40:80
203.22.223.230:80
203.24.108.100:80
203.30.189.209:80
45.12.30.200:80
185.162.231.236:80
45.12.31.29:80
203.30.188.94:80
203.13.32.183:80
203.32.121.113:80
203.32.120.96:80
203.30.188.186:80
203.32.121.179:80
203.24.102.185:80
45.12.30.79:80
203.24.109.239:80
23.227.38.56:80
203.30.188.138:80
185.162.229.185:80
45.8.106.227:80
185.238.228.9:80
203.23.103.112:80
172.67.68.234:80
172.67.180.27:80
203.23.104.225:80
45.8.104.144:80
203.24.109.113:80
185.171.230.217:80
185.162.231.147:80
45.8.105.147:80
185.171.231.253:80
203.22.223.243:80
203.23.106.56:80
203.24.103.14:80
203.30.190.58:80
203.23.103.119:80
203.34.28.242:80
185.171.230.66:80
185.171.231.174:80
185.171.231.4:80
203.24.108.57:80
185.162.229.135:80
203.24.108.84:80
164.90.177.61:80
162.247.243.11:80
203.32.121.161:80
172.67.182.69:80
172.67.181.62:80
203.24.102.113:80
23.227.38.97:80
203.24.108.148:80
203.34.28.136:80
203.30.188.235:80
203.32.120.12:80
185.171.231.115:80
185.162.231.185:80
45.8.107.133:80
203.24.103.134:80
185.162.229.117:80
203.30.191.86:80
203.23.106.228:80
203.23.104.194:80
185.171.230.215:80
45.8.104.245:80
185.162.230.229:80
203.30.190.77:80
45.12.31.224:80
185.162.230.0:80
45.8.107.76:80
203.34.28.254:80
185.171.230.54:80
203.28.8.145:80
185.171.230.182:80
45.12.31.223:80
185.171.231.176:80
91.226.97.151:80
203.24.109.88:80
91.226.97.214:80
45.8.105.125:80
185.171.231.196:80
203.28.9.198:80
45.8.106.212:80
45.12.31.218:80
45.12.30.94:80
45.8.105.172:80
45.12.31.189:80
203.30.189.26:80
185.171.231.45:80
203.23.106.15:80
203.24.103.190:80
185.171.230.224:80
91.226.97.2:80
45.12.31.74:80
203.28.9.103:80
45.8.105.234:80
185.162.229.237:80
185.238.228.254:80
185.238.228.117:80
45.8.104.111:80
203.24.102.176:80
45.12.31.33:80
203.23.106.69:80
45.8.104.233:80
185.162.228.105:80
45.14.174.94:80
203.23.106.80:80
203.28.8.194:80
203.34.28.207:80
203.23.106.33:80
23.227.38.1:80
45.12.31.147:80
203.32.120.130:80
185.171.231.117:80
203.30.190.151:80
45.8.105.207:80
45.12.30.26:80
203.24.108.222:80
203.28.9.45:80
191.101.251.9:80
172.67.179.200:80
172.64.204.2:80
221.4.241.198:9091
218.28.98.229:9091
41.203.83.66:8080
120.196.188.21:9091
58.17.24.162:9091
58.246.58.150:9002
172.67.3.64:80
203.32.121.46:80
203.30.189.44:80
203.23.106.68:80
203.30.188.21:80
203.23.103.105:80
185.162.230.44:80
203.22.223.27:80
203.24.103.170:80
45.8.106.226:80
203.30.188.80:80
203.24.108.143:80
143.47.188.34:80
172.67.34.8:80
45.12.30.159:80
185.162.228.240:80
45.12.30.169:80
45.8.106.131:80
203.32.121.171:80
45.8.106.165:80
45.8.106.242:80
91.226.97.210:80
203.13.32.123:80
185.162.230.248:80
203.34.28.76:80
23.227.38.211:80
203.32.121.21:80
45.12.30.60:80
185.162.231.36:80
203.32.120.247:80
45.12.30.27:80
185.162.231.233:80
203.30.188.121:80
203.23.106.111:80
203.24.109.243:80
203.34.28.32:80
203.30.188.14:80
188.114.98.138:80
31.43.179.6:80
185.238.228.189:80
31.43.179.218:80
159.112.235.0:80
172.67.43.224:80
172.64.159.2:80
172.64.158.2:80
172.67.23.152:80
203.34.28.92:80
45.12.31.68:80
185.171.231.0:80
203.30.189.250:80
203.24.108.141:80
45.14.174.229:80
185.162.229.28:80
203.30.191.29:80
45.8.105.209:80
203.23.103.94:80
45.8.105.158:80
45.8.105.2:80
203.24.102.12:80
185.171.231.78:80
203.28.8.215:80
23.227.38.237:80
203.30.188.230:80
31.43.179.129:80
31.43.179.66:80
141.101.113.0:80
172.67.165.107:80
162.247.243.91:80
172.67.182.99:80
185.171.230.204:80
45.14.174.202:80
203.30.189.170:80
185.162.231.45:80
203.13.32.81:80
45.8.106.15:80
45.12.30.82:80
185.162.228.97:80
203.28.9.204:80
185.162.230.61:80
203.23.106.205:80
185.238.228.215:80
185.162.231.25:80
172.67.70.9:80
172.67.70.171:80
172.67.3.118:80
45.8.106.39:80
45.8.104.209:80
185.162.230.251:80
203.24.102.115:80
203.24.109.215:80
203.23.103.178:80
203.28.8.163:80
23.227.38.79:80
185.162.229.70:80
203.30.190.5:80
203.34.28.59:80
91.226.97.59:80
203.24.109.160:80
185.238.228.194:80
141.193.213.112:80
141.193.213.210:80
172.67.56.226:80
103.160.132.26:83
103.4.94.12:3128
47.74.152.29:8888
172.67.182.126:80
203.28.8.136:80
185.162.229.219:80
185.238.228.63:80
172.67.11.138:80
203.28.9.20:80
172.67.167.226:80
45.8.106.143:80
203.28.8.118:80
45.8.105.23:80
203.34.28.246:80
45.14.174.175:80
203.30.189.137:80
45.14.174.228:80
203.22.223.192:80
203.32.121.195:80
45.8.105.188:80
203.28.9.135:80
203.30.190.112:80
203.23.104.241:80
203.24.109.27:80
203.23.106.131:80
185.162.231.55:80
172.67.171.221:80
172.67.75.168:80
172.67.181.93:80
190.93.244.171:80
172.67.3.84:80
203.23.104.166:80
45.12.30.32:80
203.32.120.1:80
203.32.120.79:80
203.13.32.38:80
203.23.106.128:80
203.28.9.239:80
203.32.121.202:80
185.162.228.127:80
203.22.223.217:80
185.171.231.96:80
203.28.9.189:80
203.30.189.160:80
23.227.38.143:80
45.8.105.9:80
45.8.104.133:80
172.67.75.163:80
162.247.243.86:80
172.67.181.231:80
172.67.82.234:80
172.67.182.2:80
172.67.168.132:80
203.23.103.89:80
203.30.188.167:80
45.8.105.28:80
45.8.104.63:80
203.32.120.45:80
45.8.105.120:80
45.8.104.93:80
203.24.108.142:80
203.32.120.215:80
91.226.97.123:80
203.34.28.73:80
203.28.8.65:80
45.14.174.17:80
203.32.121.162:80
185.171.231.81:80
203.30.190.117:80
172.67.43.99:80
172.67.70.164:80
172.67.70.62:80
172.67.70.255:80
185.162.228.166:80
45.8.104.247:80
203.28.8.120:80
203.22.223.7:80
203.24.102.126:80
45.8.106.195:80
203.24.103.78:80
203.23.104.196:80
203.23.103.101:80
203.32.121.210:80
203.24.108.119:80
203.32.121.143:80
45.12.31.215:80
45.12.30.41:80
203.22.223.198:80
172.67.188.27:80
172.67.181.239:80
172.64.137.163:80
45.8.105.52:80
203.32.121.3:80
203.30.190.80:80
203.23.106.199:80
45.12.30.250:80
185.171.231.23:80
203.24.109.177:80
191.101.251.230:80
218.244.147.59:3128
103.156.15.48:8080
182.253.140.250:8080
190.186.1.65:999
36.92.43.107:8080
117.54.114.101:80
203.23.104.172:80
45.8.107.40:80
141.193.213.115:80
172.67.3.128:80
185.162.228.165:80
203.30.189.218:80
203.24.103.202:80
185.162.228.155:80
203.30.188.67:80
185.171.230.16:80
203.23.104.151:80
45.8.105.130:80
45.12.31.166:80
45.8.107.159:80
185.162.230.91:80
185.162.228.96:80
203.13.32.166:80
203.22.223.91:80
203.13.32.251:80
203.24.103.53:80
203.23.104.155:80
203.23.106.162:80
203.24.102.37:80
203.24.103.221:80
185.238.228.18:80
203.28.8.227:80
185.162.228.76:80
203.13.32.61:80
185.162.228.131:80
45.8.105.90:80
45.14.174.191:80
203.24.102.104:80
203.34.28.56:80
185.171.230.114:80
203.30.190.225:80
203.23.106.28:80
203.30.191.126:80
172.64.170.2:80
172.67.70.67:80
45.8.105.155:80
203.34.28.122:80
203.32.121.250:80
188.114.96.5:80
172.67.70.85:80
203.23.104.168:80
185.162.231.137:80
185.171.231.83:80
203.24.108.26:80
203.34.28.133:80
185.162.230.45:80
203.23.103.54:80
45.8.104.116:80
185.162.229.21:80
203.23.104.213:80
203.24.102.166:80
45.8.104.218:80
203.24.109.100:80
45.8.104.222:80
203.23.106.221:80
45.12.31.52:80
185.162.229.120:80
203.30.190.27:80
203.28.8.131:80
203.23.106.82:80
203.28.8.41:80
185.162.228.78:80
203.23.106.50:80
203.32.121.45:80
45.8.106.19:80
185.162.228.130:80
185.162.228.60:80
91.226.97.145:80
203.34.28.22:80
203.24.108.194:80
185.238.228.200:80
172.67.43.108:80
45.8.106.97:80
203.34.28.213:80
203.24.103.233:80
185.162.230.51:80
45.8.107.210:80
203.28.9.217:80
203.30.189.78:80
203.13.32.34:80
203.30.191.132:80
203.30.188.166:80
203.23.106.16:80
203.24.103.184:80
203.24.102.119:80
203.23.103.202:80
203.13.32.189:80
45.8.105.254:80
203.30.190.71:80
203.22.223.194:80
203.23.106.232:80
45.8.106.174:80
45.8.106.33:80
45.14.174.213:80
203.34.28.220:80
172.67.75.203:80
203.28.9.214:80
203.30.189.71:80
203.22.223.122:80
203.30.190.223:80
185.171.230.163:80
203.24.103.71:80
185.171.231.185:80
203.23.103.121:80
203.30.191.141:80
185.162.228.254:80
203.22.223.202:80
203.23.106.71:80
45.8.107.129:80
203.13.32.129:80
23.227.38.129:80
203.34.28.174:80
31.43.179.138:80
172.67.187.247:80
141.193.213.33:80
162.247.241.6:80
173.245.49.44:80
172.67.70.213:80
172.67.70.184:80
172.67.3.151:80
185.162.229.179:80
185.162.231.215:80
185.171.230.78:80
203.32.120.178:80
203.24.103.111:80
203.34.28.29:80
185.162.230.79:80
185.171.231.60:80
185.162.229.118:80
45.8.106.92:80
185.171.230.150:80
45.8.106.35:80
203.23.103.147:80
203.30.191.191:80
45.8.105.91:80
185.171.231.249:80
185.162.231.229:80
203.24.108.5:80
203.30.188.247:80
185.162.231.226:80
203.28.9.50:80
31.43.179.204:80
185.171.231.171:80
162.247.243.216:80
172.67.43.216:80
31.43.179.103:80
31.43.179.39:80
185.238.228.44:80
172.67.73.149:80
172.67.3.104:80
172.67.180.63:80
185.162.231.158:80
45.8.107.61:80
203.22.223.145:80
203.22.223.24:80
203.32.120.48:80
45.14.174.52:80
203.30.190.169:80
172.67.171.230:80
162.247.243.25:80
172.67.43.113:80
157.245.33.31:80
191.101.251.77:80
172.67.182.157:80
172.67.3.86:80
45.8.105.142:80
203.24.102.189:80
203.30.191.119:80
185.162.230.242:80
185.162.230.66:80
203.24.108.71:80
203.24.108.223:80
45.8.104.101:80
203.28.8.153:80
203.13.32.101:80
203.28.8.191:80
203.32.121.222:80
203.23.104.187:80
203.23.103.104:80
45.8.107.2:80
185.171.230.149:80
91.226.97.107:80
45.8.107.211:80
45.8.105.75:80
203.13.32.154:80
203.34.28.248:80
45.8.107.179:80
185.162.231.243:80
185.162.231.136:80
23.227.38.186:80
91.226.97.54:80
203.13.32.160:80
45.8.107.248:80
203.30.189.134:80
203.24.103.96:80
203.24.103.77:80
31.43.179.225:80
172.67.0.25:80
172.67.43.102:80
141.193.213.79:80
141.193.213.169:80
172.67.65.209:80
58.248.11.38:1080
176.241.95.162:41890
223.96.90.216:8085
172.67.0.8:80
203.24.108.34:80
203.24.108.237:80
203.34.28.121:80
203.34.28.233:80
45.8.107.120:80
185.162.230.72:80
141.193.213.235:80
45.14.174.83:80
203.24.102.152:80
203.32.121.12:80
162.247.243.233:80
203.34.28.155:80
45.8.107.7:80
203.32.121.6:80
172.67.176.227:80
203.13.32.104:80
185.162.230.32:80
185.171.231.221:80
203.24.109.5:80
45.8.104.134:80
185.162.230.146:80
185.171.230.120:80
185.162.230.113:80
203.32.120.187:80
45.12.30.10:80
203.22.223.142:80
203.13.32.26:80
203.28.8.74:80
203.32.120.95:80
203.32.120.105:80
185.162.231.191:80
203.24.102.35:80
203.24.108.155:80
23.227.38.138:80
203.28.8.82:80
45.8.105.93:80
203.28.9.24:80
203.30.189.14:80
203.24.102.64:80
203.13.32.176:80
23.227.38.214:80
45.8.107.251:80
185.162.228.233:80
203.23.104.81:80
185.162.229.253:80
31.43.179.149:80
31.43.179.115:80
141.193.213.70:80
191.101.251.149:80
185.238.228.167:80
141.193.213.58:80
188.114.96.250:80
188.114.97.6:80
172.67.69.9:80
172.67.3.57:80
172.67.167.119:80
130.61.226.124:80
203.22.223.227:80
185.162.229.11:80
203.30.189.166:80
203.13.32.127:80
203.23.104.79:80
45.8.107.185:80
45.8.105.65:80
185.171.230.233:80
45.8.107.39:80
203.22.223.114:80
203.30.191.14:80
203.32.120.112:80
185.162.230.104:80
203.28.9.105:80
172.67.75.188:80
185.238.228.113:80
162.247.243.137:80
172.67.70.188:80
185.162.231.24:80
185.162.230.132:80
203.23.103.144:80
203.23.106.41:80
185.171.231.226:80
203.23.103.130:80
203.30.188.39:80
203.24.103.163:80
185.171.230.241:80
45.8.105.129:80
45.8.106.231:80
203.24.109.56:80
203.30.191.15:80
185.162.228.136:80
23.227.38.195:80
23.227.38.231:80
185.171.231.101:80
203.24.108.77:80
203.30.191.61:80
45.12.30.189:80
203.22.223.155:80
185.162.229.44:80
162.247.243.191:80
172.64.149.94:80
172.64.153.2:80
186.3.38.201:999
5.188.136.52:8080
1.20.166.142:8080
172.67.70.199:80
172.67.70.77:80
172.64.104.38:80
203.30.189.24:80
203.30.188.200:80
185.162.229.64:80
23.227.38.120:80
203.30.190.53:80
185.162.231.69:80
203.28.8.208:80
45.14.174.243:80
203.32.121.105:80
45.8.106.203:80
91.226.97.4:80
185.162.230.166:80
203.23.104.14:80
45.12.30.230:80
45.8.104.88:80
203.24.103.106:80
203.30.189.181:80
203.30.190.126:80
203.30.191.2:80
185.162.228.208:80
185.162.229.230:80
45.8.106.82:80
31.43.179.167:80
31.43.179.191:80
141.193.213.142:80
172.67.43.147:80
191.101.251.235:80
191.101.251.166:80
172.67.254.165:80
45.8.107.125:80
203.30.190.154:80
203.28.9.167:80
185.171.231.52:80
91.226.97.227:80
185.162.228.147:80
203.30.191.118:80
203.24.103.227:80
45.12.31.73:80
203.34.28.224:80
185.162.231.11:80
203.23.103.159:80
185.162.230.160:80
45.8.106.61:80
185.162.230.116:80
143.47.177.25:80
141.193.213.83:80
188.114.98.98:80
47.91.14.110:80
141.193.213.217:80
31.43.179.234:80
172.67.93.9:80
185.238.228.252:80
172.64.137.2:80
103.21.244.29:80
172.67.3.93:80
203.32.120.114:80
45.12.30.21:80
185.162.231.152:80
45.14.174.134:80
23.227.38.199:80
130.61.219.40:80
203.24.109.72:80
203.24.109.22:80
185.162.229.223:80
185.162.230.12:80
203.24.103.42:80
172.67.170.22:80
172.67.75.191:80
172.67.192.29:80
188.114.96.3:80
172.67.110.87:80
45.8.107.231:80
185.171.231.66:80
203.30.190.197:80
23.227.38.83:80
45.8.105.98:80
203.23.106.6:80
45.12.31.77:80
203.30.188.13:80
45.12.30.205:80
203.30.188.195:80
31.43.179.9:80
191.101.251.43:80
143.47.177.138:80
31.43.179.68:80
172.67.179.182:80
185.238.228.133:80
141.193.213.117:80
162.247.243.221:80
203.34.28.14:80
185.162.228.139:80
203.30.189.197:80
203.32.121.120:80
185.162.231.216:80
203.28.9.47:80
185.162.228.65:80
203.28.8.162:80
141.101.115.101:80
172.67.167.63:80
45.8.107.216:80
203.24.109.236:80
203.24.102.17:80
185.171.230.187:80
203.34.28.171:80
45.14.174.215:80
172.67.109.3:80
172.67.70.102:80
203.30.191.83:80
203.30.189.81:80
185.162.230.150:80
203.30.188.63:80
203.30.190.211:80
45.8.107.33:80
203.13.32.169:80
45.12.30.40:80
203.32.121.134:80
185.162.231.173:80
203.30.191.127:80
45.8.107.105:80
23.227.38.111:80
203.32.120.147:80
45.8.104.232:80
203.24.103.130:80
45.12.31.117:80
172.67.43.85:80
31.43.179.226:80
172.67.181.209:80
203.23.106.30:80
203.32.121.117:80
203.24.108.227:80
203.32.120.156:80
91.226.97.229:80
203.34.28.7:80
203.23.103.195:80
45.8.105.201:80
203.32.120.17:80
173.245.49.97:80
23.227.38.210:80
172.64.103.5:80
203.23.103.118:80
203.28.8.52:80
203.24.103.56:80
45.8.105.4:80
45.12.31.109:80
45.8.105.152:80
45.12.31.11:80
45.8.107.203:80
203.30.190.119:80
203.34.28.206:80
45.12.31.131:80
203.34.28.10:80
45.8.104.29:80
203.28.9.208:80
162.247.243.163:80
203.24.109.89:80
185.162.231.6:80
203.34.28.119:80
45.8.105.198:80
203.34.28.253:80
203.30.189.242:80
203.34.28.221:80
45.8.104.152:80
185.162.230.177:80
203.30.191.48:80
203.23.103.111:80
185.171.231.71:80
185.171.231.55:80
45.8.104.77:80
185.171.230.84:80
31.43.179.112:80
162.247.243.223:80
172.67.67.120:80
45.12.31.195:80
45.8.104.11:80
203.28.8.8:80
31.43.179.14:80
141.101.123.25:80
185.171.230.189:80
185.171.230.188:80
185.162.229.22:80
203.23.106.201:80
203.13.32.74:80
45.14.174.116:80
203.23.103.136:80
203.30.188.64:80
45.8.104.108:80
203.30.191.16:80
45.8.104.8:80
203.13.32.215:80
203.23.103.82:80
91.226.97.228:80
203.30.188.143:80
203.28.9.6:80
45.12.30.198:80
203.30.189.139:80
185.238.228.134:80
172.67.75.255:80
153.3.236.22:443
36.152.45.98:443
203.30.188.81:80
203.28.8.233:80
203.24.108.15:80
172.67.70.236:80
172.67.70.0:80
172.67.3.121:80
185.238.228.86:80
203.32.121.92:80
185.162.230.88:80
203.23.106.176:80
172.67.167.97:80
172.67.167.235:80
185.162.229.109:80
45.12.30.51:80
203.24.109.135:80
203.34.28.129:80
203.24.102.79:80
203.30.189.21:80
45.12.31.97:80
23.227.38.179:80
185.162.229.209:80
203.30.189.180:80
185.162.231.231:80
203.24.108.224:80
203.30.190.96:80
203.30.189.73:80
45.8.106.134:80
203.30.189.251:80
185.171.231.246:80
203.24.102.59:80
185.162.229.19:80
203.28.9.88:80
203.30.188.183:80
203.28.9.174:80
203.24.102.87:80
162.247.243.132:80
203.30.191.222:80
162.247.243.73:80
172.67.43.194:80
172.67.101.143:80
191.101.251.136:80
172.64.156.2:80
172.67.18.40:80
172.67.0.15:80
203.22.223.79:80
91.226.97.3:80
203.30.190.108:80
203.24.103.133:80
203.23.106.87:80
23.227.38.42:80
45.8.106.18:80
162.247.243.22:80
172.67.182.15:80
172.67.75.184:80
185.238.228.29:80
159.112.235.13:80
172.67.93.174:80
218.75.38.154:9091
130.61.145.255:80
185.162.229.7:80
203.24.109.219:80
203.28.9.73:80
203.34.28.60:80
203.30.191.45:80
203.24.109.184:80
203.23.106.9:80
45.14.174.150:80
203.24.103.183:80
45.8.107.229:80
203.24.109.180:80
203.13.32.178:80
31.43.179.63:80
185.238.228.61:80
103.21.244.22:80
172.67.70.93:80
203.23.103.234:80
203.24.103.69:80
185.162.228.221:80
45.12.30.137:80
203.30.188.46:80
203.30.188.134:80
23.227.38.192:80
45.8.107.158:80
185.162.230.202:80
203.34.28.70:80
185.171.230.68:80
203.28.8.77:80
203.24.108.176:80
203.23.106.90:80
91.226.97.205:80
45.8.105.113:80
23.227.38.193:80
203.28.9.35:80
188.114.99.153:80
141.193.213.225:80
162.247.243.60:80
191.101.251.93:80
172.64.175.2:80
47.242.20.94:3128
45.148.145.56:3128
181.118.158.133:999
31.171.152.68:8118
185.162.228.160:80
203.24.109.0:80
45.8.107.192:80
203.30.189.89:80
45.14.174.67:80
91.226.97.34:80
45.8.105.25:80
203.24.102.130:80
203.24.108.92:80
162.247.243.47:80
188.114.98.160:80
203.32.120.223:80
45.8.107.188:80
203.30.190.23:80
203.30.191.229:80
172.67.182.58:80
172.67.181.171:80
172.67.201.154:80
203.13.32.207:80
203.28.9.101:80
185.162.231.0:80
203.30.188.74:80
203.23.106.75:80
185.171.230.71:80
203.30.190.219:80
185.162.231.122:80
203.28.8.78:80
185.162.228.58:80
203.24.102.121:80
203.23.104.206:80
185.162.228.92:80
45.8.106.29:80
185.162.229.212:80
203.23.106.32:80
203.24.108.126:80
45.12.31.110:80
172.67.116.209:80
172.67.165.43:80
172.67.79.154:80
141.101.123.223:80
172.67.3.63:80
185.162.230.124:80
185.162.228.226:80
203.24.109.46:80
203.24.102.5:80
203.30.191.23:80
45.8.107.86:80
45.14.174.126:80
203.28.8.68:80
185.162.231.97:80
203.24.103.208:80
162.247.243.37:80
188.114.98.160:80
172.64.192.2:80
45.12.31.231:80
45.8.107.67:80
23.227.38.244:80
185.162.231.119:80
203.32.120.103:80
23.227.38.30:80
123.56.106.161:8888
61.182.121.66:9091
173.245.49.7:80
203.34.28.40:80
45.12.30.234:80
203.30.189.38:80
23.227.38.94:80
185.162.231.164:80
203.30.188.37:80
172.67.187.254:80
188.114.99.160:80
172.67.165.43:80
172.67.136.253:80
172.67.181.1:80
203.28.9.211:80
203.23.106.217:80
185.238.228.160:80
31.43.179.180:80
191.101.251.169:80
142.93.42.71:80
188.114.99.160:80
141.101.123.32:80
203.30.191.55:80
91.226.97.48:80
45.12.31.238:80
185.162.228.184:80
203.13.32.237:80
172.67.182.41:80
203.28.9.142:80
203.24.109.116:80
172.67.188.18:80
91.226.97.113:80
173.245.49.0:80
141.101.122.236:80
91.226.97.146:80
203.32.121.103:80
203.32.121.88:80
185.162.231.54:80
23.227.38.209:80
91.226.97.147:80
203.34.28.177:80
45.8.106.154:80
203.30.191.173:80
203.23.103.17:80
203.30.190.67:80
45.14.174.110:80
203.30.189.41:80
203.23.104.67:80
203.30.191.129:80
31.43.179.59:80
31.43.179.49:80
31.43.179.44:80
185.238.228.123:80
172.64.199.2:80
188.114.97.4:80
172.66.43.53:80
203.24.102.51:80
203.24.102.75:80
91.226.97.208:80
203.34.28.104:80
203.22.223.118:80
188.114.97.11:80
172.67.34.58:80
203.23.103.140:80
45.12.30.206:80
203.22.223.129:80
185.162.229.248:80
91.226.97.124:80
45.12.31.82:80
91.226.97.78:80
45.14.174.161:80
45.8.105.119:80
203.24.102.21:80
185.162.230.249:80
45.8.105.49:80
203.28.8.159:80
203.28.8.226:80
23.227.38.81:80
203.30.190.103:80
45.8.104.43:80
185.162.229.128:80
203.23.106.102:80
203.24.109.131:80
203.22.223.29:80
31.43.179.237:80
31.43.179.106:80
172.67.170.5:80
31.43.179.47:80
162.247.243.8:80
185.238.228.127:80
45.8.106.123:80
45.8.104.65:80
203.28.8.146:80
91.226.97.217:80
45.8.104.52:80
203.32.121.146:80
203.24.108.175:80
203.30.188.175:80
45.8.105.101:80
23.227.38.82:80
23.227.38.60:80
185.171.231.146:80
23.227.38.218:80
91.226.97.119:80
185.162.228.53:80
203.23.106.12:80
203.22.223.6:80
31.43.179.214:80
172.67.75.148:80
203.23.103.65:80
185.171.231.9:80
203.30.190.234:80
185.162.228.48:80
173.245.49.70:80
172.67.181.192:80
203.24.108.172:80
162.247.241.2:80
172.67.176.89:80
203.24.103.65:80
203.23.106.224:80
91.226.97.246:80
45.8.104.146:80
185.162.230.38:80
203.23.104.59:80
203.23.104.25:80
45.8.106.219:80
203.13.32.141:80
203.34.28.33:80
45.8.104.124:80
203.32.121.167:80
45.8.104.184:80
203.28.8.218:80
203.34.28.144:80
45.8.105.241:80
203.24.109.111:80
45.12.31.129:80
203.30.190.89:80
91.226.97.249:80
203.30.188.115:80
203.28.8.240:80
45.8.105.190:80
45.8.105.100:80
203.30.188.129:80
31.43.179.246:80
172.67.188.13:80
172.67.185.154:80
172.67.254.152:80
172.67.3.98:80
185.162.228.67:80
45.12.31.71:80
203.24.109.115:80
45.8.104.151:80
203.24.102.226:80
203.30.188.50:80
203.13.32.58:80
23.227.38.108:80
203.23.104.186:80
203.32.120.242:80
203.30.191.206:80
203.34.28.195:80
203.30.189.33:80
185.171.230.116:80
173.245.49.79:80
45.8.104.27:80
203.23.104.101:80
45.12.30.158:80
45.8.104.191:80
203.34.28.240:80
185.171.231.40:80
191.101.251.28:80
191.101.251.56:80
172.67.185.197:80
162.247.243.120:80
141.193.213.78:80
191.101.251.213:80
188.114.96.255:80
188.114.97.9:80
190.93.247.5:80
172.67.70.86:80
185.162.229.106:80
203.32.120.104:80
23.227.38.165:80
185.162.230.83:80
185.162.228.132:80
203.24.109.197:80
203.23.103.10:80
185.171.231.128:80
203.24.102.24:80
203.13.32.7:80
203.30.189.0:80
172.67.191.253:80
172.67.191.231:80
141.193.213.38:80
172.64.142.2:80
203.24.103.166:80
203.30.190.98:80
45.8.105.255:80
203.23.103.13:80
203.30.191.92:80
203.32.121.90:80
203.32.120.195:80
185.162.230.191:80
141.193.213.139:80
172.64.134.2:80
172.67.180.62:80
117.173.149.211:9091
203.24.103.222:80
173.245.49.68:80
91.226.97.95:80
172.67.182.37:80
172.67.181.124:80
172.67.254.138:80
172.67.255.217:80
172.67.176.3:80
172.67.176.179:80
172.67.177.231:80
203.13.32.106:80
185.162.229.38:80
203.24.108.190:80
45.8.107.23:80
203.23.103.181:80
203.32.120.82:80
203.24.109.246:80
185.162.230.142:80
45.12.31.8:80
203.24.102.135:80
203.24.102.255:80
203.30.191.223:80
203.22.223.56:80
45.14.174.23:80
185.162.230.228:80
203.23.104.127:80
203.22.223.228:80
185.162.231.203:80
203.30.188.135:80
185.171.230.88:80
203.30.189.23:80
203.30.190.186:80
45.14.174.235:80
31.43.179.160:80
162.247.243.58:80
172.67.179.197:80
172.67.181.30:80
172.67.181.8:80
91.226.97.162:80
203.32.121.191:80
203.22.223.254:80
203.24.103.186:80
203.24.103.8:80
203.32.121.89:80
203.23.106.129:80
45.8.104.205:80
203.24.108.44:80
203.30.190.170:80
173.245.49.116:80
203.30.188.116:80
203.30.188.91:80
203.23.104.57:80
203.30.188.229:80
203.32.120.192:80
91.226.97.190:80
45.8.107.142:80
31.43.179.117:80
172.67.43.138:80
203.24.102.52:80
172.67.185.150:80
172.67.165.42:80
172.67.182.90:80
172.67.181.40:80
172.67.182.158:80
172.67.181.194:80
185.162.229.68:80
45.8.107.53:80
45.14.174.209:80
203.23.106.220:80
45.8.104.31:80
203.24.109.75:80
45.8.106.213:80
173.245.49.78:80
173.245.49.85:80
203.23.106.36:80
45.8.105.8:80
45.12.31.18:80
185.171.231.203:80
203.23.104.242:80
203.23.104.148:80
185.162.228.40:80
31.43.179.109:80
191.101.251.63:80
172.67.187.245:80
172.67.192.4:80
191.101.251.131:80
172.67.181.198:80
23.227.38.20:80
45.14.174.82:80
23.227.38.0:80
45.14.174.48:80
91.226.97.164:80
45.8.106.94:80
203.22.223.106:80
23.227.38.170:80
203.23.104.214:80
31.43.179.118:80
203.32.120.217:80
173.245.49.96:80
173.245.49.47:80
45.8.106.249:80
203.30.191.201:80
45.12.30.212:80
203.24.109.90:80
191.101.251.60:80
183.239.62.251:9091
172.67.145.144:80
172.67.186.212:80
172.67.182.93:80
103.21.244.17:80
172.67.180.55:80
45.8.105.39:80
203.30.189.176:80
172.67.167.107:80
172.67.176.56:80
172.67.177.137:80
172.67.177.171:80
203.32.120.108:80
203.22.223.197:80
45.8.106.201:80
45.8.106.47:80
185.162.229.178:80
203.30.190.177:80
203.24.109.10:80
203.24.109.11:80
45.8.107.25:80
23.227.38.77:80
203.30.189.210:80
203.30.189.5:80
45.12.31.134:80
203.24.109.144:80
203.34.28.173:80
45.8.105.137:80
203.24.108.226:80
203.24.103.223:80
203.30.190.140:80
203.13.32.41:80
203.30.188.165:80
185.162.231.81:80
31.43.179.56:80
31.43.179.235:80
141.193.213.10:80
141.193.213.123:80
141.193.213.126:80
141.193.213.34:80
172.67.184.50:80
172.67.67.147:80
141.193.213.227:80
173.245.49.182:80
172.67.180.50:80
172.67.180.37:80
172.67.176.222:80
203.13.32.1:80
23.227.38.255:80
185.171.230.110:80
45.8.104.19:80
185.171.231.106:80
203.32.120.35:80
173.245.49.106:80
172.67.180.182:80
172.67.191.233:80
172.64.136.107:80
172.67.181.12:80
172.67.212.31:80
172.67.255.213:80
172.67.180.46:80
172.67.181.109:80
172.67.167.202:80
172.67.176.88:80
172.67.177.60:80
172.67.177.63:80
203.34.28.89:80
203.30.189.123:80
203.24.102.71:80
23.227.38.153:80
203.32.121.232:80
203.34.28.47:80
203.34.28.31:80
203.23.106.84:80
203.32.120.138:80
172.67.162.173:80
162.247.241.8:80
172.67.188.7:80
172.67.181.235:80
172.67.192.55:80
203.30.188.192:80
203.32.120.2:80
45.12.30.29:80
203.23.106.145:80
203.13.32.145:80
203.28.9.163:80
203.23.103.251:80
203.24.109.159:80
45.8.107.241:80
203.24.103.204:80
172.67.255.2:80
172.67.188.3:80
172.67.185.178:80
173.245.49.29:80
172.67.70.242:80
172.67.70.10:80
172.67.180.48:80
172.67.180.43:80
172.67.180.31:80
185.238.228.1:80
172.67.167.96:80
203.30.189.221:80
203.32.121.184:80
45.14.174.136:80
203.28.8.54:80
203.23.106.99:80
203.28.8.119:80
203.28.8.6:80
173.245.49.80:80
203.34.28.57:80
203.30.189.236:80
203.13.32.115:80
203.30.188.240:80
172.67.170.26:80
172.67.185.182:80
172.67.191.225:80
172.67.187.14:80
172.67.218.148:80
141.101.113.20:80
185.171.230.202:80
203.28.9.17:80
185.162.231.17:80
203.30.188.111:80
45.14.174.129:80
203.24.108.32:80
185.171.230.53:80
203.24.102.69:80
185.171.230.176:80
203.28.9.18:80
203.24.102.139:80
185.171.231.70:80
203.34.28.64:80
185.162.228.86:80
45.12.31.229:80
203.30.188.73:80
141.101.115.246:80
172.64.205.110:80
172.64.170.86:80
172.67.182.85:80
172.67.180.13:80
172.67.177.158:80
203.30.190.11:80
45.14.174.29:80
45.8.107.43:80
203.34.28.208:80
45.8.104.44:80
203.23.103.117:80
45.8.107.237:80
203.23.106.62:80
45.8.104.82:80
185.162.229.83:80
91.226.97.221:80
203.34.28.74:80
45.8.107.124:80
203.28.9.161:80
185.162.229.58:80
203.24.109.143:80
203.23.104.204:80
203.34.28.110:80
191.101.251.163:80
172.67.188.14:80
172.67.181.238:80
141.193.213.48:80
141.193.213.174:80
172.64.133.60:80
172.67.182.45:80
172.67.70.29:80
172.67.176.74:80
172.67.177.198:80
45.8.104.202:80
23.227.38.254:80
203.24.103.141:80
185.171.231.224:80
203.23.106.103:80
185.171.231.230:80
203.30.190.176:80
203.24.109.252:80
172.67.179.199:80
185.238.228.73:80
172.67.191.254:80
172.64.110.15:80
23.227.38.18:80
185.162.230.227:80
23.227.38.21:80
45.8.107.227:80
45.8.105.249:80
203.23.104.22:80
172.67.181.4:80
172.67.181.174:80
172.67.182.9:80
172.67.182.39:80
172.67.182.130:80
173.245.49.21:80
172.67.255.211:80
173.245.49.51:80
203.24.108.244:80
172.67.176.104:80
203.30.190.230:80
173.245.49.60:80
45.8.107.134:80
45.12.30.193:80
203.22.223.181:80
45.8.107.111:80
203.24.109.141:80
185.171.230.200:80
172.67.181.232:80
172.67.191.232:80
172.67.182.35:80
172.67.182.164:80
203.22.223.72:80
45.8.107.29:80
203.23.104.75:80
185.162.230.220:80
91.226.97.49:80
185.162.228.88:80
203.22.223.50:80
203.32.121.107:80
185.162.229.113:80
203.24.103.89:80
203.24.109.31:80
203.30.191.179:80
23.227.38.62:80
203.28.9.61:80
203.24.109.170:80
203.13.32.148:80
203.24.102.155:80
91.226.97.52:80
45.8.105.80:80
172.67.179.213:80
162.247.243.46:80
172.67.191.251:80
172.67.170.170:80
172.67.88.21:80
172.67.176.235:80
172.67.177.220:80
203.32.120.232:80
203.24.103.214:80
162.247.243.108:80
172.67.182.56:80
172.67.182.103:80
172.67.181.6:80
172.67.181.128:80
172.67.138.84:80
172.67.254.140:80
172.67.254.159:80
172.67.180.24:80
172.67.176.173:80
172.67.176.199:80
172.67.176.249:80
172.67.177.139:80
172.67.177.191:80
203.23.104.180:80
203.23.103.21:80
172.67.179.201:80
172.67.187.242:80
172.67.185.172:80
172.67.191.250:80
172.64.140.232:80
172.64.171.178:80
141.101.122.234:80
203.24.103.196:80
91.226.97.200:80
203.28.8.186:80
45.8.104.175:80
185.171.231.97:80
203.24.103.64:80
203.30.188.161:80
203.22.223.131:80
203.34.28.239:80
45.12.30.166:80
203.30.190.66:80
203.32.120.106:80
203.23.106.118:80
45.8.104.211:80
203.24.109.128:80
203.23.106.2:80
185.162.229.167:80
172.67.171.204:80
185.238.228.42:80
191.101.251.82:80
185.238.228.171:80
172.64.146.137:80
201.76.8.36:8080
172.67.255.218:80
172.67.215.83:80
203.32.120.254:80
203.24.102.70:80
203.22.223.67:80
172.67.182.83:80
172.65.195.6:80
203.24.108.48:80
172.67.167.30:80
172.67.176.103:80
172.67.177.159:80
172.67.177.223:80
203.28.9.252:80
203.30.191.97:80
203.30.188.42:80
203.22.223.168:80
185.162.228.17:80
203.13.32.245:80
203.22.223.107:80
203.30.190.254:80
185.162.229.239:80
45.8.106.138:80
203.32.121.20:80
45.8.106.102:80
203.32.121.136:80
185.238.228.250:80
185.238.228.108:80
191.101.251.16:80
162.247.243.181:80
172.67.182.144:80
172.67.182.60:80
172.67.158.10:80
172.67.180.53:80
172.67.176.190:80
203.24.108.247:80
45.8.104.71:80
203.23.104.234:80
203.30.191.0:80
203.22.223.222:80
45.14.174.139:80
45.8.105.40:80
45.12.30.186:80
185.162.229.40:80
203.23.104.60:80
185.171.230.41:80
203.24.102.102:80
203.13.32.195:80
185.171.230.10:80
172.67.138.138:80
172.67.179.192:80
172.67.185.162:80
172.67.191.241:80
191.101.251.181:80
172.67.182.105:80
172.67.181.115:80
203.32.121.86:80
91.226.97.165:80
185.162.228.171:80
203.13.32.153:80
203.30.189.95:80
91.226.97.179:80
185.162.230.137:80
203.30.191.81:80
91.226.97.10:80
203.30.190.246:80
203.24.102.61:80
45.12.30.112:80
203.22.223.214:80
31.43.179.100:80
172.67.188.25:80
172.67.181.210:80
172.67.181.175:80
172.67.176.182:80
203.22.223.182:80
203.30.190.48:80
203.28.8.26:80
185.162.228.33:80
172.67.192.47:80
23.227.37.124:80
203.24.109.225:80
45.12.31.185:80
23.227.38.198:80
203.32.121.145:80
45.12.30.103:80
203.23.103.240:80
91.226.97.216:80
203.30.189.6:80
203.24.108.73:80
91.226.97.180:80
45.8.106.209:80
203.30.188.40:80
14.241.225.167:443
172.67.3.136:80
172.67.181.113:80
172.67.177.162:80
203.24.102.48:80
172.67.179.202:80
203.22.223.25:80
172.67.177.6:80
203.30.190.97:80
185.171.230.242:80
203.22.223.44:80
203.30.191.252:80
203.32.120.42:80
203.23.103.26:80
203.24.109.213:80
203.30.188.197:80
185.171.230.2:80
185.162.231.57:80
203.24.109.77:80
185.162.231.83:80
203.34.28.212:80
185.162.228.59:80
45.12.30.168:80
185.171.230.154:80
203.30.191.10:80
45.8.106.126:80
203.30.190.152:80
203.24.108.60:80
45.8.104.40:80
172.67.171.210:80
172.67.43.119:80
31.43.179.240:80
172.67.254.158:80
203.28.8.128:80
45.14.174.72:80
203.30.188.104:80
203.24.109.212:80
172.67.192.19:80
173.245.49.61:80
172.67.181.103:80
172.67.182.8:80
172.67.182.25:80
172.67.181.51:80
172.67.4.23:80
172.67.180.44:80
172.67.177.124:80
45.8.105.66:80
45.8.105.148:80
203.24.109.245:80
45.8.106.53:80
45.8.104.78:80
203.24.109.238:80
185.162.229.35:80
203.32.120.102:80
45.8.106.236:80
203.30.190.190:80
203.30.191.178:80
172.67.192.2:80
190.93.244.126:80
203.30.189.192:80
185.162.230.216:80
45.12.30.15:80
185.162.231.159:80
203.23.106.207:80
203.30.191.19:80
45.8.104.155:80
45.8.106.12:80
203.23.106.194:80
203.24.108.216:80
45.8.104.132:80
217.160.192.11:8081
172.67.181.70:80
173.245.49.62:80
172.67.214.97:80
172.67.216.140:80
172.67.181.165:80
172.67.181.162:80
172.67.181.65:80
172.67.177.43:80
172.67.177.98:80
203.24.102.228:80
203.32.121.217:80
203.30.190.6:80
45.14.174.38:80
45.12.31.32:80
203.30.188.17:80
203.22.223.105:80
203.30.191.247:80
185.162.228.167:80
185.162.228.57:80
45.14.174.232:80
203.32.121.177:80
203.23.104.3:80
185.162.228.203:80
203.32.121.200:80
185.162.228.174:80
203.22.223.179:80
172.67.171.219:80
172.67.185.166:80
172.67.185.174:80
172.67.191.240:80
172.67.182.102:80
172.67.181.204:80
23.227.38.14:80
172.67.167.223:80
172.67.176.167:80
203.28.8.53:80
203.24.108.238:80
203.24.102.19:80
203.13.32.13:80
203.24.102.201:80
203.23.106.120:80
203.30.191.253:80
23.227.38.236:80
91.226.97.53:80
185.171.230.172:80
185.162.231.112:80
203.30.191.76:80
185.162.228.161:80
185.162.231.214:80
203.24.108.46:80
91.226.97.23:80
203.30.191.68:80
45.8.106.128:80
172.67.179.203:80
191.101.251.253:80
172.67.185.171:80
141.193.213.147:80
172.67.248.123:80
203.23.104.117:80
172.67.177.141:80
203.24.108.79:80
203.28.9.222:80
203.34.28.48:80
185.162.230.58:80
45.12.31.75:80
203.13.32.4:80
203.30.190.29:80
45.8.105.59:80
203.23.106.241:80
45.8.106.192:80
185.171.231.24:80
185.162.231.56:80
203.23.103.135:80
185.162.231.27:80
172.67.181.229:80
172.67.192.66:80
172.64.139.2:80
172.67.181.77:80
103.21.244.21:80
172.67.177.11:80
45.14.174.151:80
203.23.103.224:80
203.28.9.223:80
185.162.228.135:80
31.43.179.144:80
141.193.213.49:80
173.245.49.120:80
91.226.97.43:80
172.67.242.195:80
172.67.255.216:80
172.67.181.114:80
172.67.176.12:80
172.67.176.16:80
172.67.176.183:80
172.67.177.202:80
45.8.104.125:80
203.23.103.35:80
185.162.230.19:80
45.8.104.165:80
203.30.188.174:80
203.24.103.139:80
45.14.174.218:80
173.245.49.71:80
203.30.191.235:80
203.32.121.228:80
203.32.121.57:80
45.12.30.58:80
203.24.102.127:80
185.162.229.59:80
203.34.28.149:80
203.30.190.168:80
91.226.97.17:80
203.30.190.92:80
185.162.230.28:80
203.24.109.167:80
203.23.106.95:80
172.67.219.84:80
172.67.223.255:80
203.24.102.68:80
185.238.228.197:80
162.247.243.206:80
191.101.251.96:80
172.67.179.206:80
185.238.228.242:80
191.101.251.39:80
172.67.187.236:80
172.67.181.248:80
172.67.191.222:80
141.101.115.250:80
141.101.123.210:80
141.101.123.228:80
172.67.254.163:80
172.67.182.7:80
185.171.230.199:80
203.30.189.205:80
203.30.191.224:80
203.32.121.245:80
45.8.106.170:80
45.8.107.137:80
185.162.231.113:80
185.162.228.194:80
203.24.103.115:80
203.23.103.169:80
45.12.31.176:80
203.32.121.66:80
45.12.31.57:80
203.24.102.145:80
162.247.243.246:80
172.67.179.193:80
172.67.180.243:80
185.238.228.147:80
172.67.191.239:80
172.67.241.49:80
190.93.247.58:80
45.8.106.34:80
203.32.121.133:80
203.32.120.126:80
45.8.104.10:80
203.34.28.201:80
203.30.188.27:80
203.24.108.25:80
203.23.103.163:80
185.171.230.96:80
45.8.107.230:80
23.227.38.8:80
185.162.230.125:80
172.67.133.8:80
172.67.192.42:80
101.200.127.149:3129
139.9.64.238:443
172.67.181.63:80
173.245.49.11:80
172.67.254.144:80
172.67.254.173:80
172.67.254.174:80
172.67.180.41:80
172.67.180.40:80
172.67.176.14:80
172.67.176.120:80
203.13.32.243:80
203.23.104.141:80
203.24.108.212:80
203.22.223.216:80
185.162.231.210:80
203.30.190.128:80
172.67.182.97:80
185.162.230.17:80
203.24.108.81:80
185.162.230.81:80
185.162.230.208:80
185.171.231.233:80
203.22.223.134:80
203.23.103.87:80
45.8.107.202:80
185.162.230.159:80
45.8.104.192:80
23.227.38.84:80
203.23.103.148:80
45.8.107.246:80
45.14.174.196:80
172.67.43.82:80
162.247.243.94:80
188.114.97.14:80
172.67.182.67:80
172.67.181.134:80
172.67.167.17:80
172.67.176.181:80
172.67.177.23:80
172.67.177.155:80
173.245.49.65:80
172.67.187.246:80
172.67.233.208:80
172.67.182.174:80
172.67.181.26:80
172.67.182.55:80
172.67.182.92:80
203.24.108.161:80
172.67.254.162:80
172.67.3.148:80
172.67.3.112:80
203.30.188.204:80
203.28.9.39:80
172.67.176.151:80
45.8.105.179:80
185.162.229.142:80
203.30.189.248:80
185.171.230.141:80
203.23.106.119:80
203.24.109.200:80
203.24.108.187:80
45.8.106.65:80
203.32.121.82:80
45.8.105.140:80
203.28.9.36:80
203.30.191.34:80
203.23.106.210:80
203.24.109.44:80
203.23.106.26:80
191.101.251.87:80
185.238.228.80:80
188.114.99.160:80
45.14.174.125:80
203.13.32.249:80
91.226.97.239:80
203.23.106.202:80
185.162.230.52:80
203.30.190.95:80
185.171.231.2:80
45.8.106.93:80
185.162.230.108:80
203.34.28.68:80
185.238.228.223:80
220.247.171.242:8080
47.89.185.178:8888
47.92.113.71:80
172.67.181.135:80
172.67.180.8:80
172.67.255.13:80
173.245.49.49:80
172.67.176.5:80
45.12.30.36:80
203.24.102.218:80
203.24.108.215:80
203.22.223.189:80
203.34.28.90:80
185.162.230.211:80
203.30.189.173:80
23.227.38.187:80
203.24.108.66:80
185.162.228.66:80
185.171.231.29:80
203.30.191.57:80
45.12.31.167:80
185.162.230.106:80
172.67.179.188:80
172.67.179.130:80
172.67.185.210:80
172.67.191.226:80
191.101.251.112:80
141.193.213.163:80
172.67.181.158:80
172.67.181.217:80
203.13.32.157:80
172.67.180.9:80
203.23.103.225:80
172.67.177.207:80
185.171.231.243:80
203.23.104.232:80
203.28.9.21:80
203.24.102.171:80
203.23.104.185:80
23.227.38.78:80
185.171.230.44:80
185.171.231.217:80
185.162.228.15:80
203.34.28.114:80
203.34.28.49:80
203.24.102.46:80
203.24.102.227:80
185.162.228.64:80
185.162.229.82:80
185.162.230.197:80
185.162.230.68:80
172.67.179.172:80
203.28.9.162:80
45.12.30.45:80
172.67.185.152:80
172.67.159.119:80
185.238.228.159:80
172.64.106.205:80
172.67.177.169:80
45.12.31.202:80
203.13.32.221:80
203.28.8.155:80
45.8.107.48:80
203.22.223.97:80
45.8.105.32:80
91.226.97.160:80
203.24.103.40:80
203.23.106.233:80
162.247.243.249:80
191.101.251.81:80
141.193.213.20:80
172.67.181.136:80
172.67.134.127:80
172.67.176.219:80
45.14.174.165:80
45.12.31.174:80
185.162.229.147:80
203.23.103.6:80
185.162.231.163:80
203.23.104.30:80
185.171.230.13:80
203.30.188.146:80
203.23.106.20:80
203.30.189.42:80
203.24.102.199:80
203.24.109.36:80
203.30.189.63:80
203.23.103.50:80
185.162.229.104:80
31.43.179.139:80
191.101.251.193:80
162.247.243.85:80
172.67.185.155:80
172.67.192.8:80
172.67.182.147:80
172.67.180.29:80
172.67.181.101:80
172.67.182.61:80
172.67.190.88:80
172.67.180.3:80
185.162.230.185:80
203.30.190.202:80
173.245.49.59:80
45.8.106.188:80
203.22.223.209:80
45.8.104.166:80
185.162.228.5:80
203.24.103.95:80
172.67.187.253:80
162.247.241.3:80
172.67.134.16:80
172.67.3.119:80
203.30.188.215:80
172.67.176.40:80
45.8.106.202:80
45.8.105.248:80
45.8.104.127:80
203.30.189.19:80
45.14.174.177:80
203.32.120.244:80
203.30.189.238:80
91.226.97.134:80
203.24.102.26:80
185.171.230.46:80
45.8.104.210:80
185.171.230.77:80
23.227.38.9:80
185.162.228.31:80
23.227.38.106:80
185.162.229.69:80
185.162.230.16:80
45.8.105.95:80
203.30.191.80:80
203.30.190.164:80
185.162.231.199:80
203.30.188.51:80
203.28.8.46:80
188.114.99.160:80
172.67.182.107:80
173.245.49.39:80
91.226.97.35:80
45.8.105.237:80
45.14.174.30:80
203.32.120.211:80
141.193.213.107:80
172.67.181.60:80
172.67.181.92:80
172.67.224.246:80
172.67.133.23:80
172.67.180.59:80
172.67.180.57:80
203.32.121.174:80
203.22.223.165:80
203.24.109.87:80
45.8.104.253:80
203.28.9.246:80
203.30.190.26:80
203.23.106.100:80
203.28.9.170:80
91.226.97.65:80
185.171.231.242:80
185.171.230.108:80
185.162.230.226:80
45.12.31.76:80
45.8.104.186:80
203.24.103.84:80
45.12.30.170:80
203.32.120.117:80
45.12.31.9:80
185.162.231.171:80
185.162.228.173:80
185.162.228.232:80
185.162.230.180:80
185.162.229.163:80
203.30.191.32:80
185.162.230.121:80
203.30.189.175:80
45.12.30.78:80
203.24.109.103:80
162.247.243.153:80
191.101.251.103:80
141.193.213.162:80
185.238.228.98:80
172.67.187.234:80
172.67.181.250:80
188.114.99.160:80
172.64.205.2:80
172.67.214.222:80
109.74.197.141:18027
172.67.179.48:80
203.24.108.170:80
185.162.231.222:80
203.28.9.139:80
203.28.9.117:80
203.30.191.174:80
203.30.188.108:80
185.171.231.144:80
203.30.190.210:80
91.226.97.195:80
45.12.30.180:80
185.162.231.238:80
203.30.188.173:80
172.67.181.176:80
172.67.181.37:80
172.67.187.199:80
172.67.177.78:80
203.30.191.38:80
45.14.174.176:80
91.226.97.122:80
203.30.188.218:80
203.24.109.161:80
203.24.103.107:80
203.30.189.28:80
185.171.231.54:80
203.23.103.57:80
203.32.120.11:80
185.162.228.102:80
203.34.28.86:80
185.162.228.251:80
203.34.28.192:80
203.28.8.30:80
203.30.191.193:80
185.162.229.111:80
203.24.102.10:80
203.28.9.75:80
203.23.104.192:80
203.28.8.49:80
185.162.231.148:80
203.32.120.51:80
185.162.229.149:80
203.24.103.118:80
203.30.188.12:80
191.101.251.189:80
172.67.165.43:80
173.245.49.40:80
185.162.229.170:80
203.30.189.149:80
203.22.223.208:80
185.162.228.158:80
203.23.103.241:80
203.32.120.183:80
91.226.97.39:80
203.30.191.33:80
185.162.229.176:80
172.67.181.91:80
172.67.181.149:80
172.67.182.155:80
172.67.214.105:80
185.171.230.123:80
185.162.229.76:80
185.171.230.133:80
45.8.105.67:80
45.12.30.67:80
203.24.103.132:80
203.22.223.119:80
91.226.97.142:80
23.227.38.128:80
185.162.230.219:80
23.227.38.171:80
185.171.230.94:80
203.22.223.92:80
203.24.108.43:80
45.12.31.95:80
203.23.104.224:80
141.193.213.134:80
188.114.98.160:80
172.64.163.125:80
185.162.231.95:80
185.162.230.253:80
203.32.121.139:80
203.34.28.5:80
203.28.8.168:80
185.162.231.84:80
203.28.9.180:80
45.8.107.199:80
185.238.228.89:80
172.67.182.109:80
45.8.107.12:80
172.67.180.32:80
23.227.38.10:80
203.28.9.216:80
45.8.105.157:80
203.23.103.70:80
185.171.230.230:80
203.30.190.33:80
203.30.190.20:80
23.227.38.54:80
185.171.230.112:80
185.162.230.158:80
185.162.230.24:80
172.67.24.177:80
188.114.98.160:80
188.114.99.160:80
23.227.38.163:80
188.114.98.160:80
172.67.180.61:80
203.30.191.112:80
91.226.97.11:80
188.114.99.160:80
172.67.185.163:80
185.171.230.134:80
45.12.31.187:80
185.162.231.39:80
203.24.109.192:80
185.162.230.161:80
203.28.8.73:80
203.30.188.36:80
203.24.109.220:80
203.23.106.193:80
31.43.179.67:80
31.43.179.211:80
188.114.98.160:80
14.248.122.5:19132
45.14.174.179:80
203.30.188.153:80
203.32.121.206:80
203.24.109.153:80
185.162.229.213:80
45.12.31.246:80
203.24.103.168:80
172.67.221.193:80
172.67.181.130:80
203.34.28.126:80
45.14.174.164:80
203.13.32.84:80
185.162.229.140:80
203.24.109.185:80
203.32.120.251:80
203.28.8.175:80
203.22.223.86:80
45.8.107.132:80
91.226.97.144:80
203.32.120.60:80
203.30.188.3:80
203.24.109.224:80
203.23.103.197:80
191.101.251.217:80
141.101.123.17:80
45.8.106.1:80
203.13.32.16:80
185.171.231.187:80
203.24.108.206:80
185.171.231.5:80
185.171.231.109:80
185.171.231.126:80
203.30.188.232:80
203.13.32.77:80
140.83.37.54:80
191.101.251.70:80
203.32.121.97:80
141.101.123.13:80
203.22.223.94:80
45.12.31.211:80
203.13.32.211:80
203.30.190.52:80
185.171.230.47:80
185.171.231.93:80
203.30.191.165:80
203.24.109.120:80
203.28.8.255:80
45.8.105.77:80
203.24.103.10:80
203.23.103.97:80
172.67.172.176:80
188.114.98.160:80
172.67.165.43:80
172.67.179.27:80
45.8.107.161:80
203.13.32.72:80
45.8.107.204:80
203.32.120.193:80
203.30.189.76:80
172.67.180.45:80
203.24.108.35:80
203.30.189.211:80
203.32.120.181:80
203.30.189.127:80
203.30.190.78:80
45.8.106.55:80
188.166.163.172:80
190.93.244.37:80
185.162.230.3:80
45.12.31.242:80
23.227.38.53:80
203.32.121.203:80
45.8.105.64:80
185.162.231.50:80
203.28.9.5:80
45.14.174.73:80
203.24.103.93:80
185.162.230.199:80
203.30.190.226:80
203.30.190.114:80
203.13.32.240:80
203.30.189.60:80
203.30.191.3:80
45.8.106.147:80
203.28.9.249:80
203.30.188.57:80
203.34.28.2:80
185.162.229.151:80
203.30.190.9:80
45.8.107.160:80
203.13.32.93:80
162.247.243.168:80
185.238.228.190:80
191.101.251.49:80
188.114.98.160:80
203.30.188.62:80
203.28.9.16:80
185.162.228.100:80
203.24.108.177:80
203.30.188.83:80
203.28.8.206:80
203.30.191.213:80
172.67.225.30:80
45.8.104.121:80
203.13.32.121:80
203.24.102.232:80
91.226.97.197:80
185.171.231.8:80
45.12.31.141:80
203.23.106.168:80
23.227.38.251:80
203.34.28.244:80
45.8.107.101:80
45.12.30.232:80
45.14.174.80:80
203.24.109.99:80
203.28.8.179:80
45.8.104.148:80
203.23.104.247:80
203.24.102.204:80
45.12.30.156:80
45.8.105.71:80
203.28.9.236:80
203.24.108.95:80
185.171.231.22:80
203.32.120.59:80
203.22.223.104:80
203.23.103.198:80
203.23.106.206:80
203.22.223.51:80
203.24.109.67:80
203.32.121.213:80
159.223.27.218:80
185.238.228.15:80
162.247.243.167:80
185.171.230.128:80
45.8.107.121:80
203.24.103.81:80
203.28.9.34:80
31.43.179.81:80
203.30.191.233:80
172.67.167.252:80
203.28.9.153:80
45.12.31.230:80
185.162.228.113:80
203.30.188.140:80
23.227.38.26:80
203.23.106.51:80
203.22.223.59:80
185.171.230.70:80
203.22.223.93:80
23.227.38.7:80
203.32.121.108:80
203.13.32.59:80
203.28.9.143:80
31.43.179.182:80
185.238.228.27:80
191.101.251.173:80
172.67.165.43:80
172.67.180.7:80
203.30.189.231:80
203.30.188.211:80
203.28.8.209:80
203.30.191.84:80
185.171.230.226:80
45.8.104.20:80
203.34.28.222:80
203.13.32.204:80
203.23.106.34:80
203.28.8.15:80
203.23.103.59:80
45.12.30.190:80
188.114.98.160:80
203.24.103.238:80
45.12.30.215:80
45.8.107.63:80
45.14.174.194:80
203.30.188.187:80
203.30.190.107:80
203.30.190.61:80
162.247.243.172:80
172.67.3.82:80
203.28.8.170:80
203.24.102.252:80
203.24.103.213:80
45.8.107.238:80
203.32.121.226:80
203.24.102.118:80
203.22.223.146:80
91.226.97.219:80
203.28.9.240:80
45.8.107.110:80
203.24.102.177:80
203.23.106.161:80
203.32.121.189:80
45.8.104.244:80
203.24.102.109:80
203.22.223.17:80
203.13.32.116:80
203.13.32.20:80
185.162.231.145:80
203.30.189.48:80
203.22.223.58:80
185.162.231.230:80
203.23.103.39:80
45.8.104.143:80
203.30.190.179:80
172.67.192.33:80
188.114.99.160:80
172.67.12.34:80
172.67.142.192:80
45.90.164.114:80
222.138.64.93:9091
219.146.125.162:9091
154.85.58.149:80
106.14.255.124:80
203.23.103.18:80
185.162.231.223:80
203.23.106.192:80
185.162.230.62:80
203.32.121.235:80
203.24.108.1:80
45.12.30.143:80
203.32.120.101:80
45.8.104.105:80
185.171.231.18:80
203.28.8.212:80
203.28.9.250:80
203.13.32.27:80
185.162.231.217:80
91.226.97.125:80
45.8.104.70:80
203.24.108.138:80
191.101.251.106:80
185.238.228.28:80
191.101.251.208:80
188.114.98.160:80
172.67.196.142:80
172.67.181.131:80
91.226.97.193:80
203.22.223.167:80
203.30.188.93:80
203.23.103.236:80
203.13.32.250:80
203.22.223.207:80
203.30.188.1:80
172.67.141.210:80
45.14.174.241:80
203.24.102.39:80
203.22.223.234:80
203.28.9.247:80
185.162.231.240:80
91.226.97.82:80
91.226.97.26:80
172.67.170.109:80
203.24.109.59:80
185.162.229.42:80
45.8.105.215:80
203.24.103.140:80
45.8.106.191:80
185.162.231.150:80
185.162.228.70:80
185.162.231.99:80
45.12.30.245:80
203.28.8.203:80
91.226.97.102:80
185.162.228.11:80
45.8.104.249:80
172.67.43.105:80
191.101.251.190:80
172.67.163.110:80
23.227.38.88:80
91.226.97.112:80
23.227.38.250:80
203.28.8.183:80
203.22.223.235:80
45.12.31.213:80
203.23.103.76:80
203.30.191.123:80
45.12.30.102:80
203.24.109.80:80
45.8.104.242:80
203.30.188.75:80
216.24.57.253:80
172.67.180.52:80
203.24.108.231:80
45.8.107.165:80
203.23.104.104:80
172.67.141.148:80
172.67.253.7:80
185.238.228.233:80
203.24.108.106:80
45.8.105.134:80
185.162.229.93:80
203.24.108.124:80
45.8.106.225:80
45.12.30.129:80
173.245.49.91:80
185.162.229.46:80
45.8.107.4:80
45.8.104.47:80
45.8.105.184:80
141.193.213.232:80
141.193.213.77:80
188.114.98.160:80
173.245.49.27:80
45.8.106.66:80
203.24.108.97:80
185.162.228.46:80
45.8.104.74:80
203.24.103.79:80
203.28.9.171:80
172.67.254.151:80
91.226.97.248:80
203.24.109.16:80
172.67.7.187:80
172.67.188.23:80
172.67.163.224:80
172.67.190.170:80
185.170.166.107:80
45.8.106.31:80
203.24.108.183:80
45.8.105.169:80
203.24.109.117:80
203.23.103.139:80
203.23.103.131:80
203.24.102.91:80
188.114.99.160:80
172.67.37.43:80
103.153.247.66:3125
46.53.191.12:3128
222.139.156.118:9091
120.237.144.77:9091
221.181.238.59:9091
172.67.181.154:80
172.67.181.44:80
172.67.167.31:80
172.67.177.199:80
203.28.9.7:80
203.28.9.56:80
185.162.230.235:80
203.24.108.54:80
172.67.188.16:80
172.67.182.46:80
172.67.133.78:80
23.227.39.179:80
172.67.239.72:80
172.67.190.16:80
172.67.169.151:80
172.67.191.44:80
188.114.98.160:80
45.14.174.95:80
203.30.189.2:80
203.30.190.4:80
45.12.30.183:80
203.30.190.161:80
203.32.121.83:80
45.12.30.39:80
172.67.179.181:80
172.67.180.220:80
188.114.98.160:80
172.64.151.10:80
203.30.189.219:80
203.28.9.29:80
23.227.38.5:80
203.24.103.195:80
172.67.22.205:80
172.67.180.5:80
185.162.231.87:80
185.162.228.180:80
45.14.174.118:80
203.22.223.47:80
45.8.104.128:80
203.24.103.164:80
45.8.106.157:80
203.24.109.105:80
141.193.213.202:80
162.247.243.124:80
141.193.213.133:80
188.114.98.160:80
172.67.65.31:80
172.64.150.12:80
172.67.14.54:80
173.245.49.32:80
172.67.180.42:80
203.23.104.121:80
203.23.103.248:80
203.22.223.193:80
216.24.57.3:80
172.67.180.208:80
141.193.213.50:80
172.67.185.165:80
172.67.185.176:80
188.114.98.160:80
172.67.160.206:80
190.93.247.9:80
203.23.104.202:80
45.12.30.177:80
45.14.174.31:80
203.24.108.198:80
45.12.31.161:80
185.162.229.110:80
45.14.174.70:80
185.162.231.194:80
203.23.103.71:80
191.101.251.89:80
191.101.251.201:80
172.67.180.196:80
172.67.188.4:80
172.67.191.224:80
188.114.98.160:80
188.114.99.160:80
141.101.115.244:80
188.114.99.160:80
172.67.176.149:80
203.24.108.86:80
185.162.229.201:80
45.8.106.10:80
185.162.229.51:80
172.67.128.62:80
172.67.196.58:80
172.67.149.4:80
203.23.104.50:80
45.8.104.183:80
203.24.102.138:80
203.32.120.71:80
91.226.97.116:80
185.162.231.195:80
45.12.31.249:80
45.8.106.119:80
185.171.231.11:80
45.12.31.25:80
172.67.160.206:80
172.67.185.157:80
172.67.60.105:80
172.67.165.43:80
172.67.21.238:80
190.93.245.242:80
203.32.120.80:80
45.8.104.230:80
45.12.30.120:80
162.247.243.231:80
172.67.181.129:80
172.67.176.160:80
203.24.109.145:80
203.30.190.45:80
45.8.106.87:80
203.28.8.246:80
185.171.231.62:80
23.227.38.175:80
203.23.106.183:80
185.162.229.148:80
203.13.32.78:80
203.28.8.207:80
188.114.99.160:80
172.67.170.0:80
191.101.251.69:80
191.101.251.139:80
172.67.181.249:80
172.67.191.234:80
188.114.99.160:80
188.114.99.160:80
188.114.98.160:80
172.64.161.2:80
172.67.165.43:80
188.114.98.160:80
172.64.153.236:80
172.67.159.104:80
188.114.99.160:80
203.24.108.101:80
185.171.231.114:80
45.8.106.204:80
203.24.108.118:80
203.24.109.186:80
203.30.191.199:80
45.8.105.141:80
203.23.106.93:80
203.24.102.7:80
191.101.251.207:80
172.64.135.2:80
203.24.109.118:80
188.114.99.160:80
172.67.182.40:80
185.171.230.7:80
172.67.176.9:80
203.30.189.32:80
203.24.102.63:80
45.8.106.89:80
45.8.104.248:80
203.30.190.135:80
185.171.231.219:80
162.247.241.4:80
172.67.179.194:80
203.30.190.69:80
172.67.165.43:80
141.101.123.222:80
185.162.229.77:80
203.23.103.239:80
203.23.103.237:80
45.12.31.88:80
45.8.107.148:80
91.226.97.61:80
203.24.103.73:80
45.8.105.88:80
203.24.102.66:80
185.171.230.208:80
203.24.102.221:80
203.13.32.111:80
203.34.28.225:80
45.12.31.132:80
203.32.121.192:80
203.32.121.63:80
191.101.251.244:80
141.193.213.203:80
188.114.98.160:80
188.114.99.160:80
172.67.72.47:80
91.226.97.224:80
203.24.103.9:80
185.162.229.231:80
45.12.30.76:80
203.30.190.31:80
172.67.176.149:80
162.247.243.99:80
172.64.136.2:80
172.67.181.17:80
141.101.123.18:80
172.67.214.239:80
172.67.176.20:80
203.30.188.249:80
172.67.177.41:80
45.12.31.154:80
203.34.28.27:80
203.23.106.185:80
185.162.228.182:80
203.24.109.60:80
45.8.106.161:80
45.8.107.52:80
185.171.230.87:80
203.23.103.235:80
203.28.8.106:80
23.227.38.233:80
185.171.230.115:80
203.13.32.30:80
203.28.9.26:80
185.162.229.150:80
203.30.189.204:80
203.23.106.157:80
45.8.106.233:80
203.30.189.151:80
172.67.43.245:80
185.238.228.102:80
162.247.243.68:80
162.247.243.208:80
191.101.251.20:80
141.101.113.103:80
172.67.181.178:80
185.171.230.63:80
45.14.174.33:80
203.24.103.90:80
45.12.31.164:80
203.30.190.105:80
172.67.181.7:80
172.67.182.170:80
203.23.103.125:80
172.67.167.139:80
203.28.8.200:80
203.30.191.168:80
185.162.228.246:80
203.24.102.223:80
45.8.106.141:80
203.23.103.56:80
185.162.230.224:80
45.8.107.100:80
45.8.105.41:80
203.32.121.163:80
203.32.121.53:80
203.23.103.27:80
203.28.8.142:80
45.12.30.80:80
45.8.107.170:80
203.24.109.57:80
203.32.120.234:80
45.12.31.225:80
203.32.120.231:80
203.23.106.234:80
203.30.188.101:80
45.8.106.38:80
203.28.8.55:80
203.30.188.10:80
203.23.106.175:80
172.67.43.203:80
172.67.191.248:80
203.34.28.25:80
188.114.98.160:80
172.64.157.2:80
45.189.254.10:999
172.67.167.154:80
185.162.228.193:80
185.162.230.198:80
172.67.172.152:80
185.162.228.198:80
203.28.9.126:80
203.28.8.101:80
203.24.108.96:80
91.226.97.206:80
45.12.30.83:80
45.8.104.154:80
203.32.120.73:80
203.24.109.223:80
203.28.8.196:80
45.12.31.244:80
203.28.9.197:80
45.14.174.34:80
172.67.43.214:80
185.238.228.21:80
162.247.243.95:80
203.24.109.174:80
185.171.231.30:80
203.32.120.191:80
185.171.231.140:80
185.171.231.12:80
185.162.230.118:80
203.24.108.21:80
91.226.97.233:80
185.162.230.6:80
203.32.120.171:80
203.30.189.171:80
45.8.106.118:80
45.12.30.126:80
45.12.30.0:80
203.32.121.187:80
203.24.109.21:80
172.67.160.206:80
188.114.99.160:80
203.24.103.121:80
203.24.102.224:80
45.14.174.250:80
45.8.106.83:80
45.14.174.234:80
45.14.174.188:80
172.67.172.147:80
172.67.43.209:80
172.67.192.57:80
191.101.251.27:80
172.67.194.134:80
172.67.167.254:80
185.171.231.127:80
203.28.9.173:80
203.30.188.133:80
203.22.223.68:80
203.24.109.147:80
185.162.229.116:80
203.30.190.235:80
185.171.231.41:80
203.30.190.141:80
203.24.108.75:80
203.28.9.128:80
185.162.231.187:80
203.30.188.202:80
91.226.97.235:80
203.24.103.31:80
203.24.108.185:80
203.23.103.152:80
172.67.171.213:80
172.67.171.227:80
172.67.0.37:80
162.247.243.90:80
172.67.215.83:80
130.61.105.94:80
203.22.223.144:80
185.171.231.100:80
45.8.105.22:80
185.162.231.205:80
185.162.229.224:80
203.24.102.186:80
203.30.191.171:80
45.12.30.123:80
185.171.230.164:80
203.32.120.5:80
203.24.103.97:80
185.171.231.206:80
203.13.32.67:80
162.247.243.119:80
203.30.191.236:80
185.238.228.35:80
203.30.190.153:80
172.64.193.76:80
111.59.194.52:9091
187.216.82.55:3128
45.12.30.182:80
203.13.32.2:80
203.34.28.42:80
203.24.109.169:80
203.28.8.248:80
203.23.106.108:80
185.162.231.96:80
203.22.223.180:80
203.32.121.65:80
203.23.104.116:80
45.12.30.179:80
203.24.103.38:80
203.28.9.212:80
203.28.9.131:80
45.12.31.247:80
203.28.9.134:80
45.8.106.162:80
45.8.105.123:80
45.14.174.154:80
203.23.104.2:80
23.227.38.212:80
203.13.32.228:80
203.30.190.157:80
203.23.103.249:80
203.13.32.179:80
185.162.228.211:80
203.34.28.199:80
203.32.121.22:80
203.24.109.168:80
45.8.104.69:80
162.247.243.189:80
31.43.179.29:80
31.43.179.27:80
31.43.179.238:80
66.235.200.0:80
172.67.179.214:80
31.43.179.162:80
31.43.179.113:80
31.43.179.253:80
185.238.228.219:80
31.43.179.169:80
31.43.179.65:80
172.67.161.43:80
191.101.251.58:80
172.67.161.124:80
45.8.105.21:80
172.67.3.143:80
172.67.167.90:80
172.67.167.171:80
172.67.167.218:80
172.67.177.5:80
203.23.106.42:80
203.34.28.8:80
45.14.174.249:80
45.8.104.163:80
203.23.103.182:80
203.24.109.15:80
203.30.189.253:80
23.227.38.85:80
45.8.105.225:80
203.32.120.107:80
203.28.8.140:80
185.171.230.45:80
203.30.191.189:80
45.12.31.47:80
185.162.231.104:80
45.12.31.16:80
203.30.190.93:80
203.23.106.235:80
203.28.8.172:80
203.24.102.137:80
185.162.228.99:80
185.162.231.108:80
203.13.32.170:80
203.30.188.131:80
203.30.189.135:80
203.30.189.90:80
203.24.102.233:80
203.32.121.58:80
203.23.106.239:80
31.43.179.120:80
31.43.179.64:80
172.67.171.203:80
191.101.251.138:80
141.193.213.69:80
31.43.179.53:80
172.67.43.159:80
159.223.26.254:80
31.43.179.82:80
141.193.213.88:80
31.43.179.37:80
191.101.251.219:80
203.32.120.177:80
45.8.104.180:80
203.24.102.11:80
185.162.228.205:80
31.43.179.3:80
172.67.0.35:80
162.247.243.215:80
31.43.179.20:80
31.43.179.108:80
173.245.49.16:80
203.32.120.131:80
45.12.31.184:80
203.24.108.235:80
203.34.28.219:80
45.8.105.62:80
203.23.103.143:80
203.32.121.214:80
45.8.106.37:80
203.28.9.115:80
203.32.121.11:80
45.14.174.54:80
203.13.32.55:80
203.32.120.81:80
203.28.9.113:80
45.12.31.237:80
91.226.97.129:80
203.23.104.35:80
45.12.30.211:80
185.162.229.173:80
45.8.107.135:80
203.34.28.123:80
45.8.107.72:80
203.34.28.61:80
31.43.179.224:80
31.43.179.107:80
31.43.179.28:80
31.43.179.151:80
31.43.179.25:80
31.43.179.153:80
172.67.170.27:80
31.43.179.194:80
31.43.179.233:80
31.43.179.136:80
141.193.213.242:80
185.238.228.204:80
31.43.179.31:80
31.43.179.2:80
31.43.179.155:80
188.114.99.160:80
172.64.147.2:80
172.67.165.41:80
23.227.39.19:80
203.23.104.28:80
203.13.32.19:80
185.162.228.120:80
203.23.104.108:80
31.43.179.183:80
31.43.179.232:80
31.43.179.140:80
31.43.179.69:80
172.67.75.189:80
31.43.179.250:80
162.247.243.213:80
172.67.192.11:80
203.23.106.81:80
203.30.189.18:80
45.8.107.6:80
203.13.32.133:80
203.32.120.123:80
203.28.8.198:80
185.162.229.32:80
45.12.31.70:80
45.12.31.208:80
203.24.103.215:80
45.8.107.144:80
185.162.231.162:80
203.34.28.88:80
31.43.179.159:80
31.43.179.70:80
31.43.179.150:80
31.43.179.34:80
31.43.179.209:80
31.43.179.227:80
172.67.171.216:80
31.43.179.12:80
31.43.179.148:80
31.43.179.42:80
31.43.179.171:80
31.43.179.208:80
31.43.179.170:80
31.43.179.166:80
31.43.179.247:80
185.238.228.229:80
31.43.179.71:80
172.67.75.174:80
31.43.179.83:80
185.162.228.223:80
203.24.108.31:80
185.162.231.92:80
173.245.49.95:80
45.12.30.1:80
203.13.32.196:80
172.67.254.47:80
172.67.180.21:80
45.12.30.185:80
172.67.167.253:80
172.67.177.200:80
203.32.121.248:80
23.227.38.169:80
203.24.102.8:80
45.12.30.99:80
203.32.120.180:80
203.24.109.86:80
45.14.174.247:80
45.8.106.90:80
203.24.103.123:80
203.24.102.192:80
203.24.103.174:80
45.12.31.175:80
203.22.223.130:80
203.30.189.104:80
185.162.231.9:80
203.30.189.93:80
45.12.31.142:80
31.43.179.0:80
31.43.179.1:80
31.43.179.61:80
31.43.179.105:80
31.43.179.123:80
31.43.179.21:80
31.43.179.157:80
31.43.179.54:80
31.43.179.73:80
162.247.243.155:80
172.67.172.159:80
172.67.0.29:80
172.67.192.10:80
162.247.243.72:80
188.114.99.160:80
172.67.126.135:80
172.67.172.179:80
173.245.49.20:80
185.162.229.60:80
203.30.188.33:80
45.14.174.76:80
31.43.179.192:80
31.43.179.230:80
31.43.179.181:80
31.43.179.7:80
141.193.213.59:80
172.67.153.17:80
203.13.32.128:80
45.12.30.114:80
185.162.228.163:80
91.226.97.85:80
185.162.229.232:80
203.13.32.71:80
203.30.191.72:80
31.43.179.121:80
31.43.179.38:80
31.43.179.201:80
185.238.228.71:80
31.43.179.30:80
185.238.228.26:80
172.67.192.18:80
154.113.32.26:8080
45.8.104.75:80
45.8.106.193:80
45.12.31.179:80
203.24.103.110:80
203.24.102.2:80
31.43.179.99:80
203.30.190.247:80
31.43.179.62:80
203.24.103.234:80
185.162.229.88:80
203.24.103.5:80
203.28.8.224:80
185.171.230.56:80
203.28.9.59:80
203.28.8.220:80
45.8.107.71:80
203.30.188.136:80
203.23.104.9:80
203.32.121.230:80
185.171.231.163:80
203.23.104.40:80
45.14.174.117:80
203.32.120.194:80
185.162.229.222:80
203.23.103.216:80
31.43.179.43:80
31.43.179.79:80
162.247.243.34:80
172.67.187.248:80
31.43.179.142:80
31.43.179.50:80
172.67.182.10:80
172.67.181.52:80
172.67.181.111:80
172.67.242.194:80
172.67.180.17:80
172.67.181.105:80
172.67.167.159:80
172.67.176.220:80
91.226.97.105:80
203.28.8.235:80
185.162.228.197:80
45.12.31.45:80
31.43.179.104:80
31.43.179.119:80
31.43.179.165:80
31.43.179.93:80
172.67.188.17:80
172.67.245.37:80
172.67.182.143:80
172.67.181.186:80
172.64.141.12:80
172.67.26.7:80
172.67.70.100:80
172.67.3.139:80
203.22.223.196:80
45.12.31.27:80
203.13.32.9:80
45.8.105.87:80
203.24.103.148:80
203.24.103.45:80
203.24.102.111:80
45.14.174.101:80
203.22.223.15:80
45.12.30.108:80
203.30.191.159:80
203.23.104.41:80
185.162.230.31:80
185.162.228.9:80
203.13.32.227:80
45.14.174.47:80
203.32.120.142:80
203.32.120.206:80
31.43.179.4:80
31.43.179.89:80
31.43.179.85:80
31.43.179.242:80
31.43.179.10:80
31.43.179.75:80
31.43.179.244:80
172.67.170.14:80
172.67.172.151:80
172.67.180.232:80
141.193.213.184:80
31.43.179.245:80
172.67.182.18:80
141.193.213.213:80
172.67.144.93:80
172.67.181.100:80
172.67.181.16:80
172.67.254.241:80
172.67.167.15:80
172.67.167.184:80
172.67.176.122:80
172.67.177.8:80
203.23.104.134:80
203.23.104.140:80
185.171.230.228:80
45.8.106.11:80
203.13.32.51:80
203.30.191.242:80
185.238.228.115:80
172.67.170.29:80
172.67.180.241:80
191.101.251.221:80
31.43.179.116:80
172.67.185.195:80
172.67.181.251:80
172.67.151.87:80
203.28.9.166:80
162.247.243.2:80
172.67.176.165:80
203.30.191.79:80
203.30.188.103:80
203.13.32.229:80
203.32.120.162:80
45.8.104.145:80
203.23.106.72:80
185.162.229.234:80
185.162.228.29:80
203.23.104.94:80
185.162.230.144:80
45.14.174.221:80
91.226.97.117:80
162.247.243.235:80
172.67.170.33:80
162.247.243.100:80
141.193.213.103:80
172.67.75.153:80
141.193.213.82:80
141.193.213.171:80
172.64.194.2:80
187.192.161.194:3128
159.203.70.121:3128
117.160.140.198:9091
172.67.182.118:80
172.67.254.157:80
141.101.113.23:80
172.67.167.166:80
91.226.97.148:80
185.162.230.93:80
45.8.104.229:80
203.13.32.131:80
172.67.0.41:80
162.247.243.29:80
172.67.57.51:80
172.67.70.162:80
172.67.3.134:80
185.162.231.143:80
185.171.231.149:80
185.162.228.218:80
203.23.104.198:80
45.8.104.251:80
45.8.104.45:80
45.8.104.53:80
203.30.191.204:80
203.23.103.108:80
203.28.8.107:80
45.8.104.234:80
45.12.30.210:80
185.162.229.174:80
185.171.231.229:80
185.238.228.5:80
172.67.43.78:80
191.101.251.187:80
172.67.182.117:80
172.67.181.34:80
172.67.182.104:80
172.67.181.196:80
172.67.254.135:80
172.64.137.4:80
172.67.180.22:80
172.67.180.155:80
172.67.167.33:80
172.67.167.214:80
172.67.177.157:80
91.226.97.254:80
91.226.97.110:80
185.162.231.155:80
203.30.189.61:80
45.8.107.190:80
45.8.107.119:80
203.30.189.163:80
203.24.108.146:80
45.12.31.99:80
203.34.28.158:80
203.24.102.240:80
203.28.8.87:80
203.24.102.193:80
203.32.120.169:80
203.23.103.128:80
203.32.120.75:80
203.23.106.178:80
203.24.102.45:80
203.32.121.49:80
203.13.32.139:80
23.227.38.222:80
203.28.8.254:80
203.34.28.100:80
45.8.106.198:80
203.24.109.222:80
203.23.104.195:80
191.101.251.182:80
141.193.213.179:80
191.101.251.162:80
191.101.251.15:80
188.114.97.0:80
188.114.96.251:80
172.64.201.125:80
172.67.158.52:80
172.67.254.156:80
172.67.3.56:80
185.162.230.210:80
185.162.228.13:80
45.8.104.96:80
203.24.103.127:80
203.34.28.187:80
203.30.189.80:80
203.28.8.67:80
23.227.38.239:80
203.30.188.206:80
203.24.108.64:80
203.24.108.250:80
45.8.106.84:80
172.67.164.40:80
203.32.120.23:80
172.64.85.100:80
203.28.9.152:80
185.171.231.65:80
45.8.105.205:80
173.245.49.98:80
172.67.3.123:80
45.8.106.5:80
203.30.191.64:80
45.12.30.93:80
91.226.97.55:80
203.28.9.49:80
45.12.31.190:80
185.171.231.245:80
203.30.188.4:80
203.28.8.17:80
203.28.9.79:80
23.227.38.109:80
45.12.31.103:80
203.30.189.212:80
203.23.103.186:80
185.162.231.10:80
203.30.191.74:80
203.30.191.109:80
203.32.120.144:80
45.8.105.204:80
203.24.108.94:80
31.43.179.178:80
185.238.228.244:80
191.101.251.212:80
185.238.228.33:80
185.238.228.92:80
172.64.174.106:80
173.245.49.13:80
173.245.49.55:80
172.67.176.250:80
203.24.109.45:80
45.8.106.235:80
185.162.229.39:80
203.23.106.180:80
45.8.107.68:80
203.23.104.100:80
185.162.230.128:80
185.162.231.125:80
185.171.231.76:80
191.101.251.205:80
185.162.230.55:80
172.67.3.101:80
203.32.120.47:80
203.24.103.100:80
203.24.103.242:80
203.24.102.195:80
203.24.103.13:80
203.28.9.194:80
203.23.104.239:80
203.24.108.37:80
203.23.106.177:80
45.8.105.135:80
203.22.223.83:80
203.13.32.231:80
185.162.231.146:80
91.226.97.243:80
203.28.8.210:80
23.227.38.194:80
45.8.107.169:80
203.32.120.129:80
185.171.231.205:80
203.24.109.51:80
45.8.105.162:80
185.171.231.67:80
203.23.103.158:80
45.14.174.190:80
45.8.105.76:80
203.32.121.165:80
203.23.106.151:80
45.12.30.150:80
45.8.107.59:80
203.23.106.216:80
203.32.120.16:80
185.162.229.169:80
185.171.230.221:80
203.24.102.40:80
203.23.104.11:80
172.67.187.250:80
191.101.251.107:80
162.247.243.125:80
45.8.106.42:80
185.162.230.71:80
203.24.109.38:80
203.24.109.104:80
185.171.230.152:80
45.14.174.25:80
173.245.49.54:80
203.23.103.188:80
203.30.191.85:80
45.8.105.226:80
23.227.38.190:80
203.32.121.166:80
203.34.28.179:80
203.30.191.13:80
203.23.103.79:80
203.24.103.205:80
45.8.106.76:80
203.30.188.191:80
203.24.109.9:80
91.226.97.5:80
203.34.28.182:80
203.30.191.146:80
203.30.188.199:80
203.23.103.49:80
45.14.174.97:80
185.238.228.57:80
162.247.243.59:80
45.8.106.179:80
172.67.181.138:80
172.67.181.5:80
141.101.123.2:80
185.171.230.177:80
45.14.174.2:80
185.162.229.89:80
45.8.104.193:80
45.12.31.221:80
185.162.229.254:80
91.226.97.150:80
203.23.103.52:80
203.28.8.195:80
203.24.102.74:80
45.14.174.226:80
203.24.108.173:80
203.34.28.152:80
45.8.106.57:80
203.13.32.95:80
203.22.223.61:80
203.24.102.27:80
23.227.38.146:80
203.30.189.94:80
45.12.31.163:80
203.30.191.120:80
203.23.104.12:80
185.171.231.123:80
203.34.28.72:80
203.24.109.157:80
45.8.107.183:80
203.24.102.92:80
45.8.106.243:80
203.24.103.102:80
23.227.38.27:80
45.8.104.194:80
203.23.106.134:80
203.34.28.165:80
188.114.96.160:80
172.67.79.65:80
190.93.244.247:80
45.14.174.79:80
172.67.176.169:80
203.13.32.181:80
203.32.120.85:80
45.14.174.237:80
203.32.121.68:80
203.24.102.129:80
203.24.103.72:80
203.23.103.244:80
203.23.104.210:80
203.22.223.100:80
185.162.229.177:80
203.32.120.3:80
203.32.121.35:80
45.8.104.162:80
45.14.174.146:80
185.162.229.18:80
45.8.104.9:80
185.171.231.57:80
45.12.31.243:80
185.171.231.189:80
45.8.105.189:80
203.28.8.18:80
203.32.120.99:80
203.24.109.110:80
203.23.104.16:80
203.24.109.4:80
203.23.103.114:80
172.67.43.152:80
31.43.179.202:80
172.64.158.169:80
203.34.28.94:80
203.22.223.161:80
185.171.230.131:80
172.67.187.100:80
203.24.109.254:80
185.162.229.102:80
185.162.230.4:80
203.32.120.7:80
203.23.104.106:80
203.24.108.207:80
91.226.97.19:80
203.30.190.120:80
203.32.120.20:80
203.28.8.111:80
45.8.105.33:80
203.30.191.35:80
185.162.231.178:80
203.30.191.249:80
185.171.230.130:80
31.43.179.33:80
185.238.228.206:80
31.43.179.198:80
185.238.228.54:80
162.247.243.74:80
188.114.96.245:80
172.67.97.232:80
173.245.49.12:80
172.67.254.139:80
141.101.123.9:80
172.67.30.179:80
45.12.31.173:80
203.24.109.66:80
203.34.28.183:80
185.162.229.15:80
203.30.188.239:80
203.28.8.11:80
203.34.28.127:80
45.8.104.62:80
185.162.228.227:80
203.30.190.43:80
203.24.102.164:80
185.171.230.113:80
203.30.190.46:80
203.13.32.184:80
203.30.188.128:80
185.171.231.56:80
185.162.229.205:80
185.171.231.35:80
45.8.104.169:80
203.28.9.207:80
45.12.31.83:80
203.24.108.19:80
141.193.213.251:80
162.247.243.222:80
172.64.151.202:80
172.67.181.45:80
203.24.103.161:80
203.30.188.231:80
203.32.120.189:80
172.67.176.154:80
45.8.107.189:80
45.8.106.17:80
203.28.8.167:80
203.30.191.160:80
45.8.105.163:80
203.24.102.147:80
203.23.104.76:80
203.30.191.31:80
203.34.28.226:80
185.171.230.99:80
185.162.229.166:80
203.30.188.224:80
203.22.223.164:80
203.30.188.82:80
203.32.121.116:80
203.24.102.108:80
203.28.9.57:80
185.162.230.133:80
185.162.229.25:80
203.24.102.44:80
203.30.188.59:80
45.8.105.63:80
203.23.103.106:80
45.12.31.240:80
203.13.32.152:80
203.24.102.1:80
203.23.104.69:80
203.28.9.38:80
203.24.103.253:80
45.12.30.109:80
31.43.179.249:80
45.8.104.38:80
172.67.44.4:80
185.238.228.82:80
172.67.22.240:80
23.227.39.104:80
45.12.31.162:80
203.32.120.238:80
203.24.102.85:80
203.24.109.165:80
45.12.31.20:80
203.23.104.107:80
203.23.104.77:80
203.30.190.191:80
203.23.104.223:80
31.43.179.146:80
172.67.6.231:80
172.67.181.205:80
172.67.70.234:80
203.23.106.223:80
185.162.230.107:80
91.226.97.131:80
203.30.189.115:80
45.8.106.144:80
45.8.107.126:80
203.22.223.150:80
185.162.229.41:80
203.23.106.139:80
203.23.106.229:80
45.8.107.96:80
203.30.191.124:80
203.23.106.109:80
45.8.105.48:80
203.30.190.239:80
45.8.105.37:80
203.30.189.27:80
203.30.188.66:80
203.24.109.151:80
203.24.103.19:80
185.171.230.43:80
45.8.107.17:80
185.162.228.0:80
185.171.230.75:80
45.8.105.150:80
203.32.121.141:80
185.171.231.48:80
45.12.30.47:80
203.28.9.27:80
203.34.28.237:80
45.14.174.199:80
203.13.32.63:80
172.67.43.218:80
203.28.8.94:80
203.23.103.1:80
203.30.189.67:80
203.24.109.137:80
203.23.106.189:80
203.30.189.194:80
45.14.174.245:80
45.8.107.97:80
45.8.106.24:80
23.227.38.223:80
203.30.191.46:80
45.8.104.103:80
185.162.230.64:80
203.32.120.38:80
203.32.121.176:80
203.32.121.56:80
190.93.247.3:80
203.23.104.153:80
91.226.97.96:80
203.24.102.253:80
185.162.229.207:80
203.24.108.135:80
203.24.108.115:80
203.22.223.111:80
45.8.106.205:80
185.171.231.170:80
45.8.104.87:80
203.13.32.192:80
203.24.109.96:80
185.162.228.189:80
185.162.229.47:80
203.28.9.107:80
45.12.30.223:80
185.162.231.86:80
45.8.107.118:80
203.28.9.23:80
185.162.231.109:80
203.24.102.30:80
185.162.228.24:80
203.30.190.32:80
31.43.179.15:80
168.100.6.0:80
141.193.213.187:80
162.247.243.110:80
172.64.140.2:80
203.30.191.103:80
203.30.188.11:80
203.28.8.184:80
203.23.104.5:80
203.22.223.153:80
203.22.223.76:80
203.13.32.194:80
185.171.230.229:80
203.24.102.167:80
203.30.191.152:80
203.24.108.139:80
203.30.188.178:80
23.227.38.17:80
185.171.231.223:80
203.13.32.80:80
45.12.30.9:80
45.12.30.247:80
203.32.121.197:80
45.8.104.106:80
45.8.106.52:80
185.162.229.249:80
31.43.179.212:80
172.67.191.221:80
188.114.96.252:80
172.67.180.26:80
23.227.38.12:80
45.14.174.115:80
203.22.223.34:80
45.12.30.176:80
185.162.231.206:80
203.24.108.205:80
203.32.120.139:80
203.23.103.61:80
185.162.228.137:80
203.32.121.26:80
45.12.31.135:80
185.171.231.1:80
203.24.103.244:80
203.22.223.10:80
203.28.8.20:80
203.30.191.42:80
45.8.106.69:80
203.13.32.253:80
45.14.174.6:80
203.34.28.227:80
185.162.228.108:80
23.227.38.137:80
45.12.30.226:80
31.43.179.111:80
31.43.179.134:80
185.238.228.135:80
172.67.159.96:80
172.67.108.138:80
172.67.3.131:80
185.162.230.41:80
185.162.231.248:80
203.13.32.39:80
45.14.174.252:80
203.32.121.61:80
203.34.28.180:80
185.162.231.73:80
203.23.104.212:80
203.22.223.82:80
203.23.103.75:80
203.30.188.251:80
91.226.97.101:80
23.227.38.216:80
172.67.67.98:80
185.162.231.183:80
45.8.105.146:80
203.32.121.50:80
45.12.30.145:80
203.32.120.148:80
185.162.231.93:80
203.24.109.194:80
45.8.106.108:80
45.12.31.232:80
45.8.106.85:80
45.8.104.200:80
185.162.228.183:80
203.23.103.5:80
203.22.223.231:80
203.23.106.197:80
91.226.97.12:80
203.32.121.43:80
45.8.105.55:80
45.14.174.107:80
203.23.103.74:80
203.32.121.125:80
203.32.120.250:80
185.162.230.156:80
45.12.31.79:80
45.8.107.99:80
203.23.106.187:80
203.24.102.76:80
45.8.107.82:80
45.8.107.10:80
203.30.191.73:80
203.23.104.197:80
203.32.120.136:80
203.23.106.203:80
45.8.104.235:80
31.43.179.219:80
185.238.228.169:80
172.67.172.175:80
172.67.75.167:80
31.43.179.60:80
191.101.251.146:80
141.193.213.249:80
203.13.32.11:80
88.255.65.117:8080
203.28.9.157:80
203.28.9.213:80
185.162.228.248:80
203.34.28.35:80
45.14.174.236:80
203.24.102.151:80
203.22.223.187:80
91.226.97.77:80
203.23.106.37:80
203.24.109.35:80
45.8.104.57:80
185.171.231.198:80
203.23.106.184:80
185.171.230.5:80
45.8.106.113:80
172.67.43.229:80
191.101.251.184:80
188.114.97.2:80
172.67.181.84:80
203.34.28.82:80
45.8.104.178:80
185.171.231.14:80
203.23.103.203:80
185.162.229.43:80
45.8.106.115:80
203.30.191.139:80
45.8.104.220:80
203.28.8.187:80
203.22.223.74:80
23.227.38.184:80
203.28.9.184:80
203.24.103.251:80
31.43.179.197:80
31.43.179.102:80
203.23.106.64:80
203.28.9.55:80
203.30.190.132:80
185.171.230.31:80
185.171.231.158:80
203.23.106.116:80
185.162.231.12:80
23.227.38.92:80
203.28.9.62:80
203.30.188.155:80
203.30.188.213:80
185.162.229.130:80
141.101.123.224:80
172.64.136.149:80
45.8.107.249:80
23.227.38.39:80
203.23.106.127:80
45.12.31.197:80
45.12.30.71:80
203.34.28.26:80
45.8.105.26:80
185.162.228.47:80
203.30.189.34:80
203.24.103.24:80
45.8.105.118:80
203.23.106.44:80
45.12.31.6:80
185.162.228.118:80
185.162.231.188:80
45.8.106.234:80
185.171.230.220:80
185.162.229.217:80
185.162.229.12:80
203.28.9.241:80
203.32.120.53:80
185.162.228.209:80
190.93.246.210:80
162.247.243.21:80
188.114.98.160:80
103.21.244.3:80
23.227.38.122:80
203.24.102.168:80
185.162.229.133:80
185.162.230.153:80
185.171.231.173:80
91.226.97.64:80
203.30.189.169:80
45.8.104.92:80
203.24.108.245:80
185.162.230.43:80
45.12.31.23:80
203.30.191.70:80
203.24.108.82:80
91.226.97.152:80
191.101.251.68:80
185.238.228.56:80
191.101.251.168:80
172.67.182.137:80
172.67.181.156:80
203.24.108.171:80
203.30.191.125:80
91.226.97.132:80
203.34.28.36:80
203.24.102.210:80
203.24.108.65:80
203.28.8.249:80
185.162.228.250:80
203.22.223.63:80
185.171.230.36:80
203.30.189.146:80
203.13.32.90:80
203.30.191.243:80
203.32.121.137:80
45.8.106.112:80
203.23.104.200:80
172.64.172.245:80
172.64.202.2:80
172.64.130.119:80
172.64.207.96:80
188.114.96.253:80
172.67.181.54:80
172.67.126.178:80
172.67.70.89:80
203.30.191.246:80
203.22.223.135:80
203.24.102.49:80
203.28.8.135:80
203.32.121.238:80
203.24.103.243:80
203.34.28.146:80
45.8.106.74:80
185.162.229.136:80
45.8.107.93:80
203.28.9.11:80
185.162.228.204:80
45.8.107.80:80
203.34.28.228:80
185.171.230.214:80
203.30.188.221:80
203.34.28.162:80
203.23.104.167:80
45.12.30.243:80
45.14.174.132:80
203.13.32.66:80
185.162.230.100:80
172.67.73.239:80
141.193.213.37:80
172.67.182.59:80
172.67.70.91:80
172.67.70.135:80
203.23.106.238:80
203.30.188.179:80
45.8.104.255:80
45.8.104.58:80
203.24.109.109:80
203.22.223.132:80
203.22.223.121:80
203.28.9.69:80
203.24.102.57:80
185.162.230.245:80
203.30.189.107:80
203.28.9.182:80
23.227.38.219:80
45.12.30.130:80
203.22.223.33:80
203.24.102.182:80
203.34.28.84:80
45.8.107.11:80
203.23.103.85:80
203.34.28.137:80
203.34.28.17:80
45.14.174.145:80
45.8.104.33:80
172.67.172.181:80
172.67.43.142:80
172.67.192.44:80
172.64.89.0:80
172.67.80.69:80
23.227.39.226:80
172.67.97.169:80
185.162.228.35:80
91.226.97.253:80
203.30.188.72:80
203.32.120.0:80
203.24.108.49:80
185.171.231.231:80
91.226.97.250:80
23.227.38.196:80
203.24.103.39:80
203.23.106.170:80
203.23.106.18:80
45.8.106.13:80
185.162.228.191:80
191.101.251.62:80
172.67.75.197:80
172.67.75.4:80
91.226.97.37:80
203.32.120.39:80
185.162.228.94:80
203.34.28.112:80
172.67.181.220:80
203.34.28.156:80
103.21.244.32:80
203.30.188.95:80
203.32.121.150:80
203.22.223.245:80
203.24.102.244:80
185.162.229.227:80
185.162.231.182:80
203.24.108.240:80
45.12.31.152:80
203.22.223.42:80
185.162.231.120:80
203.28.8.139:80
185.162.230.138:80
203.32.120.93:80
23.227.38.125:80
185.162.228.195:80
203.32.120.221:80
203.13.32.50:80
203.23.104.193:80
45.12.31.78:80
45.12.30.162:80
45.8.107.5:80
203.24.108.76:80
172.67.47.56:80
31.43.179.221:80
191.101.251.165:80
191.101.251.85:80
172.67.60.124:80
172.64.145.2:80
188.114.97.17:80
103.21.244.36:80
203.24.102.142:80
172.67.176.121:80
203.23.104.209:80
203.23.106.10:80
45.8.104.107:80
45.8.105.132:80
203.23.104.229:80
173.245.49.56:80
172.67.177.69:80
203.24.102.53:80
203.24.103.46:80
185.162.228.115:80
185.171.231.183:80
91.226.97.225:80
203.28.8.237:80
45.12.31.46:80
203.30.189.103:80
203.22.223.5:80
203.24.108.102:80
185.171.230.15:80
45.14.174.214:80
185.162.230.112:80
203.22.223.110:80
188.114.98.160:80
203.23.103.223:80
45.8.107.145:80
45.8.106.99:80
203.28.8.21:80
203.23.106.46:80
203.23.106.115:80
185.162.231.116:80
91.226.97.106:80
203.32.120.155:80
45.14.174.61:80
188.114.99.137:80
162.247.243.27:80
191.101.251.154:80
172.67.36.174:80
203.30.190.204:80
172.67.176.105:80
203.32.120.10:80
203.30.188.60:80
203.24.108.156:80
203.24.102.72:80
203.23.103.102:80
203.24.109.29:80
203.30.191.27:80
185.162.228.93:80
203.24.108.103:80
203.30.189.124:80
185.171.230.253:80
45.8.105.231:80
203.30.189.208:80
185.162.231.180:80
185.162.229.52:80
31.43.179.114:80
185.238.228.221:80
162.247.243.51:80
172.64.151.2:80
45.8.105.131:80
154.236.168.169:1981
201.222.45.64:999
45.12.30.187:80
172.67.177.253:80
185.171.230.1:80
203.30.191.90:80
45.12.31.207:80
203.23.104.34:80
45.14.174.156:80
45.14.174.137:80
203.24.108.208:80
185.162.230.190:80
203.30.190.56:80
185.162.229.92:80
203.23.104.80:80
203.23.104.138:80
203.34.28.151:80
203.28.8.245:80
185.171.231.152:80
203.22.223.108:80
45.12.31.170:80
203.13.32.186:80
203.28.8.42:80
203.13.32.52:80
203.30.190.216:80
203.30.190.38:80
185.171.230.30:80
203.30.190.44:80
45.8.104.142:80
203.30.191.101:80
203.13.32.175:80
31.43.179.205:80
141.193.213.226:80
172.67.70.214:80
203.34.28.120:80
45.8.105.175:80
45.8.106.116:80
45.12.31.241:80
185.171.230.206:80
45.8.106.244:80
185.171.230.57:80
203.23.106.236:80
45.12.30.209:80
185.162.228.181:80
203.24.102.207:80
45.8.106.222:80
45.12.30.7:80
91.226.97.7:80
203.34.28.245:80
203.28.9.14:80
203.24.102.150:80
45.14.174.119:80
91.226.97.199:80
141.193.213.136:80
185.238.228.156:80
172.67.75.170:80
188.114.99.160:80
172.67.38.3:80
172.67.182.22:80
172.67.181.211:80
172.67.70.8:80
172.67.73.243:80
45.14.174.140:80
203.23.103.55:80
45.14.174.98:80
203.24.103.146:80
185.162.228.8:80
185.162.231.61:80
185.171.230.76:80
203.34.28.167:80
45.12.30.23:80
203.23.106.204:80
203.30.190.228:80
203.23.103.145:80
203.24.108.116:80
185.162.231.174:80
203.32.120.9:80
45.8.104.153:80
45.8.104.141:80
45.8.107.218:80
203.30.189.91:80
185.162.230.57:80
203.24.108.39:80
203.24.102.178:80
31.43.179.248:80
31.43.179.173:80
172.67.44.2:80
191.101.251.109:80
203.24.108.136:80
203.30.189.147:80
45.8.106.186:80
203.13.32.17:80
203.23.106.222:80
203.22.223.48:80
203.24.103.119:80
45.14.174.155:80
203.32.121.209:80
203.30.191.172:80
203.22.223.12:80
45.8.107.214:80
45.12.30.240:80
31.43.179.127:80
172.67.182.150:80
203.32.120.201:80
203.32.121.160:80
45.8.104.56:80
203.13.32.232:80
185.162.229.49:80
172.67.0.42:80
203.30.190.148:80
203.32.120.19:80
203.22.223.62:80
203.22.223.46:80
203.23.104.19:80
185.162.228.153:80
203.22.223.190:80
203.23.104.184:80
203.24.103.49:80
203.24.102.203:80
203.24.103.1:80
203.30.188.172:80
203.28.8.39:80
45.8.105.29:80
91.226.97.137:80
203.30.188.254:80
203.23.103.132:80
203.24.109.221:80
203.32.120.185:80
203.23.104.142:80
203.30.189.52:80
31.43.179.254:80
191.101.251.114:80
185.238.228.39:80
185.238.228.91:80
203.23.103.247:80
203.32.120.54:80
203.30.191.37:80
203.34.28.55:80
185.238.228.90:80
141.193.213.180:80
203.22.223.64:80
203.13.32.105:80
185.162.230.14:80
203.24.109.70:80
45.8.104.42:80
185.162.228.216:80
203.32.121.227:80
45.12.31.34:80
185.162.228.52:80
185.162.228.199:80
185.223.154.145:80
203.24.103.152:80
185.171.231.172:80
45.12.31.50:80
203.32.121.215:80
45.8.107.166:80
203.28.8.169:80
45.8.107.236:80
203.30.189.249:80
45.8.105.166:80
203.23.103.77:80
185.162.231.124:80
203.23.104.128:80
185.171.231.188:80
203.23.104.216:80
185.162.230.26:80
185.171.231.19:80
185.193.30.29:80
191.101.251.55:80
162.247.243.0:80
203.23.104.74:80
203.13.32.208:80
203.24.109.55:80
185.162.228.129:80
45.8.107.104:80
91.226.97.98:80
203.23.104.114:80
162.247.243.18:80
172.67.255.212:80
185.162.229.193:80
185.171.230.102:80
203.28.9.53:80
185.171.231.244:80
203.28.9.1:80
203.30.189.233:80
23.227.38.33:80
203.24.102.9:80
45.8.106.88:80
45.8.106.41:80
185.162.229.105:80
162.247.243.205:80
172.67.180.250:80
203.23.104.207:80
185.171.230.227:80
45.8.105.105:80
185.162.230.231:80
203.28.8.96:80
203.30.189.195:80
45.8.106.175:80
203.30.189.223:80
203.24.108.16:80
45.12.30.140:80
203.13.32.238:80
203.24.102.60:80
203.30.189.40:80
203.23.103.8:80
203.24.102.62:80
203.13.32.158:80
203.34.28.117:80
31.43.179.5:80
172.67.43.207:80
172.67.146.139:80
203.23.106.39:80
172.67.176.229:80
172.67.177.217:80
185.171.231.32:80
45.12.30.20:80
185.162.231.58:80
203.23.106.74:80
203.24.103.2:80
45.12.31.38:80
203.24.103.169:80
203.30.190.14:80
23.227.38.142:80
185.162.228.106:80
141.101.123.217:80
203.23.106.240:80
203.32.121.77:80
203.34.28.111:80
185.162.228.87:80
45.12.31.193:80
203.23.104.201:80
45.12.30.242:80
203.24.103.189:80
185.171.231.153:80
45.8.104.227:80
23.227.38.37:80
203.32.121.24:80
203.32.120.125:80
203.23.103.37:80
45.8.106.110:80
203.30.189.82:80
185.162.231.22:80
203.24.102.0:80
203.24.108.246:80
91.226.97.230:80
45.12.30.85:80
203.30.189.184:80
203.22.223.191:80
91.226.97.187:80
203.13.32.254:80
203.30.190.118:80
203.23.104.243:80
203.23.106.169:80
185.162.230.36:80
45.8.105.236:80
203.28.8.176:80
185.162.228.75:80
141.193.213.25:80
172.64.110.180:80
172.67.3.150:80
203.28.9.191:80
203.30.188.65:80
203.24.108.254:80
45.8.107.84:80
203.34.28.168:80
185.162.229.247:80
45.8.106.44:80
203.30.191.41:80
203.24.108.10:80
45.8.104.98:80
203.24.109.146:80
203.32.121.10:80
45.8.106.168:80
185.171.231.232:80
185.162.228.110:80
185.238.228.139:80
162.247.243.19:80
188.114.97.92:80
172.67.181.9:80
203.13.32.125:80
45.8.104.64:80
45.8.104.150:80
203.13.32.47:80
203.24.109.235:80
185.162.231.207:80
203.30.188.222:80
203.34.28.166:80
45.8.106.23:80
203.22.223.225:80
203.28.8.213:80
185.171.231.212:80
185.171.230.62:80
45.12.31.39:80
185.162.228.178:80
203.24.109.50:80
185.171.230.237:80
91.226.97.141:80
31.43.179.228:80
141.193.213.224:80
185.238.228.51:80
172.66.40.89:80
185.171.230.185:80
203.34.28.189:80
45.8.107.47:80
203.28.9.187:80
203.28.8.75:80
45.8.107.212:80
185.162.230.204:80
203.24.108.123:80
141.193.213.158:80
172.67.185.194:80
172.67.0.3:80
172.64.103.196:80
172.67.176.11:80
203.34.28.143:80
203.24.108.157:80
172.67.167.112:80
172.67.177.44:80
203.32.121.130:80
45.8.104.167:80
203.24.109.237:80
203.30.190.178:80
203.30.189.98:80
203.13.32.248:80
203.24.109.108:80
185.162.231.28:80
45.8.106.6:80
203.24.103.34:80
23.227.38.174:80
45.8.104.123:80
203.30.188.89:80
23.227.38.168:80
203.22.223.195:80
203.24.103.188:80
45.8.106.169:80
203.13.32.180:80
203.30.188.198:80
45.8.106.120:80
45.14.174.10:80
203.13.32.216:80
91.226.97.57:80
45.8.107.58:80
185.162.231.94:80
203.30.189.148:80
31.43.179.40:80
185.238.228.20:80
185.238.228.251:80
31.43.179.239:80
172.67.182.13:80
141.193.213.113:80
162.247.243.140:80
185.171.230.196:80
172.67.70.116:80
45.8.104.30:80
172.67.177.128:80
185.162.228.42:80
203.24.102.191:80
203.23.103.221:80
45.8.105.109:80
203.30.190.221:80
203.30.190.159:80
185.162.230.46:80
203.24.103.15:80
203.24.108.232:80
203.24.108.131:80
203.30.188.236:80
203.28.8.92:80
185.171.231.61:80
203.23.103.23:80
45.8.105.70:80
203.28.9.99:80
31.43.179.19:80
185.238.228.213:80
172.67.185.183:80
103.21.244.15:80
190.93.245.9:80
203.28.9.71:80
203.23.103.254:80
45.8.104.136:80
203.24.108.217:80
203.30.190.181:80
45.12.31.253:80
185.162.228.144:80
203.28.8.205:80
203.23.106.165:80
203.22.223.127:80
185.171.230.240:80
203.24.103.58:80
203.30.189.188:80
45.8.107.28:80
185.162.229.157:80
203.28.8.244:80
203.23.103.66:80
45.8.104.240:80
203.28.9.72:80
203.28.8.129:80
185.171.231.215:80
203.23.106.209:80
162.247.243.116:80
172.67.170.24:80
172.67.182.14:80
203.30.190.82:80
203.24.103.245:80
203.28.8.79:80
203.32.120.56:80
45.8.107.22:80
203.30.189.224:80
203.24.103.254:80
203.13.32.174:80
45.12.31.85:80
172.67.43.146:80
185.162.228.237:80
162.247.243.69:80
172.67.70.6:80
203.13.32.136:80
45.12.30.157:80
172.67.177.215:80
45.8.106.240:80
203.32.121.23:80
185.171.231.201:80
45.8.105.126:80
45.12.30.110:80
203.23.106.155:80
45.12.30.251:80
45.8.106.16:80
203.24.109.73:80
45.8.104.157:80
203.30.190.171:80
203.34.28.154:80
45.12.31.104:80
203.23.103.116:80
23.227.38.158:80
203.34.28.108:80
203.23.103.242:80
203.24.102.158:80
185.171.231.16:80
203.30.191.147:80
203.22.223.125:80
203.32.120.132:80
203.30.189.30:80
91.226.97.189:80
203.28.9.78:80
45.159.216.0:80
203.30.189.133:80
185.238.228.41:80
172.64.68.249:80
203.34.28.105:80
185.162.231.153:80
203.23.104.97:80
203.24.103.62:80
203.30.190.91:80
203.24.102.245:80
203.28.9.8:80
203.23.103.29:80
203.24.102.29:80
203.24.102.237:80
203.24.109.119:80
45.8.104.68:80
203.30.190.220:80
185.238.228.31:80
45.12.31.37:80
141.193.213.86:80
172.64.150.2:80
172.64.200.2:80
45.131.210.165:80
172.67.82.8:80
23.227.38.123:80
185.171.230.93:80
203.30.191.96:80
203.23.103.214:80
203.30.190.136:80
203.32.120.246:80
203.30.190.200:80
203.24.103.70:80
203.24.108.111:80
191.101.251.46:80
191.101.251.73:80
45.12.30.12:80
45.8.105.144:80
203.23.104.233:80
203.24.108.203:80
45.12.30.68:80
185.162.230.234:80
185.162.231.46:80
45.8.106.30:80
203.30.188.78:80
203.24.108.98:80
45.12.30.69:80
203.13.32.79:80
45.12.31.15:80
203.13.32.163:80
203.30.190.155:80
203.24.109.49:80
203.24.108.181:80
31.43.179.88:80
185.238.228.142:80
162.247.243.64:80
172.67.253.181:80
203.23.106.61:80
185.162.229.90:80
45.12.31.58:80
45.12.31.151:80
185.162.231.14:80
203.34.28.135:80
91.226.97.47:80
185.162.228.188:80
203.32.120.176:80
45.12.31.84:80
91.226.97.8:80
203.30.190.74:80
203.24.109.123:80
203.23.103.153:80
203.32.120.14:80
203.23.104.137:80
203.28.8.178:80
203.23.103.155:80
203.24.103.237:80
45.8.107.220:80
185.171.230.245:80
185.162.231.29:80
45.8.106.103:80
203.28.8.34:80
203.28.9.164:80
45.14.174.53:80
45.12.31.116:80
203.28.8.10:80
203.22.223.35:80
23.227.38.80:80
203.30.188.225:80
185.238.228.155:80
172.67.185.199:80
172.67.224.254:80
203.32.121.229:80
203.23.106.242:80
185.171.231.112:80
45.8.104.4:80
185.162.230.184:80
45.8.106.133:80
203.34.28.176:80
185.162.231.232:80
185.162.230.73:80
185.162.229.45:80
188.114.99.160:80
141.101.115.243:80
172.67.149.62:80
203.32.121.33:80
203.23.106.244:80
185.162.231.228:80
45.8.107.91:80
203.24.109.3:80
203.30.188.114:80
203.32.120.67:80
203.24.103.225:80
203.24.103.47:80
203.28.9.220:80
185.162.230.164:80
31.43.179.190:80
172.67.181.126:80
45.14.174.148:80
203.22.223.102:80
185.162.228.213:80
45.12.31.233:80
203.32.120.207:80
185.171.231.239:80
203.24.103.143:80
23.227.38.132:80
203.32.121.100:80
45.8.107.26:80
203.23.106.79:80
203.32.121.52:80
203.24.103.43:80
203.22.223.22:80
203.24.108.89:80
185.162.231.82:80
45.12.30.138:80
45.12.30.248:80
203.30.188.176:80
203.28.8.148:80
45.8.105.219:80
185.238.228.226:80
188.114.96.28:80
31.43.179.98:80
172.67.182.72:80
23.227.38.59:80
185.171.231.207:80
185.162.231.47:80
203.24.103.20:80
173.245.49.33:80
172.67.180.28:80
203.23.104.132:80
203.23.103.218:80
203.32.120.212:80
203.23.106.231:80
45.12.31.105:80
185.162.231.107:80
203.23.106.137:80
203.23.103.58:80
45.8.106.196:80
45.14.174.96:80
203.34.28.101:80
203.34.28.204:80
45.12.31.19:80
203.24.108.186:80
203.24.103.147:80
185.162.231.60:80
45.8.104.168:80
185.162.231.19:80
203.23.106.152:80
185.171.230.74:80
203.28.9.3:80
185.162.229.190:80
203.34.28.215:80
203.28.9.92:80
45.8.107.252:80
185.162.229.242:80
203.24.103.12:80
45.8.105.102:80
185.162.231.111:80
203.23.104.246:80
203.24.108.27:80
45.8.106.208:80
203.13.32.161:80
45.8.107.127:80
91.226.97.89:80
185.162.230.223:80
203.30.190.209:80
45.8.105.60:80
91.226.97.244:80
23.227.38.93:80
203.30.191.17:80
91.226.97.177:80
172.67.219.1:80
203.34.28.125:80
185.171.231.175:80
203.30.191.228:80
203.24.109.28:80
203.28.9.22:80
185.171.230.168:80
203.30.189.129:80
203.30.189.109:80
23.227.38.45:80
203.32.121.233:80
45.8.106.21:80
45.8.107.117:80
203.24.102.128:80
185.162.230.182:80
203.24.103.138:80
185.162.230.230:80
45.8.105.72:80
31.43.179.91:80
203.23.103.174:80
203.30.189.187:80
203.23.104.170:80
203.28.8.157:80
45.14.174.173:80
45.8.105.45:80
185.162.229.94:80
203.28.8.80:80
203.24.103.23:80
23.227.38.238:80
185.162.229.211:80
45.12.31.54:80
203.30.190.54:80
203.24.108.113:80
203.30.191.43:80
203.24.102.47:80
23.227.38.185:80
203.24.103.54:80
45.12.31.222:80
203.32.121.223:80
203.22.223.176:80
203.32.120.124:80
203.13.32.119:80
203.23.104.47:80
45.12.30.146:80
203.30.191.198:80
162.247.243.171:80
185.238.228.141:80
172.67.181.240:80
172.67.165.43:80
203.32.121.123:80
203.23.103.99:80
172.67.176.1:80
185.162.228.90:80
203.23.106.248:80
45.8.107.69:80
203.24.108.128:80
185.162.229.26:80
162.247.243.7:80
203.28.9.202:80
203.34.28.65:80
203.30.188.97:80
45.14.174.180:80
203.23.106.186:80
203.23.104.8:80
203.24.109.92:80
185.171.231.138:80
203.28.8.121:80
203.28.9.51:80
203.22.223.36:80
203.24.108.104:80
185.171.231.208:80
45.8.107.38:80
185.162.229.96:80
203.24.108.213:80
45.12.30.8:80
172.67.179.179:80
172.67.185.196:80
162.247.243.45:80
162.247.243.30:80
172.67.202.243:80
23.227.38.16:80
203.23.104.178:80
45.8.107.102:80
173.245.49.99:80
203.23.106.8:80
172.67.182.26:80
172.67.188.15:80
203.13.32.82:80
203.30.188.162:80
203.30.190.144:80
203.23.104.84:80
172.67.253.249:80
172.67.3.103:80
185.162.229.95:80
203.13.32.185:80
203.30.190.68:80
203.34.28.218:80
45.12.31.186:80
23.227.38.230:80
203.24.109.91:80
23.227.38.240:80
203.32.120.33:80
185.162.228.146:80
45.8.107.228:80
203.28.8.174:80
203.13.32.18:80
203.24.108.63:80
45.12.30.244:80
45.12.31.228:80
203.23.104.238:80
45.8.106.81:80
203.30.189.15:80
203.24.108.160:80
203.23.103.62:80
45.8.107.191:80
185.171.230.117:80
185.162.229.144:80
23.227.38.107:80
45.12.31.92:80
185.171.230.175:80
203.34.28.205:80
185.171.231.210:80
172.67.180.247:80
162.247.243.9:80
188.114.97.10:80
185.238.228.173:80
172.67.229.43:80
172.67.181.58:80
172.67.254.149:80
45.14.174.84:80
173.245.49.1:80
173.245.49.43:80
103.21.244.4:80
172.67.181.104:80
185.162.231.71:80
203.23.106.29:80
203.30.188.244:80
203.23.104.65:80
203.23.104.103:80
203.34.28.163:80
45.8.106.246:80
203.24.109.61:80
203.24.108.228:80
45.14.174.152:80
203.30.190.100:80
203.28.8.1:80
45.8.105.10:80
185.171.231.111:80
185.162.230.70:80
185.171.230.28:80
23.227.38.246:80
173.245.49.57:80
173.245.49.92:80
203.23.104.161:80
203.32.120.172:80
203.23.103.110:80
203.30.189.246:80
185.162.231.235:80
172.67.181.82:80
172.67.128.116:80
172.67.182.159:80
172.67.180.11:80
172.67.176.7:80
172.67.176.10:80
172.67.176.26:80
172.67.176.87:80
172.67.177.106:80
185.162.231.100:80
203.24.109.130:80
203.28.9.176:80
203.24.102.95:80
203.23.104.44:80
203.23.106.83:80
203.30.191.244:80
203.23.106.114:80
141.193.213.92:80
141.101.115.251:80
203.24.109.62:80
203.32.120.55:80
45.8.107.34:80
203.24.103.142:80
203.28.8.241:80
45.12.30.91:80
203.30.190.150:80
203.28.8.132:80
203.32.120.236:80
203.34.28.67:80
203.30.189.206:80
185.162.230.140:80
203.28.9.114:80
45.12.30.127:80
203.30.191.69:80
45.8.105.154:80
185.171.230.81:80
203.23.103.156:80
203.30.189.145:80
203.32.120.159:80
91.226.97.111:80
91.226.97.6:80
45.14.174.169:80
185.238.228.2:80
188.114.96.1:80
112.14.40.137:9091
172.67.181.173:80
203.34.28.69:80
173.245.49.94:80
172.67.148.92:80
141.101.123.14:80
190.93.244.9:80
203.13.32.22:80
203.23.104.61:80
203.24.109.240:80
23.227.38.225:80
203.32.120.31:80
185.171.230.197:80
185.162.229.36:80
45.8.105.58:80
45.8.106.58:80
185.162.229.127:80
203.28.8.99:80
203.28.9.4:80
203.30.189.59:80
45.12.30.163:80
45.8.104.34:80
203.28.8.143:80
173.245.49.58:80
173.245.49.112:80
203.30.190.113:80
203.30.191.4:80
203.28.9.41:80
203.32.121.2:80
45.12.30.34:80
23.227.38.55:80
143.47.187.121:80
172.67.148.182:80
172.67.136.41:80
172.64.95.40:80
173.245.49.2:80
103.21.244.19:80
172.67.177.201:80
91.226.97.222:80
203.32.121.168:80
185.171.230.235:80
91.226.97.51:80
203.13.32.35:80
185.162.231.219:80
185.162.230.86:80
185.171.230.207:80
185.171.230.52:80
91.226.97.204:80
203.24.109.218:80
203.23.106.125:80
203.28.8.5:80
172.67.192.17:80
188.114.97.181:80
172.67.152.107:80
188.114.97.16:80
172.67.240.126:80
173.245.49.53:80
203.24.108.117:80
203.30.189.69:80
185.162.230.109:80
203.24.108.114:80
185.162.230.122:80
45.8.105.92:80
203.22.223.81:80
45.8.106.25:80
45.14.174.114:80
203.30.190.60:80
203.24.108.147:80
173.245.49.72:80
203.30.191.50:80
23.227.38.226:80
191.101.251.238:80
188.114.97.3:80
172.67.181.49:80
172.67.181.140:80
172.67.181.202:80
203.24.102.215:80
45.14.174.162:80
203.30.190.116:80
45.14.174.3:80
91.226.97.136:80
203.28.9.196:80
45.14.174.208:80
203.24.109.247:80
203.30.189.157:80
185.162.231.128:80
185.171.230.118:80
91.226.97.202:80
203.24.109.231:80
203.22.223.38:80
45.12.31.41:80
185.171.231.204:80
45.12.31.21:80
191.101.251.61:80
141.193.213.73:80
162.247.243.134:80
173.245.49.6:80
173.245.49.18:80
203.24.102.242:80
203.30.191.254:80
173.245.49.110:80
173.245.49.84:80
173.245.49.118:80
203.32.120.210:80
172.67.192.40:80
172.67.182.36:80
172.67.181.61:80
172.67.254.164:80
172.67.177.232:80
172.67.188.26:80
172.67.185.209:80
172.67.181.3:80
172.67.182.47:80
172.67.181.11:80
172.67.182.52:80
203.23.103.171:80
203.24.109.121:80
203.23.104.52:80
203.24.102.222:80
203.23.103.190:80
203.32.121.225:80
185.162.228.20:80
203.24.103.33:80
203.23.103.167:80
45.8.105.54:80
203.23.103.48:80
203.24.109.229:80
173.245.49.105:80
203.24.109.148:80
45.14.174.251:80
203.22.223.160:80
203.22.223.20:80
45.14.174.206:80
203.28.8.3:80
203.22.223.103:80
203.23.103.42:80
203.24.108.202:80
203.24.108.14:80
191.101.251.84:80
191.101.251.129:80
191.101.251.102:80
172.67.185.153:80
172.67.192.28:80
172.64.144.2:80
188.114.96.247:80
173.245.49.50:80
91.226.97.184:80
185.162.231.168:80
203.30.191.59:80
203.32.120.118:80
185.162.230.203:80
203.24.103.156:80
185.162.229.252:80
23.227.38.48:80
203.13.32.85:80
185.162.230.196:80
45.12.31.192:80
203.24.108.7:80
203.32.120.219:80
203.22.223.206:80
45.8.107.92:80
173.245.49.73:80
203.32.121.157:80
203.28.8.63:80
185.162.228.2:80
185.162.231.140:80
203.30.188.219:80
45.14.174.103:80
159.112.235.17:80
203.24.108.88:80
203.34.28.24:80
203.30.188.154:80
203.30.188.30:80
185.162.228.149:80
45.8.107.32:80
45.8.104.221:80
203.13.32.213:80
203.23.106.73:80
203.24.108.193:80
45.8.104.198:80
91.226.97.100:80
203.22.223.226:80
203.30.189.106:80
203.23.104.208:80
203.34.28.153:80
172.67.179.183:80
185.238.228.72:80
172.67.185.198:80
172.67.21.12:80
172.67.176.221:80
172.67.177.111:80
172.67.180.39:80
172.67.180.34:80
203.30.188.168:80
45.8.107.95:80
45.14.174.219:80
23.227.38.172:80
203.23.104.136:80
185.162.229.137:80
203.34.28.107:80
45.14.174.205:80
185.162.228.210:80
185.162.230.149:80
45.8.105.14:80
173.245.49.67:80
173.245.49.77:80
203.23.106.208:80
203.13.32.103:80
203.24.109.95:80
203.30.189.105:80
141.193.213.18:80
185.238.228.7:80
172.67.43.89:80
172.67.188.21:80
172.67.191.236:80
141.193.213.116:80
172.67.135.141:80
172.67.181.197:80
173.245.49.24:80
173.245.49.41:80
172.67.167.222:80
45.8.107.207:80
45.12.31.65:80
185.162.230.244:80
203.30.191.211:80
203.23.106.123:80
203.24.108.83:80
45.8.105.19:80
185.171.231.85:80
185.162.229.189:80
45.8.104.252:80
185.238.228.178:80
172.67.180.6:80
172.64.141.11:80
172.67.181.182:80
172.67.181.125:80
185.162.229.228:80
203.24.108.61:80
203.13.32.167:80
203.30.189.232:80
203.24.103.230:80
203.34.28.150:80
203.34.28.34:80
203.24.102.173:80
203.30.191.53:80
203.34.28.196:80
203.32.121.29:80
203.24.108.252:80
203.24.102.16:80
203.22.223.156:80
203.24.103.151:80
203.32.121.140:80
203.24.103.55:80
23.227.38.245:80
203.32.120.37:80
185.162.231.41:80
203.30.189.39:80
203.23.106.173:80
45.12.31.100:80
203.23.104.154:80
172.67.172.153:80
162.247.243.253:80
203.30.188.71:80
162.247.243.50:80
172.67.188.168:80
172.67.181.25:80
172.67.132.121:80
172.67.180.38:80
172.67.176.115:80
203.28.9.221:80
45.8.105.11:80
185.162.231.90:80
45.8.104.185:80
45.12.31.98:80
203.30.191.149:80
203.24.108.13:80
203.28.9.33:80
185.171.231.74:80
203.13.32.98:80
191.101.251.148:80
191.101.251.195:80
191.101.251.249:80
172.67.181.55:80
172.67.182.5:80
172.67.177.230:80
185.162.231.40:80
203.24.103.80:80
185.171.231.142:80
173.245.49.81:80
185.162.228.51:80
203.13.32.33:80
203.23.103.220:80
203.22.223.173:80
185.171.231.86:80
172.67.179.198:80
191.101.251.174:80
172.67.255.220:80
172.67.3.137:80
172.67.176.185:80
203.23.104.230:80
162.247.243.26:80
172.67.182.162:80
172.67.161.128:80
172.67.176.4:80
203.13.32.244:80
185.162.228.22:80
185.171.231.63:80
185.162.231.51:80
45.8.105.1:80
203.30.190.215:80
203.24.108.68:80
45.8.106.164:80
185.162.229.225:80
203.23.103.113:80
203.24.102.214:80
203.30.191.36:80
203.23.103.200:80
203.34.28.44:80
203.23.106.67:80
203.30.191.116:80
203.24.103.201:80
185.162.231.170:80
45.8.104.126:80
203.23.104.32:80
185.162.231.200:80
203.28.9.84:80
185.162.228.71:80
203.24.102.90:80
173.245.49.93:80
45.8.104.17:80
45.8.107.107:80
203.24.102.247:80
203.24.103.160:80
203.24.103.248:80
185.162.230.78:80
203.22.223.151:80
172.67.0.40:80
172.67.43.189:80
172.67.43.90:80
172.64.166.2:80
172.67.165.35:80
172.67.254.166:80
172.66.43.12:80
185.162.229.238:80
203.24.102.163:80
91.226.97.226:80
203.34.28.200:80
203.30.190.212:80
203.30.190.180:80
203.24.102.33:80
203.22.223.49:80
203.32.121.64:80
185.171.231.26:80
203.13.32.236:80
203.23.103.11:80
203.24.109.64:80
203.32.121.9:80
203.28.8.152:80
172.67.185.207:80
141.193.213.19:80
172.67.181.167:80
172.67.176.180:80
45.8.107.234:80
185.162.231.123:80
185.162.231.126:80
203.23.106.97:80
203.30.191.110:80
45.8.105.24:80
185.171.231.218:80
203.30.189.183:80
203.24.108.133:80
203.24.102.82:80
203.24.103.103:80
203.32.121.114:80
173.245.49.28:80
172.67.157.169:80
173.245.49.35:80
45.12.30.105:80
203.13.32.223:80
45.8.107.98:80
203.23.103.100:80
185.162.228.41:80
45.8.106.14:80
185.162.231.7:80
185.162.228.116:80
172.67.188.24:80
172.67.181.108:80
172.67.182.131:80
172.67.177.125:80
172.67.176.189:80
172.67.177.22:80
172.67.177.167:80
185.162.229.181:80
185.162.231.234:80
172.67.188.12:80
172.67.185.158:80
172.67.185.175:80
172.67.192.51:80
141.101.114.26:80
172.67.181.72:80
172.67.181.206:80
173.245.49.37:80
172.67.3.142:80
185.162.231.209:80
203.34.28.164:80
45.12.30.148:80
185.171.231.129:80
45.8.104.24:80
91.226.97.174:80
45.12.31.227:80
203.30.189.227:80
45.8.105.165:80
203.23.104.90:80
185.171.230.100:80
203.23.103.246:80
45.8.105.27:80
203.30.188.182:80
45.8.105.94:80
203.30.190.224:80
185.171.231.107:80
45.8.105.128:80
45.8.106.122:80
185.171.230.19:80
172.67.43.191:80
141.193.213.11:80
172.64.147.215:80
172.67.181.18:80
172.67.181.19:80
172.67.133.69:80
172.67.254.130:80
172.67.254.137:80
172.67.254.155:80
172.67.3.125:80
172.67.180.64:80
172.67.181.119:80
172.67.167.205:80
172.67.177.239:80
203.30.190.139:80
203.24.103.249:80
203.23.104.189:80
23.227.38.145:80
203.23.104.199:80
203.24.103.207:80
203.32.121.254:80
45.8.106.77:80
45.8.104.2:80
45.8.107.254:80
203.24.108.80:80
172.67.170.7:80
172.67.182.200:80
172.67.179.215:80
172.67.4.142:80
45.8.105.180:80
203.34.28.169:80
185.171.231.69:80
23.227.38.160:80
203.13.32.219:80
91.226.97.153:80
23.227.38.181:80
203.34.28.124:80
203.32.121.183:80
185.162.228.245:80
203.32.121.94:80
203.28.8.243:80
203.23.106.57:80
203.24.102.56:80
203.28.9.109:80
91.226.97.46:80
203.30.188.24:80
185.162.230.115:80
203.30.190.243:80
185.238.228.128:80
172.67.182.49:80
172.67.181.163:80
45.8.106.254:80
203.32.121.62:80
23.227.38.114:80
203.28.9.112:80
172.67.181.234:80
172.67.182.11:80
173.245.49.42:80
172.67.177.108:80
172.67.177.142:80
172.67.177.205:80
203.24.109.203:80
203.32.121.119:80
23.227.38.177:80
203.24.108.191:80
185.162.231.4:80
203.24.109.79:80
203.30.191.108:80
203.24.103.209:80
203.30.190.166:80
203.30.190.255:80
185.171.231.155:80
45.12.31.209:80
185.171.230.170:80
203.32.121.243:80
185.171.230.218:80
45.14.174.244:80
45.8.107.109:80
173.245.49.115:80
185.162.230.63:80
203.23.106.230:80
45.12.30.97:80
203.30.188.38:80
203.24.103.28:80
185.162.231.13:80
185.162.228.243:80
172.67.179.189:80
31.43.179.177:80
172.67.181.241:80
172.67.75.181:80
141.193.213.201:80
172.67.247.184:80
45.8.104.21:80
203.30.189.230:80
23.227.38.96:80
45.14.174.28:80
173.245.49.113:80
45.8.104.83:80
162.247.241.9:80
172.67.188.10:80
172.67.31.55:80
173.245.49.19:80
172.67.0.13:80
45.12.30.98:80
185.162.228.179:80
203.30.188.193:80
185.162.230.169:80
185.171.230.219:80
203.13.32.168:80
203.23.103.209:80
203.23.104.73:80
185.162.230.7:80
203.13.32.28:80
45.12.30.19:80
173.245.49.66:80
173.245.49.90:80
203.28.8.165:80
203.30.191.131:80
185.162.228.201:80
203.30.189.254:80
203.34.28.106:80
172.67.172.150:80
172.67.191.246:80
172.67.181.121:80
172.67.3.94:80
172.67.180.47:80
23.227.38.13:80
203.24.108.38:80
172.67.177.188:80
91.226.97.223:80
203.24.108.140:80
203.23.104.119:80
45.8.106.62:80
45.8.107.151:80
203.30.189.85:80
45.8.106.105:80
203.13.32.212:80
203.22.223.11:80
203.28.8.223:80
185.162.231.141:80
162.247.243.177:80
31.43.179.251:80
172.67.191.245:80
162.247.243.10:80
172.67.177.57:80
173.245.49.75:80
173.245.49.82:80
172.67.181.166:80
203.32.120.166:80
173.245.49.103:80
173.245.49.117:80
203.23.104.118:80
203.30.191.207:80
203.24.108.56:80
203.24.102.94:80
203.30.191.217:80
172.67.170.6:80
162.247.243.240:80
185.238.228.185:80
172.67.182.128:80
172.67.181.203:80
172.67.255.214:80
172.67.70.163:80
172.67.3.106:80
203.22.223.3:80
172.67.176.136:80
172.67.177.186:80
172.67.177.218:80
45.8.104.206:80
203.30.188.76:80
45.14.174.44:80
203.13.32.143:80
185.162.228.37:80
203.22.223.246:80
45.8.107.15:80
203.23.104.144:80
203.24.102.209:80
203.30.190.143:80
45.12.30.64:80
91.226.97.32:80
203.24.103.194:80
203.24.109.42:80
23.227.38.89:80
45.12.31.124:80
203.24.102.170:80
45.12.30.149:80
203.30.189.47:80
203.24.109.2:80
203.28.8.64:80
203.30.191.196:80
162.247.243.196:80
172.67.185.151:80
172.64.174.40:80
185.171.231.87:80
203.13.32.42:80
173.245.49.86:80
91.226.97.15:80
172.64.167.2:80
172.67.181.145:80
23.227.38.115:80
203.24.109.209:80
91.226.97.237:80
203.24.109.7:80
203.24.102.198:80
172.67.191.228:80
172.67.181.120:80
173.245.49.31:80
185.171.231.228:80
185.162.230.13:80
203.24.109.142:80
45.8.107.184:80
203.23.104.165:80
45.12.30.115:80
185.171.230.60:80
203.13.32.44:80
203.28.9.30:80
173.245.49.109:80
203.23.103.222:80
185.162.231.44:80
91.226.97.62:80
203.23.104.13:80
185.162.230.254:80
185.171.230.39:80
103.21.244.6:80
185.171.230.58:80
172.67.167.11:80
172.67.176.126:80
172.67.176.168:80
172.67.177.168:80
185.171.230.184:80
185.171.230.79:80
185.162.229.1:80
203.34.28.217:80
45.8.106.159:80
45.8.107.232:80
203.24.103.11:80
45.14.174.174:80
203.28.9.154:80
185.162.228.148:80
203.30.189.116:80
203.30.190.72:80
172.67.43.192:80
172.67.185.177:80
172.67.181.213:80
172.67.182.152:80
172.64.192.7:80
172.67.167.27:80
185.171.230.98:80
203.24.102.13:80
203.28.8.253:80
203.13.32.110:80
203.30.189.62:80
203.24.108.129:80
185.162.230.205:80
203.23.103.138:80
173.245.49.104:80
203.30.188.31:80
45.12.30.50:80
185.162.229.172:80
203.30.191.62:80
203.24.109.154:80
203.30.189.96:80
185.162.228.69:80
203.28.8.214:80
172.67.180.246:80
172.67.185.160:80
172.67.189.12:80
172.64.207.2:80
172.67.254.108:80
185.162.230.54:80
203.34.28.188:80
173.245.49.88:80
91.226.97.128:80
173.245.49.10:80
173.245.49.26:80
173.245.49.46:80
173.245.49.36:80
172.67.180.15:80
172.67.176.42:80
203.30.189.142:80
203.24.103.51:80
91.226.97.236:80
203.23.103.243:80
185.171.231.133:80
185.162.229.10:80
203.32.121.151:80
203.32.121.81:80
203.30.191.134:80
45.12.31.254:80
45.12.30.125:80
185.171.230.174:80
203.32.120.63:80
185.171.230.144:80
203.24.108.8:80
173.245.49.63:80
173.245.49.119:80
203.13.32.140:80
185.162.229.123:80
203.24.103.176:80
203.30.190.59:80
185.171.230.232:80
203.23.103.177:80
203.23.106.246:80
45.12.30.25:80
172.67.171.234:80
188.114.98.160:80
172.67.44.15:80
162.247.243.36:80
172.67.191.230:80
185.238.228.106:80
203.34.28.80:80
191.101.251.86:80
172.67.182.124:80
172.67.181.189:80
172.67.179.58:80
172.67.176.6:80
172.67.176.248:80
172.67.177.209:80
203.30.188.84:80
162.247.243.160:80
45.8.107.187:80
91.226.97.103:80
203.22.223.229:80
185.171.231.236:80
203.30.191.24:80
203.30.191.164:80
203.13.32.126:80
203.23.103.165:80
203.24.103.7:80
203.34.28.210:80
45.12.30.6:80
185.162.230.225:80
203.24.109.228:80
172.67.43.225:80
172.67.43.161:80
185.162.229.191:80
172.67.223.190:80
173.245.49.48:80
141.101.121.254:80
203.23.104.87:80
185.171.230.246:80
203.13.32.187:80
172.67.182.125:80
172.67.182.68:80
172.67.182.3:80
172.67.175.212:80
173.245.49.45:80
172.67.177.123:80
173.245.49.4:80
173.245.49.25:80
172.67.165.70:80
103.21.244.33:80
172.67.180.20:80
172.67.180.10:80
172.67.180.2:80
172.67.182.54:80
172.67.179.5:80
203.23.104.51:80
172.67.176.106:80
172.67.177.7:80
185.162.231.190:80
185.162.230.89:80
203.28.8.228:80
45.8.107.163:80
203.22.223.169:80
185.171.230.97:80
203.23.106.52:80
185.171.231.121:80
203.13.32.57:80
45.8.104.237:80
23.227.38.200:80
185.162.228.252:80
185.171.231.118:80
203.23.106.249:80
203.34.28.93:80
203.24.102.99:80
45.12.31.155:80
173.245.49.74:80
173.245.49.100:80
203.28.8.108:80
203.34.28.98:80
45.8.107.74:80
23.227.38.139:80
203.24.108.51:80
203.23.103.72:80
203.30.191.158:80
45.14.174.160:80
45.8.104.228:80
203.30.190.229:80
172.67.185.214:80
172.67.43.143:80
172.67.182.142:80
172.67.180.56:80
172.67.176.17:80
172.67.167.10:80
172.67.176.198:80
172.67.176.217:80
45.14.174.18:80
203.32.121.15:80
203.32.121.253:80
185.162.228.175:80
203.24.109.33:80
203.23.103.201:80
203.30.191.148:80
45.8.105.151:80
45.12.30.167:80
185.162.230.111:80
45.8.106.178:80
172.67.181.242:80
141.193.213.211:80
203.30.189.190:80
203.24.102.116:80
45.8.104.160:80
185.171.231.147:80
45.8.107.113:80
203.24.109.176:80
203.32.120.220:80
203.24.109.166:80
45.8.104.197:80
203.30.189.57:80
45.8.106.183:80
203.28.8.66:80
203.24.108.108:80
185.171.231.108:80
203.24.108.30:80
172.67.179.35:80
45.12.30.100:80
203.28.8.50:80
203.30.191.65:80
36.255.87.222:83
181.225.101.14:999
41.57.138.30:8080
203.24.108.165:80
203.22.223.43:80
172.67.185.187:80
172.67.182.34:80
172.67.181.28:80
173.245.49.102:80
172.67.180.33:80
172.67.254.44:80
172.67.176.2:80
172.67.167.172:80
172.67.177.58:80
172.67.177.208:80
45.12.30.54:80
203.30.191.44:80
185.162.231.175:80
203.24.109.196:80
203.32.121.27:80
45.12.30.229:80
203.28.8.144:80
203.23.104.46:80
45.14.174.56:80
173.245.49.111:80
203.34.28.134:80
185.171.230.145:80
172.67.179.233:80
172.67.171.211:80
172.67.130.4:80
172.67.179.208:80
172.67.43.104:80
172.67.191.249:80
185.238.228.154:80
172.64.138.2:80
172.67.180.14:80
185.171.230.238:80
172.67.177.154:80
203.24.108.210:80
203.32.120.179:80
203.32.120.30:80
185.171.230.216:80
45.12.30.246:80
203.30.191.219:80
91.226.97.211:80
185.162.230.215:80
45.14.174.86:80
203.22.223.253:80
173.245.49.107:80
203.28.9.86:80
45.8.104.135:80
203.32.121.201:80
203.24.109.106:80
185.162.231.33:80
203.30.188.159:80
203.24.108.145:80
172.67.254.150:80
172.67.180.18:80
172.67.176.44:80
172.67.176.135:80
172.67.176.236:80
172.67.177.131:80
45.12.30.154:80
45.8.107.147:80
203.30.189.247:80
203.24.109.32:80
203.28.9.83:80
203.34.28.1:80
185.162.230.1:80
203.24.102.20:80
203.23.106.163:80
45.14.174.42:80
203.32.120.111:80
203.34.28.20:80
203.32.121.181:80
203.30.191.251:80
172.67.181.247:80
172.67.192.41:80
172.67.48.160:80
172.67.240.170:80
172.67.165.43:80
203.32.121.241:80
203.28.8.19:80
203.24.103.57:80
203.22.223.77:80
203.30.190.163:80
203.34.28.6:80
185.162.231.220:80
203.32.121.5:80
45.8.104.49:80
203.23.104.20:80
203.30.189.22:80
185.162.228.28:80
203.23.106.179:80
203.24.102.156:80
188.114.98.153:80
172.67.182.71:80
172.67.181.199:80
172.67.254.134:80
172.67.255.59:80
172.67.180.14:80
172.67.167.58:80
172.67.176.55:80
172.67.177.204:80
91.226.97.175:80
91.226.97.154:80
203.23.106.159:80
23.227.38.205:80
203.23.103.43:80
203.24.103.126:80
203.23.106.150:80
185.171.231.200:80
203.32.120.58:80
181.209.77.250:999
172.67.192.46:80
172.67.191.227:80
172.67.182.98:80
172.67.180.51:80
191.101.251.33:80
185.162.229.208:80
185.171.230.142:80
45.8.107.239:80
185.162.228.169:80
203.30.190.133:80
203.30.188.98:80
203.24.109.97:80
203.24.108.137:80
185.162.231.72:80
45.12.30.236:80
185.162.230.80:80
203.30.188.234:80
203.24.109.173:80
172.67.170.18:80
172.67.255.249:80
185.238.228.118:80
172.64.154.2:80
172.67.182.1:80
172.67.181.112:80
172.67.181.180:80
172.67.182.53:80
172.67.181.146:80
172.64.200.15:80
172.67.180.30:80
172.67.180.25:80
172.67.180.19:80
45.8.104.159:80
45.8.105.51:80
203.13.32.23:80
45.12.31.226:80
203.30.190.174:80
23.227.38.224:80
203.30.189.10:80
203.30.188.148:80
203.24.109.94:80
203.23.106.253:80
185.162.228.151:80
172.67.192.48:80
141.193.213.94:80
185.238.228.84:80
172.64.148.2:80
131.196.191.251:9876
172.67.254.146:80
172.67.167.67:80
45.12.31.108:80
141.101.123.220:80
141.101.123.226:80
172.67.3.55:80
91.226.97.203:80
203.24.103.66:80
203.22.223.139:80
23.227.38.40:80
203.23.106.182:80
185.162.228.192:80
203.30.188.237:80
203.28.9.234:80
185.238.228.43:80
141.193.213.175:80
141.193.213.90:80
172.67.180.36:80
172.67.177.45:80
72.195.34.59:4145
172.67.181.219:80
172.67.3.78:80
172.67.180.60:80
203.24.109.187:80
203.24.103.101:80
203.30.188.41:80
185.171.230.183:80
203.28.8.28:80
203.28.8.147:80
203.30.189.172:80
45.12.31.3:80
203.32.121.30:80
203.30.191.161:80
45.12.30.62:80
45.8.106.155:80
203.32.120.68:80
45.8.107.16:80
203.22.223.251:80
31.43.179.147:80
191.101.251.91:80
172.67.182.149:80
172.67.181.177:80
172.67.253.207:80
172.67.176.170:80
172.67.176.216:80
203.30.188.185:80
45.8.106.135:80
172.67.165.43:80
172.67.181.68:80
172.67.181.98:80
173.245.49.5:80
173.245.49.17:80
172.67.177.56:80
203.28.9.81:80
203.24.103.240:80
203.30.191.114:80
45.12.31.250:80
172.67.187.243:80
188.114.98.160:80
173.245.49.30:80
172.67.254.133:80
173.245.49.34:80
172.67.21.175:80
203.23.106.147:80
203.34.28.103:80
203.34.28.83:80
203.32.121.70:80
203.24.109.71:80
45.12.30.122:80
203.24.108.234:80
185.162.231.134:80
45.14.174.60:80
203.24.103.228:80
203.23.104.53:80
185.171.230.103:80
203.30.191.56:80
162.247.243.201:80
172.67.188.20:80
141.193.213.1:80
172.67.176.138:80
45.14.174.197:80
203.30.188.180:80
91.226.97.45:80
185.162.230.114:80
203.13.32.6:80
172.67.172.178:80
172.67.185.168:80
45.14.174.35:80
45.12.31.7:80
172.67.182.145:80
203.23.104.110:80
108.61.160.17:80
172.67.182.139:80
190.93.245.26:80
172.67.254.160:80
203.13.32.64:80
203.32.121.244:80
203.28.8.115:80
172.67.182.32:80
172.67.181.123:80
203.30.189.46:80
172.67.14.3:80
172.67.70.101:80
172.64.142.76:80
172.67.35.115:80
141.101.123.219:80
172.67.0.14:80
45.131.5.133:80
103.21.244.27:80
203.24.102.197:80
203.34.28.175:80
203.32.120.83:80
203.24.108.189:80
45.8.105.229:80
203.24.108.241:80
185.171.231.6:80
203.24.103.44:80
185.238.228.188:80
172.64.128.159:80
172.67.181.36:80
172.67.181.181:80
172.67.182.134:80
172.67.181.160:80
172.67.182.16:80
172.67.182.119:80
172.67.182.132:80
172.67.181.201:80
172.67.181.222:80
172.67.254.143:80
172.67.222.230:80
172.67.180.12:80
203.23.104.220:80
45.8.104.195:80
185.171.230.203:80
203.30.190.145:80
203.28.9.132:80
185.162.231.75:80
172.67.187.244:80
172.67.181.230:80
172.67.138.107:80
172.67.85.150:80
172.67.80.190:80
203.23.104.222:80
203.30.189.121:80
203.28.8.222:80
185.162.228.117:80
203.24.102.250:80
200.16.208.187:8080
203.23.103.47:80
172.67.182.48:80
172.67.182.29:80
172.67.182.116:80
172.67.162.212:80
172.67.181.216:80
172.67.181.218:80
173.245.49.9:80
173.245.49.15:80
173.245.49.23:80
172.67.163.71:80
91.226.97.231:80
185.171.231.91:80
185.171.230.155:80
172.67.182.30:80
172.64.164.2:80
172.67.26.82:80
23.227.38.15:80
172.67.181.190:80
203.34.28.190:80
45.8.105.161:80
203.24.102.50:80
173.245.49.76:80
173.245.49.89:80
173.245.49.101:80
203.32.121.237:80
203.23.103.109:80
172.67.188.6:80
188.114.98.160:80
172.67.182.78:80
172.67.182.169:80
172.67.182.120:80
172.67.181.118:80
172.67.181.23:80
141.101.123.21:80
172.67.181.147:80
172.67.181.144:80
172.67.182.127:80
172.67.219.60:80
172.67.221.168:80
172.67.0.11:80
172.67.254.147:80
172.67.253.233:80
172.67.253.69:80
185.162.231.42:80
203.30.191.232:80
45.12.31.5:80
203.28.8.154:80
45.8.104.91:80
203.30.188.209:80
203.30.188.52:80
185.162.230.207:80
203.30.191.180:80
45.8.107.20:80
203.23.103.229:80
172.67.187.229:80
188.114.98.160:80
188.114.99.160:80
188.114.98.160:80
172.64.155.2:80
188.114.99.160:80
172.67.182.161:80
172.67.182.19:80
172.67.181.172:80
172.67.181.208:80
172.67.0.6:80
172.67.177.61:80
45.8.107.206:80
185.162.230.129:80
45.12.30.192:80
203.24.103.239:80
45.12.30.73:80
203.32.120.151:80
45.14.174.89:80
203.24.102.141:80
203.24.103.178:80
172.67.212.157:80
45.8.105.170:80
172.67.165.43:80
172.67.181.116:80
172.67.181.2:80
172.67.182.96:80
172.67.182.17:80
172.67.181.170:80
172.67.181.155:80
172.67.182.6:80
172.67.68.216:80
172.67.181.212:80
173.245.49.8:80
172.67.26.132:80
172.67.33.192:80
141.101.123.212:80
172.67.254.148:80
172.67.255.222:80
172.67.3.149:80
172.67.218.212:80
185.171.230.192:80
203.32.121.164:80
203.24.108.22:80
203.28.8.123:80
203.28.9.97:80
203.30.189.182:80
203.32.121.212:80
203.32.120.141:80
203.22.223.113:80
185.162.231.5:80
203.23.106.237:80
172.67.165.11:80
184.178.172.5:15303
172.67.182.4:80
203.23.104.64:80
45.8.104.122:80
173.245.49.83:80
203.28.8.201:80
203.23.103.32:80
203.23.106.78:80
104.254.140.0:80
172.67.191.235:80
172.64.203.2:80
172.67.182.140:80
172.67.181.122:80
172.67.208.171:80
172.67.181.179:80
172.67.254.136:80
173.245.49.108:80
23.227.38.252:80
172.67.182.165:80
185.162.230.103:80
203.32.120.84:80
185.162.228.150:80
203.24.103.50:80
203.24.108.152:80
203.28.9.186:80
203.13.32.76:80
185.171.230.156:80
172.67.182.21:80
162.247.243.38:80
172.67.8.157:80
172.67.181.97:80
190.93.247.25:80
172.67.181.221:80
141.101.123.221:80
203.30.189.196:80
185.171.230.254:80
203.30.190.12:80
203.34.28.0:80
203.32.121.75:80
185.162.229.112:80
191.101.251.151:80
141.193.213.160:80
172.67.181.142:80
172.67.223.81:80
141.101.123.230:80
172.67.176.77:80
172.67.177.172:80
203.24.109.78:80
203.23.103.215:80
203.34.28.39:80
172.67.170.20:80
172.67.185.191:80
141.101.115.249:80
188.114.97.12:80
172.67.181.94:80
172.67.181.87:80
172.67.181.150:80
172.67.181.188:80
173.245.49.22:80
173.245.49.38:80
172.67.181.117:80
172.67.177.1:80
203.32.120.235:80
23.227.38.202:80
45.12.30.165:80
185.162.229.134:80
45.8.107.30:80
203.23.106.227:80
203.30.189.128:80
203.22.223.237:80
185.171.230.122:80
45.12.30.184:80
203.24.103.21:80
203.23.104.235:80
203.30.190.125:80
203.28.9.209:80
203.24.109.30:80
45.12.30.133:80
203.30.188.29:80
172.67.193.136:80
172.67.171.225:80
191.101.251.14:80
172.67.180.234:80
141.193.213.76:80
172.67.181.254:80
172.67.192.26:80
172.67.75.173:80
188.114.98.160:80
162.247.243.84:80
172.64.149.27:80
172.67.74.107:80
173.245.49.14:80
203.23.106.43:80
185.171.231.103:80
185.171.230.91:80
172.67.75.151:80
141.193.213.100:80
172.67.181.164:80
172.67.181.76:80
203.30.191.54:80
203.23.106.98:80
203.24.103.191:80
203.34.28.234:80
91.226.97.245:80
91.226.97.166:80
45.8.105.160:80
203.30.188.130:80
203.24.109.65:80
185.171.230.6:80
203.30.190.147:80
203.30.191.26:80
203.34.28.54:80
203.30.190.165:80
45.8.106.145:80
203.24.108.17:80
203.30.191.239:80
203.30.189.118:80
203.32.121.47:80
203.30.188.44:80
203.32.121.149:80
203.24.108.236:80
185.171.230.205:80
172.67.213.134:80
162.247.243.149:80
172.67.157.153:80
195.2.71.201:16072
172.67.180.251:80
172.67.0.36:80
172.67.185.169:80
172.67.185.193:80
172.67.181.224:80
191.101.251.150:80
141.193.213.14:80
188.114.99.160:80
185.171.231.179:80
172.67.181.74:80
172.67.181.14:80
172.67.181.21:80
172.67.182.113:80
172.67.181.110:80
172.67.182.153:80
172.67.139.99:80
172.67.182.111:80
185.162.231.106:80
172.67.181.184:80
172.67.181.191:80
203.24.102.190:80
172.67.254.62:80
103.21.244.2:80
172.67.180.58:80
172.67.167.91:80
185.171.230.124:80
203.30.188.77:80
185.162.231.252:80
203.30.190.182:80
203.24.103.192:80
45.12.30.13:80
45.12.31.146:80
23.227.38.46:80
203.13.32.113:80
203.24.109.182:80
203.23.104.0:80
185.162.228.104:80
185.171.231.136:80
45.12.30.254:80
203.34.28.37:80
45.12.31.128:80
203.30.191.248:80
203.30.188.69:80
203.32.120.230:80
203.32.121.32:80
203.23.104.254:80
203.30.191.162:80
45.8.104.176:80
45.8.107.247:80
45.12.31.60:80
203.28.8.25:80
172.67.43.140:80
141.193.213.26:80
141.193.213.239:80
191.101.251.90:80
190.93.245.2:80
172.67.34.6:80
23.227.38.116:80
203.28.8.134:80
203.34.28.128:80
203.24.102.6:80
203.24.108.159:80
45.14.174.233:80
45.8.105.253:80
203.30.189.111:80
203.23.104.56:80
185.162.231.192:80
203.24.108.242:80
203.24.108.41:80
203.30.189.66:80
203.28.8.98:80
45.12.31.12:80
203.30.189.131:80
203.30.189.156:80
185.162.231.85:80
45.8.104.156:80
172.67.172.149:80
141.193.213.52:80
188.114.99.160:80
172.67.182.38:80
172.67.182.23:80
172.67.178.110:80
141.101.122.238:80
172.67.167.1:80
172.67.167.160:80
203.30.188.86:80
45.8.104.238:80
185.162.231.244:80
203.30.190.227:80
45.8.105.243:80
45.14.174.20:80
185.162.230.250:80
45.14.174.13:80
45.14.174.41:80
203.24.109.195:80
172.67.75.194:80
141.193.213.189:80
172.67.188.22:80
172.67.9.162:80
203.24.103.159:80
203.22.223.117:80
203.30.191.63:80
203.23.104.27:80
141.193.213.167:80
172.67.185.149:80
172.67.176.19:80
172.67.176.22:80
185.171.231.39:80
91.226.97.194:80
172.67.182.88:80
172.67.176.15:80
45.8.105.136:80
185.171.231.104:80
203.32.121.39:80
203.23.104.89:80
203.23.103.3:80
203.28.8.238:80
203.24.108.204:80
45.14.174.203:80
91.226.97.93:80
203.24.102.246:80
203.30.188.188:80
203.28.9.141:80
185.171.230.95:80
203.32.120.94:80
31.43.179.137:80
172.67.75.182:80
141.193.213.127:80
172.67.81.185:80
191.101.251.19:80
172.67.174.90:80
172.67.181.193:80
172.67.209.253:80
172.67.254.153:80
172.67.3.76:80
172.67.176.13:80
185.162.230.87:80
172.67.176.152:80
185.162.229.251:80
185.171.231.234:80
185.171.231.17:80
203.32.120.202:80
45.8.104.48:80
203.24.103.29:80
45.12.30.220:80
203.30.188.49:80
203.24.103.98:80
91.226.97.172:80
185.171.230.11:80
203.30.190.81:80
203.23.104.218:80
45.8.105.117:80
45.14.174.248:80
185.238.228.96:80
185.238.228.88:80
191.101.251.130:80
172.67.75.193:80
172.64.80.165:80
162.247.243.49:80
31.43.179.217:80
141.193.213.155:80
172.67.75.164:80
191.101.251.118:80
172.67.70.176:80
45.8.104.28:80
172.67.176.90:80
185.171.230.157:80
203.23.104.7:80
185.162.231.98:80
45.8.105.7:80
203.28.9.224:80
203.28.8.230:80
45.14.174.168:80
203.24.109.227:80
203.28.9.138:80
91.226.97.247:80
185.171.231.216:80
203.13.32.56:80
45.14.174.178:80
185.162.230.90:80
185.171.230.201:80
203.30.191.238:80
185.162.230.82:80
203.24.109.139:80
45.8.105.238:80
45.14.174.239:80
185.171.231.102:80
203.24.109.179:80
203.30.188.226:80
185.171.230.20:80
185.171.230.55:80
185.162.229.73:80
203.23.106.164:80
141.193.213.66:80
141.193.213.221:80
172.67.75.177:80
162.247.243.92:80
191.101.251.54:80
172.67.192.45:80
185.238.228.143:80
141.193.213.149:80
141.101.115.253:80
172.67.176.187:80
172.67.254.14:80
172.67.3.127:80
203.23.106.92:80
45.12.31.145:80
203.23.106.133:80
203.30.190.238:80
45.8.107.21:80
45.14.174.5:80
203.23.104.39:80
45.8.106.22:80
203.28.8.252:80
185.162.228.56:80
203.24.102.174:80
203.23.103.63:80
45.12.30.86:80
45.8.104.99:80
45.8.105.57:80
185.171.230.8:80
203.23.104.253:80
23.227.38.76:80
185.171.230.85:80
203.28.8.58:80
31.43.179.132:80
172.67.171.229:80
172.67.170.15:80
162.247.243.114:80
172.67.172.160:80
162.247.243.129:80
185.238.228.37:80
172.64.170.227:80
172.67.182.146:80
172.67.182.28:80
172.67.70.187:80
172.67.153.60:80
162.247.243.147:80
172.67.181.0:80
185.171.231.151:80
203.22.223.252:80
172.67.167.180:80
172.67.176.228:80
172.67.177.252:80
45.12.30.44:80
45.8.104.164:80
203.30.191.98:80
203.30.191.52:80
45.8.107.253:80
185.171.230.40:80
45.12.30.255:80
203.30.190.231:80
203.32.120.186:80
45.12.31.217:80
203.24.102.200:80
185.162.231.172:80
141.193.213.44:80
172.67.43.162:80
185.238.228.179:80
188.114.97.201:80
188.114.98.160:80
172.67.181.168:80
172.67.181.69:80
172.67.254.142:80
172.67.70.237:80
185.171.230.151:80
172.67.176.186:80
172.67.177.196:80
45.8.107.57:80
45.12.31.66:80
45.8.106.190:80
45.14.174.253:80
203.30.191.111:80
45.12.31.201:80
45.8.105.0:80
203.23.103.245:80
185.162.229.182:80
203.30.188.110:80
203.30.188.70:80
185.162.231.247:80
45.8.104.5:80
91.226.97.81:80
203.24.109.112:80
172.67.179.195:80
172.67.44.12:80
172.64.128.31:80
203.32.121.186:80
103.21.244.10:80
185.171.230.125:80
203.32.120.119:80
45.12.31.220:80
203.24.109.1:80
45.8.106.152:80
45.8.104.158:80
185.171.231.125:80
203.23.103.15:80
203.28.8.13:80
45.12.31.251:80
203.24.102.14:80
162.247.243.131:80
172.67.192.61:80
203.30.190.131:80
185.171.230.127:80
45.14.174.216:80
141.193.213.153:80
172.67.181.57:80
172.67.181.187:80
185.162.229.8:80
203.34.28.141:80
203.28.8.29:80
45.8.104.86:80
45.8.106.121:80
203.22.223.16:80
203.23.104.33:80
185.162.230.105:80
45.8.105.115:80
203.30.191.216:80
203.32.120.27:80
203.23.104.112:80
203.30.190.214:80
203.28.9.124:80
45.8.104.188:80
203.24.109.76:80
45.8.107.193:80
203.23.103.7:80
45.8.105.186:80
203.23.106.160:80
203.30.190.36:80
45.8.106.50:80
203.28.8.229:80
45.8.104.110:80
45.8.106.230:80
203.24.102.220:80
203.30.191.231:80
203.30.190.42:80
203.32.120.153:80
45.8.107.90:80
185.171.231.131:80
203.24.109.152:80
203.23.106.35:80
172.67.171.217:80
172.67.171.233:80
162.247.243.150:80
172.67.170.17:80
192.200.160.0:80
172.67.43.134:80
172.67.192.60:80
188.114.96.249:80
172.67.136.110:80
172.67.182.94:80
172.67.254.127:80
172.67.68.208:80
203.32.120.205:80
91.226.97.198:80
45.8.107.14:80
45.8.105.84:80
185.162.228.74:80
203.30.188.8:80
203.23.106.211:80
203.23.103.81:80
203.28.9.122:80
203.24.102.55:80
185.162.228.212:80
203.23.106.144:80
203.24.109.138:80
172.67.170.31:80
188.114.98.137:80
172.67.172.166:80
172.67.180.253:80
141.193.213.216:80
172.67.187.251:80
172.67.254.154:80
172.67.134.123:80
172.67.167.120:80
172.67.176.223:80
45.8.104.201:80
185.162.231.48:80
203.13.32.206:80
45.8.107.106:80
45.8.105.122:80
203.23.106.196:80
203.30.190.160:80
45.8.105.79:80
172.67.171.207:80
172.67.172.167:80
203.30.190.102:80
203.13.32.218:80
203.32.120.203:80
203.30.189.154:80
203.30.188.255:80
45.12.31.115:80
203.24.102.122:80
203.28.9.201:80
203.30.189.155:80
31.43.179.41:80
162.247.243.1:80
141.193.213.75:80
191.101.251.67:80
172.67.0.10:80
172.67.177.237:80
203.22.223.78:80
45.8.107.139:80
203.28.8.185:80
45.8.107.155:80
45.8.106.0:80
203.34.28.193:80
203.23.104.31:80
203.28.8.83:80
91.226.97.238:80
203.24.109.253:80
203.23.103.161:80
45.8.107.50:80
45.8.105.53:80
203.24.108.196:80
23.227.38.151:80
203.23.106.76:80
203.24.108.58:80
203.30.188.113:80
45.8.107.130:80
172.67.172.157:80
172.67.192.32:80
185.238.228.104:80
191.101.251.26:80
203.23.104.38:80
172.67.255.21:80
203.30.189.177:80
172.67.171.209:80
172.67.170.2:80
172.67.170.25:80
103.21.244.20:80
203.32.121.205:80
172.67.167.7:80
172.67.167.54:80
172.67.167.237:80
45.12.30.221:80
203.24.108.72:80
203.28.8.110:80
45.8.107.175:80
203.28.9.48:80
203.28.8.124:80
203.28.8.60:80
203.30.191.214:80
45.8.104.50:80
91.226.97.66:80
45.12.31.101:80
185.171.231.122:80
185.162.229.204:80
45.8.107.140:80
203.30.188.190:80
203.23.104.88:80
203.23.106.149:80
45.14.174.71:80
185.162.229.221:80
203.32.121.31:80
203.23.103.38:80
203.32.121.7:80
203.28.9.248:80
91.226.97.27:80
203.23.103.227:80
203.30.190.115:80
185.162.230.155:80
203.24.108.29:80
203.22.223.232:80
203.23.106.214:80
185.162.229.53:80
172.67.164.239:80
31.43.179.36:80
191.101.251.225:80
185.238.228.237:80
172.67.43.217:80
185.238.228.136:80
172.67.3.97:80
172.67.167.204:80
185.162.230.181:80
203.13.32.118:80
203.32.121.106:80
45.8.107.1:80
203.23.104.98:80
203.22.223.32:80
203.23.103.173:80
203.13.32.60:80
185.171.231.238:80
45.12.31.194:80
203.13.32.142:80
185.171.231.113:80
185.162.229.121:80
91.226.97.56:80
203.30.190.50:80
203.28.9.100:80
31.43.179.13:80
172.67.171.224:80
185.238.228.241:80
203.23.106.11:80
172.67.180.209:80
169.57.1.85:8123
172.67.176.23:80
203.32.120.97:80
203.30.191.104:80
45.12.30.38:80
203.23.106.158:80
45.12.31.130:80
45.8.104.81:80
203.24.103.144:80
45.14.174.93:80
185.162.229.246:80
185.162.231.114:80
203.24.102.234:80
91.226.97.168:80
172.67.193.247:80
172.67.171.228:80
141.193.213.141:80
203.32.121.204:80
45.12.30.22:80
185.171.231.130:80
185.162.231.105:80
45.8.104.85:80
203.32.120.197:80
45.14.174.153:80
45.8.104.241:80
203.30.190.87:80
203.28.8.125:80
185.171.230.252:80
45.12.31.199:80
185.171.231.194:80
185.238.228.40:80
31.43.179.46:80
191.101.251.206:80
191.101.251.233:80
172.67.167.158:80
203.24.108.42:80
203.30.188.117:80
203.23.103.46:80
203.24.108.255:80
203.28.8.105:80
203.34.28.131:80
185.162.230.74:80
23.227.38.229:80
45.14.174.130:80
45.8.107.224:80
203.23.106.112:80
185.171.231.25:80
203.30.190.199:80
185.238.228.114:80
172.67.172.145:80
172.67.187.239:80
172.67.38.86:80
172.64.155.170:80
23.227.38.98:80
185.162.228.230:80
185.162.229.145:80
203.24.103.135:80
203.28.8.9:80
203.22.223.247:80
185.162.228.196:80
45.14.174.12:80
185.162.230.34:80
203.30.188.137:80
185.162.229.115:80
203.30.189.43:80
45.12.30.119:80
45.12.30.4:80
185.162.229.66:80
203.30.189.243:80
172.67.171.189:80
141.193.213.21:80
141.193.213.218:80
185.238.228.94:80
172.64.197.2:80
203.29.53.199:80
203.24.109.25:80
172.67.167.5:80
185.162.230.117:80
45.12.30.218:80
45.8.104.243:80
203.23.103.64:80
45.12.30.201:80
45.12.30.63:80
45.8.104.236:80
203.28.9.254:80
203.34.28.71:80
203.30.189.237:80
203.22.223.213:80
203.24.109.241:80
23.227.38.133:80
185.162.229.146:80
203.23.104.150:80
203.23.103.196:80
203.30.190.217:80
45.12.30.233:80
203.22.223.143:80
45.8.107.143:80
172.67.170.21:80
172.67.172.177:80
141.193.213.247:80
185.171.230.194:80
45.12.30.17:80
203.23.103.160:80
203.23.104.251:80
203.28.8.14:80
23.227.38.197:80
162.247.243.127:80
185.238.228.59:80
203.34.28.58:80
172.67.167.236:80
45.12.30.81:80
185.171.230.59:80
185.162.228.159:80
203.30.189.72:80
45.8.104.179:80
185.162.229.241:80
45.14.174.45:80
203.30.188.246:80
203.24.109.136:80
203.24.102.144:80
203.24.102.225:80
172.67.171.218:80
172.67.185.192:80
172.67.192.24:80
172.67.192.31:80
172.67.192.37:80
172.67.192.38:80
185.238.228.183:80
103.21.244.13:80
172.67.3.91:80
203.23.103.157:80
203.28.9.44:80
203.30.191.218:80
203.28.9.233:80
45.8.107.217:80
203.30.191.105:80
203.32.121.93:80
203.30.190.57:80
185.162.231.121:80
203.34.28.91:80
45.8.107.24:80
45.12.30.70:80
203.23.103.212:80
203.23.104.85:80
203.32.120.146:80
203.23.103.41:80
203.32.121.67:80
203.32.120.252:80
203.23.104.17:80
203.30.188.126:80
203.32.120.216:80
203.28.8.177:80
203.30.191.58:80
203.24.102.15:80
203.32.121.42:80
203.24.102.211:80
203.32.120.29:80
91.226.97.163:80
45.8.106.182:80
203.24.108.239:80
203.23.103.33:80
203.32.121.36:80
203.23.106.136:80
31.43.179.87:80
31.43.179.176:80
191.101.251.223:80
185.238.228.218:80
162.247.243.182:80
185.238.228.240:80
172.67.182.121:80
172.67.177.229:80
45.12.31.149:80
45.8.106.171:80
45.12.30.199:80
203.23.104.205:80
203.23.106.135:80
185.162.228.229:80
203.30.191.202:80
203.23.103.19:80
185.162.230.67:80
203.24.102.212:80
203.30.191.156:80
185.162.230.33:80
45.8.107.222:80
203.24.102.124:80
31.43.179.94:80
172.67.171.198:80
172.67.192.35:80
185.238.228.182:80
185.238.228.120:80
172.64.174.2:80
203.23.103.252:80
45.8.104.139:80
203.30.190.94:80
91.226.97.79:80
45.8.107.152:80
203.32.121.147:80
45.12.30.217:80
31.43.179.86:80
172.64.198.2:80
102.38.17.121:8080
172.67.181.32:80
203.23.103.164:80
45.8.105.42:80
203.22.223.30:80
203.28.9.145:80
203.28.8.88:80
45.12.31.93:80
203.30.190.201:80
203.30.191.66:80
203.22.223.70:80
172.67.22.22:80
203.24.109.163:80
203.30.191.1:80
162.247.243.81:80
172.67.43.247:80
172.67.213.75:80
141.101.123.4:80
45.14.174.159:80
91.226.97.87:80
203.23.106.40:80
45.8.106.250:80
203.30.188.119:80
203.30.189.158:80
23.227.38.147:80
45.8.106.40:80
45.8.104.32:80
23.227.38.31:80
203.30.190.187:80
185.162.231.21:80
203.34.28.198:80
185.162.230.20:80
23.227.38.241:80
185.162.229.98:80
203.30.191.245:80
203.24.103.74:80
185.162.228.79:80
45.12.30.111:80
203.23.104.125:80
203.32.120.198:80
203.22.223.26:80
203.24.108.218:80
91.226.97.28:80
172.67.75.166:80
188.114.98.160:80
188.114.97.13:80
172.67.182.31:80
172.67.167.144:80
45.8.107.131:80
185.162.230.18:80
203.24.102.4:80
185.162.230.130:80
185.162.231.63:80
203.30.188.88:80
203.30.191.169:80
45.8.106.2:80
203.30.190.88:80
203.32.120.190:80
185.162.229.6:80
203.23.106.4:80
185.162.229.164:80
203.22.223.84:80
141.193.213.233:80
141.193.213.156:80
185.238.228.70:80
141.101.113.24:80
195.245.221.37:80
172.67.167.98:80
172.67.167.213:80
45.8.105.174:80
203.30.189.143:80
185.171.230.160:80
23.227.38.180:80
185.162.230.2:80
45.8.106.153:80
203.24.103.88:80
45.8.105.50:80
203.13.32.198:80
203.32.120.184:80
203.23.106.251:80
45.8.104.203:80
203.23.104.176:80
203.28.9.137:80
45.8.106.91:80
203.22.223.218:80
203.24.109.189:80
203.24.103.85:80
203.32.120.43:80
203.28.8.97:80
31.43.179.175:80
141.193.213.244:80
172.67.43.93:80
185.238.228.170:80
172.67.231.235:80
172.67.182.43:80
172.67.0.1:80
203.28.9.230:80
172.67.167.6:80
172.67.167.32:80
172.67.167.42:80
172.67.176.247:80
45.8.104.129:80
203.32.120.175:80
203.30.191.21:80
203.30.188.106:80
185.162.228.234:80
203.30.190.244:80
45.12.31.63:80
45.8.104.137:80
203.24.102.208:80
203.24.103.155:80
185.171.231.44:80
45.8.104.12:80
185.162.229.233:80
45.8.105.108:80
203.24.102.248:80
203.24.102.107:80
203.30.190.138:80
91.226.97.135:80
45.8.106.51:80
203.24.108.67:80
203.30.190.123:80
45.14.174.26:80
172.67.170.9:80
172.67.172.172:80
172.67.43.166:80
172.67.192.12:80
162.247.243.76:80
172.67.3.132:80
203.24.108.195:80
203.24.102.184:80
185.171.231.80:80
185.162.230.176:80
203.13.32.29:80
45.8.105.139:80
91.226.97.215:80
23.227.38.131:80
203.24.102.77:80
203.23.106.7:80
203.34.28.21:80
45.8.106.251:80
203.30.188.142:80
191.101.251.64:80
172.67.170.16:80
172.67.181.200:80
172.67.181.207:80
172.67.150.253:80
203.22.223.96:80
45.12.30.35:80
203.32.120.13:80
203.30.190.51:80
203.23.104.92:80
203.34.28.11:80
203.24.102.106:80
185.171.230.105:80
203.28.8.122:80
203.13.32.91:80
203.24.109.41:80
203.30.190.167:80
203.30.191.18:80
203.24.102.84:80
185.171.230.18:80
203.30.189.88:80
45.14.174.231:80
185.171.231.13:80
203.34.28.99:80
203.30.191.9:80
45.14.174.166:80
203.30.190.13:80
172.67.170.23:80
45.12.31.235:80
203.28.8.61:80
203.23.104.177:80
203.30.189.20:80
203.23.106.21:80
45.12.31.119:80
45.12.30.144:80
23.227.38.34:80
45.12.30.59:80
203.28.8.133:80
203.28.9.118:80
203.30.190.76:80
91.226.97.252:80
203.30.188.87:80
185.171.230.179:80
203.23.106.91:80
203.32.120.253:80
203.30.190.253:80
203.24.108.0:80
91.226.97.220:80
91.226.97.13:80
172.67.182.64:80
172.67.162.127:80
172.67.0.4:80
23.227.38.141:80
185.162.228.36:80
45.8.106.9:80
203.23.106.14:80
203.13.32.54:80
185.162.231.80:80
185.162.229.156:80
185.162.228.185:80
45.14.174.65:80
91.226.97.192:80
185.162.228.172:80
203.23.104.49:80
203.24.109.58:80
185.238.228.48:80
188.114.98.94:80
172.67.165.171:80
172.67.10.90:80
141.101.123.225:80
172.67.3.153:80
172.67.167.89:80
172.67.176.218:80
45.8.104.173:80
203.22.223.87:80
203.32.120.91:80
185.162.230.131:80
162.247.243.23:80
162.247.243.244:80
172.67.172.162:80
172.67.180.226:80
172.67.185.164:80
172.67.192.5:80
172.67.43.16:80
172.67.182.62:80
172.67.70.224:80
172.64.68.92:80
172.67.167.50:80
203.24.103.122:80
203.24.109.226:80
45.14.174.163:80
203.28.8.31:80
45.12.30.96:80
91.226.97.36:80
185.171.230.222:80
203.28.9.125:80
203.13.32.99:80
203.23.106.60:80
203.23.103.185:80
185.171.231.134:80
45.8.106.139:80
45.8.106.56:80
185.162.228.228:80
45.8.105.31:80
203.28.8.192:80
172.67.179.191:80
172.67.43.86:80
172.67.43.88:80
141.193.213.68:80
185.238.228.161:80
188.114.98.27:80
172.67.182.115:80
172.67.199.44:80
172.67.194.251:80
162.247.243.146:80
172.67.177.233:80
203.30.188.32:80
45.14.174.246:80
203.28.9.144:80
203.32.120.40:80
45.12.31.234:80
203.34.28.19:80
23.227.38.162:80
203.28.9.190:80
185.162.230.238:80
185.171.230.3:80
185.171.230.167:80
45.12.31.42:80
45.8.107.55:80
185.162.228.217:80
185.171.231.220:80
203.22.223.221:80
203.30.189.7:80
45.8.104.117:80
45.8.106.48:80
23.227.38.136:80
45.12.30.33:80
203.13.32.89:80
203.28.8.81:80
203.32.121.79:80
31.43.179.18:80
188.114.96.233:80
172.67.181.22:80
63.141.128.0:80
172.67.172.158:80
172.67.179.210:80
45.14.174.230:80
172.67.188.19:80
172.67.182.24:80
191.101.251.101:80
191.101.251.241:80
190.92.67.210:999
203.32.120.218:80
203.23.103.191:80
203.24.109.244:80
172.67.172.142:80
183.239.55.65:9091
172.67.70.88:80
190.93.244.35:80
45.14.174.183:80
203.32.121.148:80
203.30.190.49:80
203.22.223.23:80
45.8.106.8:80
203.30.188.85:80
172.67.3.61:80
203.23.106.213:80
203.30.188.245:80
91.226.97.92:80
203.32.121.132:80
45.12.30.89:80
203.30.189.13:80
203.24.103.113:80
203.13.32.150:80
203.24.103.48:80
45.12.31.172:80
203.32.121.76:80
203.23.103.129:80
185.171.231.181:80
45.8.105.86:80
188.114.96.0:80
45.8.106.166:80
203.32.120.161:80
185.162.230.143:80
203.24.102.36:80
45.12.31.43:80
203.30.191.133:80
203.24.109.68:80
203.24.109.107:80
23.227.38.35:80
203.28.9.229:80
45.12.31.102:80
162.247.243.247:80
141.193.213.4:80
172.67.182.0:80
172.67.167.46:80
203.30.191.237:80
203.30.188.96:80
45.8.105.183:80
203.24.109.202:80
203.23.104.113:80
185.171.230.171:80
45.8.106.224:80
91.226.97.29:80
172.67.170.8:80
172.67.36.196:80
203.32.121.59:80
203.28.8.47:80
185.162.229.129:80
203.13.32.209:80
185.171.230.243:80
45.14.174.198:80
45.12.30.219:80
185.162.230.168:80
203.22.223.241:80
45.8.104.23:80
23.227.38.100:80
45.8.107.37:80
203.22.223.69:80
45.12.31.120:80
203.32.120.6:80
185.162.230.102:80
203.30.190.111:80
45.8.105.107:80
203.32.120.86:80
185.162.230.222:80
185.162.230.135:80
31.43.179.203:80
172.67.179.190:80
172.67.0.28:80
185.238.228.97:80
141.193.213.220:80
172.64.130.2:80
172.67.181.35:80
172.67.177.216:80
203.30.189.153:80
203.24.103.212:80
172.64.140.11:80
172.67.255.219:80
141.101.123.16:80
172.67.177.219:80
45.8.107.45:80
203.24.108.182:80
203.34.28.43:80
203.32.120.120:80
203.30.190.185:80
203.30.190.194:80
185.162.230.206:80
45.8.104.174:80
185.171.230.190:80
203.24.103.128:80
203.23.106.65:80
203.30.191.94:80
203.30.189.112:80
185.162.229.138:80
185.162.229.4:80
203.30.190.250:80
203.30.190.34:80
185.162.229.226:80
45.8.105.46:80
203.30.189.97:80
203.24.102.114:80
203.24.109.205:80
203.30.191.121:80
203.24.108.209:80
141.193.213.2:80
172.67.179.169:80
141.193.213.129:80
191.101.251.94:80
172.64.165.2:80
185.171.231.235:80
203.23.106.218:80
185.162.230.94:80
45.8.106.180:80
45.12.31.69:80
185.171.230.159:80
23.227.38.140:80
185.162.231.249:80
203.30.189.74:80
203.28.8.22:80
203.32.120.46:80
203.24.103.165:80
185.171.231.42:80
172.67.43.202:80
191.101.251.228:80
172.67.181.10:80
45.12.30.214:80
185.162.228.27:80
45.14.174.8:80
203.24.102.28:80
203.22.223.188:80
203.13.32.97:80
203.34.28.249:80
45.12.30.228:80
203.30.189.55:80
203.28.8.216:80
45.12.30.172:80
203.32.120.77:80
203.23.103.68:80
185.171.231.184:80
45.8.106.181:80
45.8.105.116:80
172.67.160.226:80
172.67.171.200:80
172.67.170.4:80
172.67.172.170:80
172.67.172.174:80
172.67.165.44:80
141.101.123.5:80
203.28.8.126:80
203.32.121.102:80
45.8.105.106:80
203.30.188.170:80
45.12.31.62:80
203.23.103.28:80
45.12.30.241:80
185.162.229.84:80
45.14.174.182:80
45.8.106.26:80
203.30.190.0:80
91.226.97.50:80
185.162.230.27:80
45.12.31.137:80
203.13.32.53:80
203.34.28.214:80
203.13.32.132:80
172.67.75.200:80
191.101.251.53:80
191.101.251.216:80
172.67.72.189:80
172.67.23.197:80
172.67.167.250:80
203.30.188.241:80
203.32.121.37:80
203.32.121.85:80
203.30.191.190:80
45.8.106.210:80
203.24.108.55:80
203.28.8.204:80
91.226.97.42:80
45.14.174.195:80
185.162.228.109:80
203.24.103.175:80
185.162.229.23:80
203.13.32.102:80
91.226.97.218:80
45.12.30.207:80
45.12.30.136:80
45.12.31.40:80
203.30.190.85:80
203.32.121.73:80
185.162.230.97:80
203.32.121.87:80
203.22.223.31:80
172.67.43.81:80
172.67.167.138:80
203.30.189.245:80
203.30.190.15:80
203.30.191.221:80
203.24.103.75:80
185.162.229.56:80
203.30.188.99:80
185.171.231.186:80
45.8.107.200:80
45.12.30.11:80
203.28.9.227:80
45.8.105.44:80
185.162.229.187:80
45.12.31.143:80
23.227.38.204:80
203.24.102.112:80
45.8.107.83:80
203.23.104.62:80
203.24.102.23:80
185.162.230.85:80
203.24.109.230:80
203.22.223.90:80
23.227.38.178:80
203.24.109.48:80
203.34.28.113:80
185.238.228.149:80
203.30.191.128:80
172.67.75.56:80
172.64.146.2:80
203.30.188.123:80
172.67.167.117:80
203.23.103.208:80
45.12.30.188:80
45.12.31.90:80
203.30.189.86:80
203.24.108.134:80
23.227.38.38:80
203.22.223.126:80
203.23.106.130:80
203.24.108.112:80
185.162.231.38:80
185.171.230.72:80
203.30.191.241:80
203.28.9.40:80
31.43.179.110:80
185.238.228.103:80
185.238.228.163:80
172.67.192.27:80
130.61.150.132:80
172.67.3.108:80
185.162.231.78:80
185.162.231.91:80
45.8.107.171:80
203.23.103.67:80
203.23.104.15:80
203.23.106.25:80
185.162.228.14:80
203.30.190.222:80
203.28.9.178:80
45.8.105.192:80
203.24.102.243:80
203.32.121.208:80
203.32.120.21:80
45.14.174.81:80
203.24.108.78:80
203.28.9.146:80
45.12.31.96:80
203.30.190.7:80
45.12.30.92:80
203.32.120.255:80
45.14.174.63:80
185.238.228.95:80
162.247.243.161:80
191.97.14.26:999
172.67.167.73:80
162.247.243.148:80
203.32.120.74:80
45.8.106.100:80
203.28.9.192:80
203.28.9.244:80
203.23.106.47:80
203.28.8.44:80
203.28.8.104:80
185.162.228.239:80
185.162.230.25:80
203.30.189.35:80
203.28.9.76:80
203.32.121.127:80
45.8.106.140:80
203.30.191.75:80
185.162.229.161:80
185.171.231.10:80
45.12.30.253:80
45.14.174.16:80
203.24.109.54:80
172.67.172.154:80
141.193.213.173:80
185.238.228.228:80
162.247.243.236:80
191.101.251.37:80
172.67.75.172:80
185.238.228.211:80
188.114.96.248:80
188.114.97.18:80
172.67.181.79:80
91.226.97.176:80
203.13.32.188:80
203.30.188.25:80
185.162.229.124:80
185.171.230.213:80
203.22.223.183:80
45.12.31.140:80
203.32.121.247:80
45.12.30.235:80
185.171.231.59:80
185.162.229.108:80
45.8.107.8:80
172.67.171.208:80
188.114.96.2:80
141.193.213.23:80
172.67.191.229:80
172.67.181.215:80
172.67.167.161:80
203.24.109.206:80
185.162.231.129:80
203.30.188.16:80
185.162.228.128:80
172.67.171.215:80
172.67.170.19:80
172.67.192.13:80
141.193.213.60:80
172.67.10.96:80
203.24.102.22:80
185.162.228.84:80
203.24.103.129:80
203.24.103.247:80
203.23.106.226:80
203.30.191.203:80
185.162.231.208:80
203.30.188.61:80
45.12.31.252:80
203.30.191.82:80
45.14.174.1:80
203.24.103.112:80
141.193.213.190:80
172.67.25.30:80
172.67.130.251:80
172.67.167.209:80
172.67.167.108:80
185.171.231.156:80
185.162.228.91:80
23.227.38.189:80
45.14.174.223:80
203.30.191.153:80
185.162.231.156:80
185.162.230.209:80
203.23.104.48:80
203.22.223.120:80
172.67.171.205:80
191.101.251.142:80
172.67.3.146:80
203.23.103.80:80
45.8.106.218:80
45.8.105.242:80
203.32.120.241:80
141.193.213.56:80
172.64.173.2:80
117.158.177.205:9091
172.67.207.127:80
45.14.174.75:80
203.30.190.17:80
45.8.104.41:80
172.67.188.38:80
141.193.213.0:80
172.67.172.148:80
191.101.251.40:80
141.101.123.211:80
172.67.255.224:80
45.8.104.172:80
185.162.228.68:80
45.12.31.1:80
203.23.106.63:80
45.12.31.55:80
203.28.8.221:80
45.8.107.186:80
45.12.31.122:80
45.12.30.24:80
162.247.243.192:80
117.158.218.133:9091
203.24.102.25:80
203.30.190.192:80
45.14.174.123:80
45.12.30.3:80
185.171.231.68:80
203.24.108.166:80
203.28.8.225:80
185.171.230.251:80
45.8.107.19:80
203.28.8.202:80
45.8.104.118:80
185.162.230.35:80
185.171.230.92:80
203.34.28.148:80
45.8.105.15:80
91.226.97.201:80
185.171.230.132:80
203.13.32.214:80
203.22.223.177:80
203.13.32.45:80
45.8.104.246:80
172.67.181.33:80
172.67.181.214:80
172.67.180.54:80
172.67.180.35:80
203.30.189.9:80
203.24.108.180:80
203.22.223.52:80
203.24.103.177:80
203.24.109.190:80
203.30.188.149:80
203.32.120.140:80
45.8.107.181:80
216.24.57.3:80
191.101.251.237:80
172.67.43.252:80
172.67.165.59:80
191.101.251.115:80
172.67.70.20:80
103.21.244.23:80
172.67.167.74:80
203.23.106.31:80
45.12.31.188:80
203.30.189.202:80
23.227.38.191:80
45.8.106.127:80
185.162.230.98:80
203.32.120.182:80
203.24.103.60:80
203.23.103.162:80
203.30.188.15:80
203.13.32.172:80
203.24.108.93:80
185.162.231.245:80
91.226.97.70:80
203.28.8.181:80
203.24.103.235:80
185.162.230.214:80
203.30.190.208:80
23.227.38.49:80
45.14.174.142:80
203.30.188.145:80
203.24.108.105:80
203.13.32.147:80
203.28.8.27:80
203.32.121.28:80
188.114.96.153:80
172.67.0.38:80
185.238.228.34:80
188.133.152.125:8080
185.221.160.176:80
185.174.138.19:80
185.221.160.60:80
45.8.107.89:80
23.227.38.217:80
203.32.120.168:80
203.24.103.27:80
45.14.174.189:80
45.8.104.250:80
203.30.191.192:80
203.30.188.47:80
203.23.106.106:80
203.24.109.37:80
172.67.43.228:80
162.247.243.106:80
162.247.243.212:80
45.8.104.16:80
203.32.120.4:80
203.30.191.150:80
45.8.106.248:80
203.24.109.127:80
45.12.31.72:80
203.28.8.127:80
185.162.230.69:80
162.247.243.28:80
172.67.170.3:80
172.67.75.183:80
141.193.213.47:80
111.59.182.75:9091
172.67.0.5:80
172.67.254.145:80
203.24.108.127:80
203.28.8.138:80
203.24.102.205:80
45.8.107.205:80
185.162.228.123:80
203.24.108.151:80
185.171.230.32:80
203.24.102.149:80
203.30.190.149:80
45.8.105.35:80
45.14.174.222:80
203.24.102.31:80
185.162.228.82:80
23.227.38.29:80
203.24.109.8:80
45.8.106.187:80
203.32.121.169:80
23.227.38.28:80
203.13.32.70:80
203.32.120.98:80
185.162.230.194:80
91.226.97.88:80
203.23.104.146:80
91.226.97.207:80
203.23.106.23:80
185.162.228.170:80
203.28.8.102:80
203.34.28.45:80
203.32.120.61:80
203.13.32.48:80
185.162.229.229:80
203.24.103.145:80
203.34.28.96:80
185.238.228.69:80
185.238.228.81:80
191.101.251.4:80
203.28.8.188:80
203.24.103.137:80
203.32.121.170:80
185.162.229.31:80
185.162.231.165:80
45.8.104.97:80
203.22.223.240:80
203.30.188.0:80
45.12.31.64:80
203.24.108.47:80
203.30.190.99:80
45.14.174.68:80
203.24.109.193:80
203.24.102.86:80
172.67.2.94:80
172.67.171.223:80
203.32.121.129:80
185.238.228.231:80
203.23.104.244:80
203.32.121.72:80
45.14.174.242:80
203.24.102.131:80
185.171.230.248:80
203.34.28.232:80
203.30.188.120:80
45.8.107.243:80
185.162.230.165:80
45.8.107.194:80
203.13.32.122:80
203.23.104.219:80
203.22.223.37:80
185.171.231.237:80
203.23.106.181:80
203.24.103.236:80
185.162.228.157:80
185.162.231.20:80
172.67.192.62:80
211.142.96.250:9091
103.21.244.11:80
91.226.97.108:80
203.30.191.210:80
203.32.120.229:80
203.34.28.75:80
185.162.228.222:80
45.8.104.114:80
45.12.30.124:80
185.162.228.133:80
203.23.106.86:80
203.28.9.87:80
172.67.216.96:80
103.21.244.14:80
103.21.244.30:80
172.67.167.24:80
45.8.106.220:80
185.162.229.122:80
45.12.31.203:80
203.30.191.226:80
185.162.230.154:80
203.22.223.166:80
203.24.109.23:80
185.171.231.162:80
203.23.106.101:80
203.32.120.78:80
203.28.9.168:80
45.8.105.18:80
203.30.189.203:80
45.8.106.117:80
203.23.104.191:80
203.24.109.216:80
203.30.190.162:80
203.28.9.203:80
203.32.120.240:80
185.171.230.33:80
203.24.108.125:80
203.28.8.180:80
203.24.109.125:80
203.30.189.229:80
185.171.231.247:80
172.67.75.161:80
172.67.191.238:80
185.162.228.126:80
141.193.213.63:80
172.64.163.2:80
172.67.134.28:80
45.8.106.125:80
203.24.103.26:80
203.32.121.110:80
185.162.229.29:80
45.14.174.157:80
185.162.228.200:80
203.30.190.203:80
203.13.32.217:80
185.162.231.135:80
185.162.229.186:80
31.43.179.193:80
172.65.206.64:80
172.64.132.2:80
172.67.181.195:80
172.67.0.18:80
172.67.34.7:80
172.67.70.233:80
172.67.3.92:80
172.67.167.45:80
203.34.28.132:80
185.162.231.43:80
23.227.38.157:80
203.32.121.242:80
45.14.174.40:80
203.13.32.24:80
203.32.121.240:80
185.171.231.254:80
203.24.103.157:80
203.23.103.69:80
203.22.223.0:80
185.162.231.193:80
91.226.97.99:80
203.32.120.199:80
162.247.243.185:80
172.67.170.1:80
172.67.181.233:80
172.67.192.30:80
172.67.56.51:80
162.247.241.4:80
172.64.133.99:80
203.24.109.82:80
45.12.30.178:80
203.23.103.176:80
203.13.32.144:80
185.162.229.17:80
185.171.231.89:80
45.12.30.239:80
203.24.108.251:80
45.12.30.2:80
45.14.174.27:80
45.12.31.214:80
141.193.213.191:80
172.67.192.53:80
185.238.228.144:80
185.238.228.77:80
162.247.243.24:80
191.101.251.71:80
62.193.68.80:1976
218.64.253.196:9091
172.67.222.111:80
172.67.164.242:80
203.24.109.251:80
172.67.70.128:80
141.101.121.253:80
172.67.167.153:80
203.24.108.53:80
185.162.231.197:80
203.23.106.17:80
203.24.109.124:80
203.23.106.126:80
203.28.9.106:80
203.30.190.196:80
203.23.106.156:80
203.30.190.75:80
203.30.190.110:80
31.43.179.184:80
172.67.187.240:80
190.93.245.41:80
172.64.80.55:80
203.22.223.175:80
172.67.177.59:80
45.12.30.203:80
185.162.230.56:80
45.8.105.206:80
203.30.191.138:80
45.8.104.39:80
203.30.188.124:80
203.13.32.224:80
45.8.106.104:80
203.30.190.63:80
203.13.32.241:80
203.34.28.77:80
203.30.191.195:80
23.227.38.63:80
45.8.105.20:80
203.23.104.83:80
203.24.102.136:80
203.24.102.32:80
31.43.179.152:80
172.67.171.206:80
185.238.228.246:80
103.21.244.34:80
172.67.3.138:80
203.24.108.169:80
185.171.230.86:80
203.30.190.146:80
203.23.106.166:80
203.23.104.95:80
203.30.190.3:80
203.13.32.107:80
203.30.188.26:80
203.28.9.110:80
203.28.8.117:80
185.162.229.37:80
45.14.174.143:80
45.12.31.158:80
203.30.189.51:80
185.162.229.192:80
185.162.231.196:80
185.162.231.62:80
185.171.231.222:80
91.226.97.167:80
185.162.228.72:80
45.8.105.194:80
203.30.191.122:80
45.12.30.14:80
185.162.228.215:80
185.162.229.162:80
203.30.189.214:80
45.12.31.30:80
172.67.43.190:80
172.67.150.25:80
172.64.149.2:80
141.101.115.245:80
162.247.243.135:80
45.12.31.177:80
185.171.231.64:80
23.227.38.148:80
203.24.109.233:80
203.28.8.23:80
185.162.231.23:80
203.13.32.137:80
185.162.229.153:80
185.162.228.26:80
45.14.174.66:80
203.30.190.73:80
185.162.228.225:80
45.8.105.61:80
203.32.120.196:80
31.43.179.196:80
188.114.96.137:80
141.193.213.178:80
172.67.75.178:80
185.238.228.3:80
185.171.231.28:80
203.28.9.67:80
120.237.144.57:9091
203.28.9.177:80
203.13.32.32:80
172.67.3.74:80
45.12.31.198:80
203.30.191.77:80
23.227.38.249:80
203.24.102.162:80
172.67.181.185:80
172.67.3.117:80
203.23.103.149:80
172.67.26.8:80
203.24.108.132:80
203.32.120.224:80
203.32.121.19:80
45.14.174.92:80
45.12.30.175:80
162.247.243.136:80
203.22.223.101:80
203.23.104.105:80
91.226.97.25:80
185.171.230.9:80
203.32.120.208:80
141.101.123.10:80
23.227.38.11:80
203.24.108.153:80
203.32.120.65:80
45.12.31.200:80
45.8.104.130:80
172.67.175.139:80
203.30.191.22:80
203.13.32.37:80
185.238.228.238:80
162.247.243.115:80
172.67.3.95:80
45.8.106.124:80
203.23.106.105:80
23.227.38.207:80
185.162.230.252:80
172.67.43.137:80
162.247.243.4:80
203.32.121.14:80
45.8.105.187:80
185.162.230.15:80
185.171.230.34:80
185.162.231.213:80
45.8.106.207:80
203.28.9.96:80
203.23.106.146:80
203.24.103.217:80
185.162.228.3:80
23.227.38.152:80
203.32.120.233:80
203.30.191.71:80
203.24.109.234:80
203.32.121.122:80
45.8.105.247:80
162.247.243.227:80
203.30.188.208:80
203.30.191.106:80
45.8.107.51:80
203.30.188.205:80
23.227.38.243:80
203.30.191.12:80
45.12.30.16:80
185.162.229.171:80
203.30.189.120:80
203.24.103.180:80
203.30.189.255:80
203.23.106.247:80
203.23.104.91:80
203.23.104.63:80
45.8.104.223:80
203.24.103.61:80
172.67.44.6:80
185.238.228.187:80
141.193.213.140:80
141.101.123.19:80
172.67.3.129:80
91.226.97.63:80
185.171.230.49:80
185.171.231.135:80
45.8.106.253:80
203.30.189.125:80
203.24.109.172:80
203.13.32.69:80
203.24.103.149:80
91.226.97.20:80
172.67.43.80:80
172.67.43.91:80
162.247.243.3:80
188.114.97.1:80
203.24.102.219:80
203.30.189.65:80
45.12.30.75:80
91.226.97.159:80
203.32.121.220:80
203.24.108.28:80
141.193.213.254:80
172.67.75.179:80
162.247.243.254:80
203.30.191.227:80
203.24.108.154:80
203.24.109.249:80
185.171.230.23:80
91.226.97.169:80
45.8.105.82:80
172.67.170.11:80
172.67.75.162:80
203.28.9.175:80
203.23.106.190:80
191.101.251.79:80
172.67.176.57:80
203.13.32.65:80
45.8.104.189:80
185.238.228.109:80
172.67.70.152:80
45.8.104.104:80
172.67.75.2:80
172.67.75.17:80
23.227.38.43:80
203.24.108.162:80
172.67.182.100:80
91.226.97.38:80
203.24.102.80:80
203.28.9.159:80
185.162.228.6:80
45.12.30.204:80
203.30.191.250:80
203.13.32.222:80
203.13.32.202:80
45.8.105.195:80
141.101.121.217:80
203.23.104.23:80
203.24.103.37:80
45.8.105.6:80
45.12.30.202:80
172.67.185.189:80
185.238.228.58:80
172.67.3.144:80
203.23.103.127:80
45.12.31.168:80
203.23.103.31:80
203.28.9.235:80
203.23.104.54:80
203.24.102.231:80
31.43.179.48:80
191.101.251.119:80
172.67.167.220:80
203.32.120.188:80
203.24.102.229:80
203.34.28.181:80
45.12.30.181:80
203.23.104.72:80
203.13.32.36:80
203.23.103.170:80
45.8.107.46:80
203.22.223.184:80
185.162.230.101:80
185.162.230.126:80
162.247.241.11:80
141.193.213.16:80
191.101.251.191:80
172.67.122.146:80
172.67.3.105:80
203.23.103.88:80
23.227.38.57:80
203.30.188.19:80
185.162.231.138:80
203.30.189.234:80
23.227.38.99:80
185.162.231.2:80
45.8.107.153:80
203.24.102.38:80
203.32.120.92:80
203.22.223.149:80
185.162.230.246:80
203.24.109.24:80
203.13.32.75:80
45.12.31.127:80
203.22.223.141:80
185.171.231.110:80
203.23.106.250:80
185.171.230.210:80
203.24.102.188:80
203.22.223.54:80
203.23.106.5:80
203.30.190.134:80
31.43.179.97:80
31.43.179.145:80
162.247.243.170:80
172.67.75.186:80
172.67.43.212:80
172.64.160.44:80
172.67.23.91:80
203.23.104.133:80
23.227.38.90:80
203.22.223.137:80
203.28.8.166:80
45.12.30.5:80
203.13.32.86:80
45.14.174.170:80
203.32.121.13:80
185.171.231.195:80
203.30.188.122:80
45.8.104.181:80
45.8.104.170:80
203.34.28.247:80
45.8.107.221:80
203.22.223.212:80
203.22.223.140:80
45.8.104.226:80
203.30.191.99:80
203.30.188.55:80
203.32.121.207:80
45.8.104.95:80
203.30.188.243:80
45.8.106.79:80
203.24.103.198:80
203.23.104.68:80
31.43.179.76:80
191.101.251.158:80
190.93.244.24:80
141.101.123.27:80
203.23.103.107:80
45.12.31.156:80
185.162.230.162:80
203.30.189.240:80
45.12.31.67:80
203.28.9.218:80
203.13.32.94:80
203.24.103.206:80
203.23.106.54:80
203.23.103.150:80
203.24.102.235:80
203.23.103.238:80
203.30.189.56:80
31.43.179.128:80
172.67.0.43:80
172.67.75.204:80
188.114.98.83:80
188.114.97.25:80
203.30.189.186:80
45.12.30.132:80
203.23.104.175:80
45.14.174.138:80
203.34.28.28:80
203.32.121.80:80
203.24.103.158:80
203.30.188.253:80
203.24.103.6:80
172.67.3.88:80
203.24.108.9:80
23.227.38.183:80
91.226.97.182:80
31.43.179.92:80
TelegramGoodsInBot>proxyline.py:
import asyncio

from aioproxyline import ProxyLine


async def get_balance(api_token: str) -> None:
    async with ProxyLine(api_token=api_token) as client:
        result = await client.get_balance()  # Balance(balance=0.0, partner_balance=0.0)


asyncio.run(get_balance(api_token='10S4hhFr2CARCBjyYIJMu2QmoLGuprebMFlAI3A6'))
TelegramGoodsInBot>README.md:
##Telegram GoodsinBot

A store with the functionality of multi-cities. Магазин в Телеграм: каталог, оплата QIWI и YooMoney, корзина, мульти-города и мульти-продавцы, рассылки, поддержка мультиязычности и многое другое


##Модули
управление локацией пользователя, хранение города пользователя
управление языками интерфейса
управление товарами и категориями товаров
управление магазинами
управление местами отдыха, артистами, событиями
управление кружками, местами обучения
управление частными объявлениями
управление балансами пользователей
управление заказами и доставкой товаров
управление рассылками сообщений


##Функции для пользователя
каталог двух уровней, категория - товар корзина
поддержка (контакты) - ссылка в диалог с администратором
FAQ - сообщение для пользователей с HTML разметкой
подробная Статистика бота: кол-во пополнений, покупок, пользователей, позиций, категорий, чистой прибыли
определение местонахождения пользователя


##Функции администратора
режим технических работ
проверка наличия обнолвения при запуске
активация/деактивация функций продажи и оплаты
добавление неограниченного количества глобальных администраторов
роль администратора магазина, управляющего своими товарами в каталоге
добавление неограниченного количества администраторов магазинов
удобная и многофункциональная админ панель
определение и хранение города нахождения товара
поиск покупателей и просмотр профилей
поиск чеков покупок
рассылка сообщений всем пользователям бота
изменение и пополнение баланса пользователя
отчет о продажах продавцов


##Оплата товаров
используется библиотеки QIWI и YooMoney
настраивается администратором бота через админку
проверка работоспособности из админки
вывод баланса кошелька QIWI


##Каталог и товары
User-friendly каталог
товары имеют одно изображение
гибкое управление товарами администраторами
выгрузка всех товаров


##Защита
админ-фильтры на все хендлеры, гарантирующие приватность админ функционала
защита от оплаты в тенге при пополнении баланса
защита от неправильного HTML синтаксиса
защита от повторной выдачи баланса
защита от спама в боте (Middlewares)


##настройки settings.ini
установить токен Бота, полученный у @BotFather
установить Telegram ID администратора


##Настройка
Скопируйте папку бота. Перейдите в папку бота.
Выполните в командной строке "pip install -r requirements.txt".
Заполните файл settings.ini.
Стартовать бот в командной строке: python3 main.py.
Заполнить информационные поля.
Наполнить каталог товарами.
Привлекать пользователей в каталог.


##Процесс администрирования площадки
Согласование продавцов.
Администрирование каталога.
Администрирование денежных средств.
Поддержка и ведение сделок, разрешение споров.


##Процесс покупки для покупателя
Выбор товара.
Пополнение счета.
Ожидание звонка продавца и уточнение параметров домтааки.
Получение товара.
Подтверждение получения.
Отправка отзыва о покупателей.


#Процесс продажи для продавца
Получение сообщения о заказе.
Звонок покупателю.
Отправка товара покупателю.
Получение отзыва о покупателей.


###TODO:


Работающий экземпляр пока только по России в 192 городах: https://t.me/Goodsinbot Чтобы торговать своими товарами в текущем экземпляре, отправьте запрос на продавца из бота, нажав "Я продавец". По вопросам пишите пожалуйста в телеграм: @raclear

TelegramGoodsInBot>requirements.txt
aiogram
colorlog
requests
bs4
beautifulsoup4
pyQiwiP2P
aiohttp
APScheduler==3.9.1
colorama
async_class
yoomoney
geopy
coinbase
TelegramGoodsInBot>sendmessages.py:
#!/usr/bin/env python3
from telethon.sync import TelegramClient, connection
from telethon.tl.functions.messages import GetDialogsRequest
from telethon.tl.types import InputPeerEmpty, InputPeerChannel, InputPeerUser
#from telethon.errors.rpcerrorlist import PeerFloodError, UserPrivacyRestrictedError
from telethon.errors.rpcerrorlist import (UserPrivacyRestrictedError,
                                          UserNotMutualContactError,
                                          FloodWaitError,
                                          PeerFloodError,
                                          UserChannelsTooMuchError,
                                          UserDeactivatedBanError,
                                          PhoneNumberBannedError,
                                          UsernameInvalidError,
                                          ChatWriteForbiddenError)

from telethon.tl.functions.channels import InviteToChannelRequest
import config
import configparser
import tqdm
import os, sys
import socks
import csv
import traceback
import datetime
import time
import random
import requests, socket
from sutils import *
from tgbot.services.api_sqlite_advert import *

print(type(datetime))

def get_time_str():
    return datetime.now().strftime("%H:%M:%S")

cur_time = datetime.datetime.now()

re="\033[1;31m"
gr="\033[1;32m"
cy="\033[1;36m"

def banner():
    print(f"""
´´´´¶¶¶¶¶¶´´´´´´¶¶¶¶¶¶
´´¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶¶¶¶¶¶
´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶ ´¶¶¶¶¶´
´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´´´¶¶¶¶¶¶¶¶
´´´´´´´´´´´¶¶¶¶
{re}

by rashidovich
        """)

#check_phones()

cpass=get_all_avtgaccountsend()
#print(cpass)
for cp in cpass:
    print(cp)
    if cp[5] in ['wait2', 'banned', 'wait3']: continue
    try:
        account_id = cp[0]
        api_id = cp[1]
        api_hash = cp[2]
        phone = cp[3]
        waits24field = cp[9]
        print(f"Работаем с аккаунтом:{phone} | ЕГО время старта: {waits24field}.")

        if config.PROXY_ENABLED:
            s = socks.socksocket()
            rnd_proxy = random.choice(config.PROXY_IPS).split(":")
            print(f"Подключение к Телеграмм с прокси {rnd_proxy}!")
            client = TelegramClient(phone, api_id, api_hash, proxy=s.set_proxy(socks.HTTP, rnd_proxy[0], rnd_proxy[1]) )
        else:
            print("Подключение к Телеграмм без прокси!")
            client = TelegramClient(phone, api_id, api_hash)
        #client.start()
        #print(f'[+] Успешная аутентификация - {phone}')
        #client.disconnect()
        client.connect()
        if not client.is_user_authorized():
            banner()
            client.start()
            print(f'[+] Успешная аутентификация - {phone}')
            client.disconnect()
            #client.connect()

    except PhoneNumberBannedError:
        print(f" | Ошибка: аккаунт {account_id} был удалён!")
        update_tgaccounts(account_id, pole="banned")
        continue
    except FloodWaitError as e:
        print(
            f"{cur_time} | Ошибка: Таймаут на {e.seconds} секунд, это примерно {round(e.seconds / 60)} минут \n"
        )
        if config.CHECK_TIMEOUT:
            for _ in range(e.seconds):
                time.sleep(1)
        else:
            cur_sec = cur_time.second
            sec = e.seconds + cur_sec
            sec = sec % (24 * 3600)
            hour = sec // 3600
            sec %= 3600
            min = sec // 60
            sec %= 60

            print(f"{str(cur_time.hour)}:{str(cur_time.minute)}")
            utime = time.mktime(cur_time.timetuple())
            print(f"{cur_time} | Аккаунт {account_id} уходит в режим ожидания на {hour} часов, {min} минут, {sec} секунд")
            break

    #os.system('clear')
    banner()


    state = "created"
    #sended = 0
    start = 0
    count = 39
    rows =  firstgeo_tosend(state, start, count)
    users = []
    for row in rows:
        user = {
            'username': row[1],
            'id': int(row[2]),
            'access_hash': int(row[3]),
            'name': row[4],
        }
        users.append(user)
    print(gr+"[1] send sms by user ID\n[2] send sms by username ")
    mode = int(input(f"{gr}Input : {re}"))

    #message = input(gr+"[+] Enter Your Message : "+re)
    message = "С наступающим Новым Годом друзья! Желаем счастья, радости, достатка и много-много интересного в Новом году! Команда @Goodsinbot"

    n = 0
    print(f"Выбрано ТГ аккаунтов для инвайта: {len(users)}")
    cur_time = datetime.datetime.now()
    print(f"{str(account_id)}|{str(cur_time)}")
    h = get_tgaccounts_statecounts(account_id)
    print(h)
    sended = h[0]
    sended_cs = 0
    f = 0
    not_sended= 0
    #users = ['raclear', 'Oleg2023long', 'OlegDJI']
    blockedu = ['Admin', 'Bot', 'bot']

    for user in users:
        n += 1
        time.sleep(2)
        try:
            print(
                n,
                f"Пробуем отправить сообщение пользователю с аккаунтом ID {user['id']}",
            )
            if mode == 1:
                receiver = InputPeerUser(user['id'],user['access_hash'])
            elif mode == 2:
                if user['username'] == "" or user['username'] in blockedu or user['access_hash'] < 0: # or user['username'].startswith('bot'):
                    continue
                receiver = client.get_input_entity(user['username'])
            else:
                print(f"{re}[!] Invalid Mode. Exiting.")
                client.disconnect()
                sys.exit()
            print(f"{gr}[+] Waiting 90 seconds.")
            time.sleep(90)
            print(f"{gr}[+] Sending Message to:", user['username'])
            client.send_message(receiver, message.format(user['name']))
            print(cp[0])
            print(user)
            update_tgparsex(cp[0], statesend='sended')
            update_tgaccounts(cp[0], pole='sended24')
            sended += 1
            sended_cs += 1
            print(
                f"{gr}+ С:{sended}/СК:{sended_cs} | Отправили пользователю: {user['username']}"
            )
                #sended += 1
                #sended_cs += 1
            print(f"{gr}[+] Waiting 90 seconds.")
            time.sleep(90)
            continue
        except PeerFloodError:
            print(re+"[!] Getting Flood Error from telegram. \n[!] Script is stopping now. \n[!] Please try again after some time.")
            client.disconnect()
            update_tgaccounts(cp[0], pole='waifors24')
            break
            #sys.exit()
        except Exception as e:
            print(f"{re}[!] Error:", e)
            print(f"{re}[!] Trying to continue...")
            continue
    client.disconnect()
    print("Done. Message sent to all users.")

TelegramGoodsInBot>settings_inv.ini:
channel_to_invite = XXXX
parse_channel_ids = XXXX
delay_msg = XXXX
count_users_send = XXXX
numbers = XXXX
log = 1


TelegramGoodsInBot>settings.ini:
# - *- coding: utf- 8 - *-
[settings]
token=6001252262:AAEBaTZvtISm0GpI-h4CsSu6VwzdwDdDNxw
admin_id=XXXXXXXXX
#admin = XXXXXXXXX, XXXXXXXXX, XXXXXXXXX, XXXXXXXXX
shopadmin_id=XXXXXXXXX
default_language=eng
#,5183434188
TelegramGoodsInBot>setup_acc.py:
#!/bin/env python3
from tgbot.services.api_sqlite import *
"""
*
you can re run setup.py 
if you have added some wrong value

"""
re="\033[1;31m"
gr="\033[1;32m"
cy="\033[1;36m"

import os, sys
import time

def banner():
    print(f"""
´´´´¶¶¶¶¶¶´´´´´´¶¶¶¶¶¶
´´¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶¶¶¶¶¶
´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´´´¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶´´¶¶¶¶¶
¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶ ´¶¶¶¶¶´
´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´¶¶¶¶¶¶¶¶¶¶¶¶¶
´´´´´´´´´¶¶¶¶¶¶¶¶
´´´´´´´´´´´¶¶¶¶
{re}

by rikudo
        """)
        
def requirements():
    def csv_lib():
        banner()
        print(f'{gr}[{cy}+{gr}]{cy} this may take some time ...')
        os.system("""
			pip3 install cython numpy pandas
			python3 -m pip install cython numpy pandas
			""")

    banner()
    print(f'{gr}[{cy}+{gr}]{cy} it will take upto 10 min to install csv merge.')
    input_csv = input(
        f'{gr}[{cy}+{gr}]{cy} do you want to enable csv merge (y/n): '
    ).lower()
    if input_csv == "y":
        csv_lib()
    print(f"{gr}[+] Installing requierments ...")
    os.system("""
		pip3 install telethon requests configparser
		python3 -m pip install telethon requests configparser
		touch config.data
		""")
    banner()
    print(gr+"[+] requierments Installed.\n")


def config_setup():
    import configparser
    banner()
    cpass = configparser.RawConfigParser()
    cpass.add_section('cred')
    xid = input("[+] enter api ID : " )
    cpass.set('cred', 'id', xid)
    xhash = input("[+] enter hash ID : " )
    cpass.set('cred', 'hash', xhash)
    xphone = input("[+] enter phone number : " )
    cpass.set('cred', 'phone', xphone)
    with open('config.data', 'w') as setup:
        cpass.write(setup)
        invited24 = 0
        add_account_todb(xid, xhash, xphone, 0,'available')
    print(f"{gr}[+] setup complete !")

def merge_csv():
    import pandas as pd
    import sys
    banner()
    file1 = pd.read_csv(sys.argv[2])
    file2 = pd.read_csv(sys.argv[3])
    print(f'{gr}[{cy}+{gr}]{cy} merging {sys.argv[2]} & {sys.argv[3]} ...')
    print(f'{gr}[{cy}+{gr}]{cy} big files can take some time ... ')
    merge = file1.merge(file2, on='username')
    merge.to_csv("output.csv", index=False)
    print(f'{gr}[{cy}+{gr}]{cy}' + ' saved file as "output.csv"\n')

def update_tool():
	import requests as r
	banner()
	source = r.get("https://raw.githubusercontent.com/th3unkn0n/TeleGram-Scraper/master/.image/.version")
	if source.text == '3':
		print(gr+'['+cy+'+'+gr+']'+cy+' alredy latest version')
	else:
		print(gr+'['+cy+'+'+gr+']'+cy+' removing old files ...')
		os.system('rm *.py');time.sleep(3)
		print(gr+'['+cy+'+'+gr+']'+cy+' getting latest files ...')
		os.system("""
			curl -s -O https://raw.githubusercontent.com/th3unkn0n/TeleGram-Scraper/master/add2group.py
			curl -s -O https://raw.githubusercontent.com/th3unkn0n/TeleGram-Scraper/master/scraper.py
			curl -s -O https://raw.githubusercontent.com/th3unkn0n/TeleGram-Scraper/master/setup.py
			curl -s -O https://raw.githubusercontent.com/th3unkn0n/TeleGram-Scraper/master/smsbot.py
			chmod 777 *.py
			""");time.sleep(3)
		print(gr+'\n['+cy+'+'+gr+']'+cy+' update compled.\n')

try:
    if any ([sys.argv[1] == '--config', sys.argv[1] == '-c']):
        print(f'{gr}[{cy}+{gr}]{cy} selected module : {re}{sys.argv[1]}')
        config_setup()
    elif any ([sys.argv[1] == '--merge', sys.argv[1] == '-m']):
        print(f'{gr}[{cy}+{gr}]{cy} selected module : {re}{sys.argv[1]}')
        merge_csv()
    elif any ([sys.argv[1] == '--update', sys.argv[1] == '-u']):
        print(f'{gr}[{cy}+{gr}]{cy} selected module : {re}{sys.argv[1]}')
        update_tool()
    elif any ([sys.argv[1] == '--install', sys.argv[1] == '-i']):
    	requirements()
    elif any ([sys.argv[1] == '--help', sys.argv[1] == '-h']):
    	banner()
    	print("""$ python3 setup.py -m file1.csv file2.csv
			
	( --config  / -c ) setup api configration
	( --merge   / -m ) merge 2 .csv files in one 
	( --update  / -u ) update tool to latest version
	( --install / -i ) install requirements
	( --help    / -h ) show this msg 
			""")
    else:
        print('\n'+gr+'['+re+'!'+gr+']'+cy+' unknown argument : '+ sys.argv[1])
        print(f'{gr}[{re}!{gr}]{cy} for help use : ')
        print(f'{gr}$ python3 setup.py -h' + '\n')
except IndexError:
    print('\n'+gr+'['+re+'!'+gr+']'+cy+' no argument given : '+ sys.argv[1])
    print(f'{gr}[{re}!{gr}]{cy} for help use : ')
    print(
        f'{gr}[{re}!{gr}]{cy} https://github.com/th3unkn0n/TeleGram-Scraper#-how-to-install-and-use'
    )
    print(f'{gr}$ python3 setup.py -h' + '\n')


TelegramGoodsInBot>setup.py:
from distutils.core import setup

setup(
    name='bot3101f',
    version='1.3',
    packages=['tgbot', 'tgbot.data', 'tgbot.utils', 'tgbot.utils.misc', 'tgbot.handlers', 'tgbot.services',
              'tgbot.keyboards', 'tgbot.middlewares', 'tgphotosender'],
    url='https://t.me/Goodsinbot',
    license='GPL 3.0',
    author='Oleg Aliullov',
    author_email='oaliullov@gmail.com',
    description='Marketplace Telegram Bot'
)


TelegramGoodsInBot>sutils.py:
#!/usr/bin/env python3
from tgbot.services.api_sqlite_advert import *
import datetime
import time

def get_time_str():
    return datetime.now().strftime("%H:%M:%S")

cur_time = datetime.datetime.now()

#выбираем аккаунты - available и wait по времени
#выбираем список для инвайта - по группе или по гео
#выбираем группу для инвайта, вводим группу для инвайта
#инвайтим - ставим отметки аккаунтам

def check_phones(reset="no"):
    all_accs=get_all_tgaccounts()
    for acc in all_accs:
        print(str(acc[0])+str(acc[4])+str(acc[8])+str(acc[9]))
        if acc[8] is None or str(acc[4]) not in ["banned", "wait2", "wait3"]: #acc[8] is None or
            update_tgaccounts(acc[0], pole='available')
        #if reset == "yes":
        #    update_tgaccounts(acc[0], pole="reset")

        if acc[4] == 'wait' and acc[8] is not None:
            dtwait = datetime.datetime.strptime(acc[10], '%Y-%m-%d %H:%M:%S')
            utime = time.mktime(cur_time.timetuple())
            print(utime)
            udtwait = time.mktime(dtwait.timetuple())
            print(udtwait)
            #Проверить если номеру пора уходить из режима ожидания
            if (utime >= udtwait and str(acc[4]) != "wait2" and str(acc[4]) != "banned" and str(acc[4]) != "wait3"):
                update_tgaccounts(acc[0], pole='available')
                print(f"{str(dtwait.hour)}:{str(dtwait.minute)}")

    return acc[0]
TelegramGoodsInBot>testneon.py:
import asyncio
import json
import random
import datetime
import time

import requests
import subprocess

import aiogram
from aiogram import Dispatcher
from aiogram import executor
from aiogram import Bot, types
from tgbot.loader import bot

from tgbot.services.api_sqlite import get_users_by_cities, get_users_by_citiesx, get_all_usersx


async def send_mes2():
	msg = await bot.send_photo(chat_id=919148970, photo=open("img/msg1.png", "rb"))
	file_id = msg.photo[0].file_id
	print(file_id)
	await asyncio.sleep(3)

async def send_mes(user_id, message, caption=""):
	await bot.send_photo(chat_id=user_id,
	                    photo=message,
	                    caption=caption) #post[9] if post[9] else None)await bot.send_photo(
	await bot.send_message(user_id, message, disable_web_page_preview=True)
	

cities = get_users_by_cities()
#users = get_all_usersx()
#for user in users:
for city in cities:
	#print(user)
	subprocess.run(["python3", "neon.py", f"-t{city['user_city']}, привет. Я Telegram Goods In Bot из Telegram.", f"-fimg/msg0002{city['user_city_id']}.png"])
	#image = open(f"img/msg{city['user_city_id']}.png", 'rb')
	#image = open(f"img/msg{user['user_city_id']}.png", 'rb')
	#caption="Hi"
	#send_mes(user['user_id'], image, caption)

#send_mes2()

TelegramGoodsInBot>tgev.py:
from telethon import TelegramClient
import random

# Тут вставляй свои данные с https://my.telegram.org/apps

api_id = "347132"
api_hash = "0878ef5125b0b4d37e4187137b9a34bf"

from telethon import TelegramClient, events
client = TelegramClient('anon', api_id, api_hash)
client.start()

@client.on(events.NewMessage(777000))
async def main(event):
	print(event.message)
TelegramGoodsInBot>tools.py:
from textwrap import wrap

def transform_color(hex_color):
    try:
        color = [_/255.0 for _ in map(lambda x: int(x, 16), wrap(hex_color, 2))]
    except ValueError as e:
        raise Exception(f"Invalid color format: {hex_color}") from e
    if len(color) != 3:
        raise Exception(f"Invalid color format: {hex_color}")
    return color

TelegramGoodsInBot>tron.py:
from tronpy import Tron

# connect to the Tron blockchain
client = Tron()

# create a Tron wallet and print out the wallet address & private key
def create_wallet(): 
    wallet = client.generate_address()
    print("Wallet address:  %s" % wallet['base58check_address'])
    print("Private Key:  %s" % wallet['private_key'])

create_wallet()
TelegramGoodsInBot>uploadproductsdata.py:

# - *- coding: utf- 8 - *-
import asyncio
import os
import csv
from datetime import datetime
#import requests

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from aiogram import Bot, types, Dispatcher
from aiogram.types import FSInputFile


#from tgbot.services.api_sqlite import get_position_of_day


API_TOKEN = '5337905343:AAFnZEexDdOAhn16AEw1zofEzVrPPEag89Q'
#API_TOKEN = '5337905343:AAFnZEexDdOAhn16AEw1zofEzVrPPEag89Q'
CHANNEL_ID = 919148970


bot = Bot(token=API_TOKEN) #ParseMode.  parse_mode=HTML
dp = Dispatcher()

positions = []


'''def send_photo_tb(photo):
    #with FSInputFile(photo) as photo:
    #with open('uploadproductdata/' + position['Photo'], 'rb') as photo:
    with open(photo, 'rb') as photo:
        id_photo =  bot.send_photo(CHANNEL_ID, photo, disable_notification=True)
        idp = id_photo['photo'][-1]['file_id'] 


        
@dp.message(content_types=['photo'])
def scan_message(message: types.Message):
    document_id = message.photo[0].file_id
    file_info = bot.get_file(document_id)
    print(f'file_id: {file_info.file_id}')
    print(f'file_path: {file_info.file_path}')
    print(f'file_size: {file_info.file_size}')
    print(f'file_unique_id: {file_info.file_unique_id}')
    return file_info.file_id'''

# Отправка рассылки
def function_sendphoto(message, caption='test', ct='photo'):
    try:
        print("||||")
        if ct == "text":
            bot.send_message(user['user_id'], message, disable_web_page_preview=True)
        elif ct == "photo":
            with open(message, 'rb') as photo:
                bot.send_photo(chat_id=CHANNEL_ID, photo=photo, caption=caption or None)
                print("|||")
                file_id = message.photo[0].file_id
                print(file_id)
    except Exception:
        pass



fieldnames = ["Cat1", "Cat2", "Code", "Art", "Name", "Price", "Weight", "WeightType", "Description",  "photo"]
with open("uploadproductdata/data4.csv", encoding='UTF-8') as f:
    rows = csv.reader(f,delimiter=",",lineterminator="\n")
    next(rows, None)
    for row in rows:
        position = {
            'Cat1': row[0],
            'Cat2': row[1],
            'Code': row[2],
            'Art': row[3],
            'Name': row[4],
            'Price': row[5],
            'Weight': row[6],
            'WeightType': row[7],
            'Description': row[8],
            'Photo': row[9],
        }
        #photo = open("uploadproductdata/" + str(row[9]), 'rb')
        photo = f"uploadproductdata/{str(row[9])}"
        #photo=open(photof, 'rb')
        function_sendphoto(photo, "test", "photo")



        #idp = send_photo_tb('uploadproductdata/' + position['Photo'])
        #photof = FSInputFile('uploadproductdata/' + str(row[9])

        #id_photo = bot.send_photo(chat_id=CHANNEL_ID, photo=photo) # этот метод поможет получить file_id
        #idp = id_photo['photo'][-1]['file_id'] # 
        #with open(photof, 'rb') as photo:
        #bot.send_photo(chat_id=chat_id, photo=open(photof, 'rb'))
        #id_photo = bot.send_photo(CHANNEL_ID, photof, disable_notification=True)
        #filef_id = message.photo[-1].file_id
        #bot.send_photo(chat_id=chat_id, photo=file_id)
        #idp = id_photo['photo'][0]['file_id'] 
        #print(filef_id)

        #send_photo_tb(position['Photo'])
        #position['PhotoUrl'] = scan_message()


        print(position)

        positions.append(position)




there might be missing data but this is everything. its in russian i dont understand shit looking for your response
